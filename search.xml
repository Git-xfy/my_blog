<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>跟踪 —— 局部地图跟踪</title>
      <link href="/2025/05/13/orbslam2-11/"/>
      <url>/2025/05/13/orbslam2-11/</url>
      
        <content type="html"><![CDATA[<h1 id="Local-Map-Tracking"><a href="#Local-Map-Tracking" class="headerlink" title="Local Map Tracking"></a>Local Map Tracking</h1><h2 id="1-目标与定位"><a href="#1-目标与定位" class="headerlink" title="1. 目标与定位"></a>1. 目标与定位</h2><ul><li><strong>角色</strong>：第二阶段跟踪，在初步跟踪（参考关键帧、恒速模型、重定位）之后进行。</li><li><strong>目的</strong>：利用更丰富的局部地图信息，对第一阶段获得的当前帧位姿进行<strong>精细化优化</strong>，得到更准确的位姿。</li><li><strong>核心</strong>：增加匹配约束，仅优化当前帧位姿。</li></ul><h2 id="2-与“局部建图线程-Local-Mapping-”的区别"><a href="#2-与“局部建图线程-Local-Mapping-”的区别" class="headerlink" title="2. 与“局部建图线程 (Local Mapping)”的区别"></a>2. 与“局部建图线程 (Local Mapping)”的区别</h2><ul><li><strong>局部地图 (Local Map) - 用于本阶段（局部地图跟踪）</strong><ul><li><strong>数据</strong>：由局部关键帧及其观测到的局部地图点构成。</li><li><strong>功能</strong>：为当前帧提供投影匹配候选，<strong>仅优化当前帧位姿</strong>。不改变关键帧位姿，也不改变地图点三维坐标。</li><li><strong>本质</strong>：“用图”来精调当前帧。</li></ul></li><li><strong>局部建图线程 (Local Mapping) - 独立线程</strong><ul><li><strong>数据</strong>：处理新生成的关键帧。</li><li><strong>功能</strong>：<ol><li>生成新的地图点。</li><li>进行局部BA (Bundle Adjustment)，同时优化局部区域内的关键帧位姿和地图点坐标。</li><li>剔除冗余关键帧和不可靠地图点。</li></ol></li><li><strong>本质</strong>：“建图”与“维护图”。</li></ul></li></ul><h2 id="3-局部地图跟踪的核心步骤"><a href="#3-局部地图跟踪的核心步骤" class="headerlink" title="3. 局部地图跟踪的核心步骤"></a>3. 局部地图跟踪的核心步骤</h2><h3 id="第-1-步：构建局部地图（更新局部关键帧和局部地图点）"><a href="#第-1-步：构建局部地图（更新局部关键帧和局部地图点）" class="headerlink" title="第 1 步：构建局部地图（更新局部关键帧和局部地图点）"></a>第 1 步：构建局部地图（更新局部关键帧和局部地图点）</h3><p>目的是为当前帧搜集一个相关的、小范围的地图子集。</p><ul><li><strong>1.1 更新局部关键帧 (Local KeyFrames)</strong><ul><li><strong>一级共视关键帧</strong>：直接与当前帧有共同观测地图点的关键帧。</li><li><strong>二级共视关键帧</strong>：一级共视关键帧的共视关键帧（如共视程度最高的前 N 个）。</li><li><strong>一级共视关键帧的父&#x2F;子关键帧</strong>：在共视图&#x2F;生成树结构中的父节点和子节点。</li><li><strong>目的</strong>：形成当前帧的“上下文环境”，确保足够的观测信息。</li></ul></li><li><strong>1.2 更新局部地图点 (Local MapPoints)</strong><ul><li><strong>来源</strong>：由上述“局部关键帧”集合所观测到的所有地图点。</li><li><strong>特点</strong>：通常覆盖范围远大于当前帧直接视野，为相机小范围运动和旋转提供了潜在匹配。</li></ul></li></ul><h3 id="第-2-步：投影匹配，获取更多匹配点对"><a href="#第-2-步：投影匹配，获取更多匹配点对" class="headerlink" title="第 2 步：投影匹配，获取更多匹配点对"></a>第 2 步：投影匹配，获取更多匹配点对</h3><p>利用局部地图点与当前帧特征点建立更多约束。</p><ul><li><strong>2.1 筛选可用的局部地图点</strong><ul><li><strong>排除已匹配点</strong>：在第一阶段跟踪中已成功匹配的地图点不再参与。</li><li><strong>视野范围检查 (In Frustum Check)</strong>：<ol><li><strong>深度为正</strong>：地图点在当前相机坐标系下，Z 轴坐标 &gt; 0。</li><li><strong>投影在图像内</strong>：地图点投影到当前帧像素平面上，坐标 (u, v) 在图像边界内。</li><li><strong>有效距离</strong>：地图点与相机中心的距离在其定义的有效观测距离范围内。</li><li><strong>观测角度</strong>：当前相机指向地图点的向量与该点平均观测方向的夹角小于阈值（如 ${60}^{ \circ }$）。</li></ol></li></ul></li><li><strong>2.2 进行投影匹配</strong><ul><li>将筛选出的合格局部地图点投影到当前帧图像。</li><li>在投影点附近区域搜索当前帧的 ORB 特征点，进行特征描述子匹配。</li></ul></li></ul><h3 id="第-3-步：位姿优化-Pose-Optimization"><a href="#第-3-步：位姿优化-Pose-Optimization" class="headerlink" title="第 3 步：位姿优化 (Pose Optimization)"></a>第 3 步：位姿优化 (Pose Optimization)</h3><p>利用新增的匹配关系进一步优化当前帧位姿。</p><ul><li><strong>方法</strong>：仅优化位姿的 BA (Pose-Only Bundle Adjustment)。</li><li><strong>固定项</strong>：局部地图点的位置、局部关键帧的位姿均保持不变。</li><li><strong>优化项</strong>：仅当前普通帧的位姿 (旋转 $R$ 和平移 $t$)。</li><li><strong>目标</strong>：最小化地图点在当前帧上的重投影误差。</li></ul><h3 id="第-4-步：更新统计信息"><a href="#第-4-步：更新统计信息" class="headerlink" title="第 4 步：更新统计信息"></a>第 4 步：更新统计信息</h3><ul><li>更新当前帧中各匹配地图点的内点&#x2F;外点状态。</li><li>统计成功跟踪（优化后为内点）的地图点总数。</li></ul><h3 id="第-5-步：判断跟踪状态"><a href="#第-5-步：判断跟踪状态" class="headerlink" title="第 5 步：判断跟踪状态"></a>第 5 步：判断跟踪状态</h3><ul><li>根据内点数量决定跟踪是否成功。</li><li>若近期发生过重定位，成功跟踪的内点数阈值会更严格。</li><li>内点数不足则认为跟踪失败，否则成功，当前帧位姿得到更新和确认。</li></ul><h2 id="4-总结思路"><a href="#4-总结思路" class="headerlink" title="4. 总结思路"></a>4. 总结思路</h2><ol><li><strong>“召集助手”</strong>：确定与当前帧相关的局部关键帧集合。</li><li><strong>“扩大搜索范围”</strong>：基于局部关键帧，构建包含丰富三维点的局部地图。</li><li><strong>“精挑细选”</strong>：从局部地图点中筛选出在当前帧视野内且观测条件良好的候选点。</li><li><strong>“建立更多连接”</strong>：将候选点投影到当前帧，进行特征匹配，增加约束。</li><li><strong>“精调姿态”</strong>：利用所有匹配，仅优化当前帧的位姿，使其更精确地对齐局部地图。</li></ol>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跟踪 —— 重定位跟踪</title>
      <link href="/2025/05/13/orbslam2-9/"/>
      <url>/2025/05/13/orbslam2-9/</url>
      
        <content type="html"><![CDATA[<h1 id="Relocalization"><a href="#Relocalization" class="headerlink" title="Relocalization"></a>Relocalization</h1><h2 id="一、核心目标与触发时机"><a href="#一、核心目标与触发时机" class="headerlink" title="一、核心目标与触发时机"></a>一、核心目标与触发时机</h2><ul><li><strong>核心目标：</strong> 当系统由于各种原因（如快速运动、场景剧变、遮挡等）导致跟踪丢失，即无法确定当前相机帧相对于已有地图的位姿时，重定位模块的目标是在已构建的地图中<strong>重新找回当前帧的准确位姿</strong>。</li><li><strong>触发时机：</strong> 这是 SLAM 系统中的一种**“拯救”或“恢复”机制**。它在常规的、依赖连续性的跟踪方法（如恒速模型跟踪、参考关键帧跟踪）均宣告失败后被激活。</li></ul><h2 id="二、核心思想：全局搜索与局部验证"><a href="#二、核心思想：全局搜索与局部验证" class="headerlink" title="二、核心思想：全局搜索与局部验证"></a>二、核心思想：全局搜索与局部验证</h2><p>重定位的整个过程可以概括为两个主要阶段，体现了从粗略的全局匹配到精确的局部验证的思想：</p><ol><li><strong>全局外观搜索 (Global Appearance-Based Search)：</strong><ul><li>由于跟踪已经丢失，系统对当前帧的位姿没有任何先验信息或良好的初始估计。</li><li><strong>策略：</strong> 利用<strong>词袋模型 (Bag-of-Words, BoW)</strong> 在整个历史关键帧数据库 (KeyFrame Database) 中进行快速、大规模的搜索。</li><li><strong>目的：</strong> 找出那些在视觉外观上与当前丢失帧最相似的<strong>候选关键帧 (Candidate KeyFrames)</strong>。这些候选帧是潜在的、当前相机可能重新观察到的场景。</li></ul></li><li><strong>局部几何验证与位姿精化 (Local Geometric Verification &amp; Pose Refinement)：</strong><ul><li>对筛选出的每一个候选关键帧，进行更细致的局部处理。</li><li><strong>策略：</strong><ul><li><strong>特征匹配：</strong> 在当前帧和候选关键帧之间进行ORB特征点的匹配。</li><li><strong>初始位姿估计：</strong> 利用匹配上的3D地图点（来自候选关键帧）和当前帧对应的2D特征点，通过 <strong>EPnP (Efficient Perspective-n-Point)</strong> 算法结合RANSAC（随机采样一致性）来估计一个初始的、相对准确的当前帧位姿。EPnP是一种高效的从n对3D-2D点对应中恢复相机位姿的算法。</li><li><strong>迭代优化：</strong> 获得初始位姿后，通过反复的<strong>投影匹配</strong>（将候选关键帧中更多的地图点根据当前估计位姿投影到当前帧，以寻找新的匹配）和<strong>BA优化 (Bundle Adjustment)</strong>（此阶段通常仅优化当前帧的位姿，不改变地图点坐标）来迭代地增加可靠的匹配点数量，并进一步精化当前帧的位姿。</li></ul></li></ul></li></ol><h2 id="三、关键技术与详细流程"><a href="#三、关键技术与详细流程" class="headerlink" title="三、关键技术与详细流程"></a>三、关键技术与详细流程</h2><h3 id="A-倒排索引-Inverted-Index-加速候选关键帧搜索"><a href="#A-倒排索引-Inverted-Index-加速候选关键帧搜索" class="headerlink" title="A. 倒排索引 (Inverted Index) - 加速候选关键帧搜索"></a>A. 倒排索引 (Inverted Index) - 加速候选关键帧搜索</h3><p>为了避免在可能包含成百上千个关键帧的数据库中进行暴力比对（这在实时系统中是不可接受的），ORB-SLAM2 采用<strong>倒排索引</strong>来高效地完成全局外观搜索。</p><ul><li><p><strong>定义与对比：</strong></p><ul><li><strong>倒排索引 (Inverted Index)：</strong><ul><li><strong>索引基础：</strong> 以“视觉单词 (Word)”（词袋模型中的基本单元）为索引。</li><li><strong>存储内容：</strong> 对于词袋模型词典中的每一个视觉单词，倒排索引存储一个列表，该列表记录了所有包含这个特定视觉单词的关键帧的标识（如指针或ID）以及可能的权重信息。</li><li><strong>核心优势：</strong> 可以非常快速地查询到“有哪些关键帧包含了某个（或某组）特定的视觉单词”。这对于判断图像间的视觉相似性（即共享的视觉单词数量和权重）至关重要且效率极高。</li></ul></li><li><strong>直接索引 (Direct Index)：</strong><ul><li><strong>索引基础：</strong> 以“图像 (KeyFrame)”为索引。</li><li><strong>存储内容：</strong> 每张图像（关键帧）存储其提取到的所有特征点，以及每个特征点在词袋树中所对应的视觉单词（节点ID）。</li><li><strong>核心优势：</strong> 能够快速获取一个关键帧中属于同一个视觉单词（或词袋树节点）下的所有特征点，这在进行两帧之间的特征匹配和后续的几何关系验证时非常有用。</li></ul></li></ul></li><li><p><strong>倒排索引在ORB-SLAM2中的数据结构示例：</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mvInvertedFile 是一个向量，其索引是 WordId (视觉单词的ID)</span></span><br><span class="line"><span class="comment">// mvInvertedFile[word_id] 是一个链表，存储了所有包含 word_id 这个视觉单词的关键帧指针</span></span><br><span class="line">std::vector&lt;std::list&lt;KeyFrame*&gt;&gt; mvInvertedFile;</span><br></pre></td></tr></table></figure></li><li><p><strong>倒排索引的维护：</strong></p><ul><li><strong>添加新关键帧时 (<code>KeyFrameDatabase::add(KeyFrame *pKF)</code>)：</strong><ol><li>获取新关键帧 <code>pKF</code> 的词袋向量 <code>pKF-&gt;mBowVec</code>（该向量记录了关键帧中包含的所有视觉单词及其权重）。</li><li>遍历此BoW向量中的每一个视觉单词 (WordId, WordValue)。</li><li>对于每一个WordId，将该关键帧 <code>pKF</code> 的指针添加到 <code>mvInvertedFile[WordId]</code> 对应的链表中。</li></ol></li><li><strong>删除关键帧时 (<code>KeyFrameDatabase::erase(KeyFrame* pKF)</code>)：</strong><ol><li>获取待删除关键帧 <code>pKF</code> 的词袋向量。</li><li>遍历此BoW向量中的每一个视觉单词.</li><li>对于每一个WordId，访问 <code>mvInvertedFile[WordId]</code> 对应的链表，并从中找到并移除关键帧 <code>pKF</code> 的指针。</li></ol></li></ul></li></ul><h3 id="B-搜索重定位候选关键帧-KeyFrameDatabase-DetectRelocalizationCandidates-Frame-F"><a href="#B-搜索重定位候选关键帧-KeyFrameDatabase-DetectRelocalizationCandidates-Frame-F" class="headerlink" title="B. 搜索重定位候选关键帧 (KeyFrameDatabase::DetectRelocalizationCandidates(Frame *F))"></a>B. 搜索重定位候选关键帧 (<code>KeyFrameDatabase::DetectRelocalizationCandidates(Frame *F)</code>)</h3><p>此函数的目标是从整个关键帧数据库中，高效地筛选出一小组与当前丢失帧 <code>F</code> 最可能在视觉上匹配的候选关键帧。</p><ol><li><strong>步骤 1：初步筛选 - 找出共享单词的关键帧 (<code>lKFsSharingWords</code>)</strong><ul><li>遍历当前帧 <code>F</code> 的BoW向量 <code>F-&gt;mBowVec</code> 中的每一个视觉单词 (WordId)。</li><li>利用<strong>倒排索引 <code>mvInvertedFile[WordId]</code></strong>，获取所有包含该WordId的历史关键帧列表。</li><li>将这些历史关键帧加入到一个临时的集合 <code>lKFsSharingWords</code> 中。</li><li>为每个加入到 <code>lKFsSharingWords</code> 的关键帧 <code>pKFi</code>，用 <code>pKFi-&gt;mnRelocWords++</code> 记录它与当前帧 <code>F</code> 共享的单词数量。</li><li>使用 <code>pKFi-&gt;mnRelocQuery = F-&gt;mnId</code> 作为标记，确保在处理当前帧 <code>F</code> 的不同单词时，同一个历史关键帧 <code>pKFi</code> 只被加入 <code>lKFsSharingWords</code> 一次，并且其 <code>mnRelocWords</code> 能被正确累计。</li><li>如果 <code>lKFsSharingWords</code> 在处理完当前帧所有单词后仍为空（即当前帧与数据库中所有关键帧都没有共同的视觉单词），则无法进行重定位，函数返回空列表。</li></ul></li><li><strong>步骤 2：设定共同单词数阈值1 (<code>minCommonWords</code>)</strong><ul><li>遍历 <code>lKFsSharingWords</code> 中的所有关键帧。</li><li>找到其中与当前帧 <code>F</code> 共享单词数最多的那个值，记为 <code>maxCommonWords</code>。</li><li>设定第一个筛选阈值：<code>minCommonWords = maxCommonWords * 0.8f</code> (例如，取最大共享单词数的80%)。</li><li><strong>目的：</strong> 过滤掉那些虽然与当前帧有共同单词，但共同数量过少的关键帧，减少后续计算量。</li></ul></li><li><strong>步骤 3：计算BoW相似度得分并进行二次筛选 (<code>lScoreAndMatch</code>)</strong><ul><li>再次遍历 <code>lKFsSharingWords</code>。</li><li>只挑选那些共享单词数 <code>pKFi-&gt;mnRelocWords &gt; minCommonWords</code> 的关键帧 <code>pKFi</code>。</li><li>对于这些通过了阈值1的关键帧，计算它们各自的BoW向量与当前帧 <code>F</code> 的BoW向量之间的<strong>相似度得分 <code>si</code></strong>。这个得分通常由词袋库提供，例如 <code>si = mpVoc-&gt;score(F-&gt;mBowVec, pKFi-&gt;mBowVec);</code>。</li><li>将计算得到的得分 <code>si</code> 存入关键帧对象中，如 <code>pKFi-&gt;mRelocScore = si;</code>。</li><li>将 <code>(si, pKFi)</code> 这样一个得分和关键帧指针的配对存入一个新的列表 <code>lScoreAndMatch</code>。</li><li>如果 <code>lScoreAndMatch</code> 在此步骤后为空，则返回空列表。</li></ul></li><li><strong>步骤 4：计算共视组累积得分并设定阈值2 (<code>minScoreToRetain</code>)</strong><ul><li><strong>核心思想：</strong> 单个关键帧与当前帧的视觉相似度可能存在偶然性。如果一个候选关键帧及其在地图中共视关系紧密的“邻居”们（共同构成一个稳定的场景区域）都与当前帧相似，那么这个区域就更可能是当前相机真实观察到的场景。这增加了重定位的鲁棒性。</li><li>遍历 <code>lScoreAndMatch</code> 中的每一个配对 <code>(score, pKFi)</code>：<ul><li>令 <code>pKFi</code> 为当前考虑的中心候选关键帧。</li><li>获取 <code>pKFi</code> 在共视图中连接最紧密的一组关键帧（例如，通过 <code>pKFi-&gt;GetBestCovisibilityKeyFrames(10)</code> 获取共视程度最高的10个邻居关键帧 <code>vpNeighs</code>）。</li><li>计算这个以 <code>pKFi</code> 为核心的“共视组”的<strong>累积得分 <code>accScore</code></strong>：<ul><li>初始 <code>accScore = pKFi-&gt;mRelocScore</code> (即 <code>score</code> from <code>lScoreAndMatch</code>)。</li><li>遍历 <code>vpNeighs</code> 中的每一个邻居关键帧 <code>pKF2</code>。</li><li><strong>重要条件：</strong> 只有当这个邻居 <code>pKF2</code> <strong>也存在于 <code>lScoreAndMatch</code> 中</strong>（即 <code>pKF2-&gt;mnRelocQuery == F-&gt;mnId</code>，意味着它也通过了步骤3的筛选，与当前帧F有足够的直接相似性）时，才将其自身的得分 <code>pKF2-&gt;mRelocScore</code> 加入到 <code>accScore</code> 中。</li></ul></li><li>在计算 <code>accScore</code> 的同时，记录这个共视组中，拥有最高<strong>个体BoW得分</strong>的关键帧及其得分（设为 <code>pBestKFInGroup</code> 和 <code>bestScoreInGroup</code>）。初始时 <code>pBestKFInGroup = pKFi</code>, <code>bestScoreInGroup = pKFi-&gt;mRelocScore</code>。</li><li>将 <code>(accScore, pBestKFInGroup)</code> 存入一个新的列表 <code>lAccScoreAndMatch</code>。</li><li>在遍历所有 <code>lScoreAndMatch</code> 中的 <code>pKFi</code> 后，记录所有共视组中出现的最高累积得分 <code>bestAccScore</code>。</li></ul></li><li>设定第二个筛选阈值：<code>minScoreToRetain = 0.75f * bestAccScore</code> (例如，取最高累积得分的75%)。</li></ul></li><li><strong>步骤 5：筛选最终候选关键帧组 (<code>vpRelocCandidates</code>)</strong><ul><li>遍历 <code>lAccScoreAndMatch</code> 中的每一个配对 <code>(accScore, pBestKFInGroup)</code>。</li><li>只选择那些其累积得分 <code>accScore &gt; minScoreToRetain</code> 的组。</li><li>对于每个通过此阈值的组，将其对应的那个具有最高个体得分的关键帧 <code>pBestKFInGroup</code> 加入到最终的候选关键帧列表 <code>vpRelocCandidates</code> 中。</li><li>使用 <code>std::set&lt;KeyFrame*&gt;</code> 来辅助去重，确保同一个关键帧不会被重复添加到 <code>vpRelocCandidates</code>。</li><li>返回 <code>vpRelocCandidates</code>。这个列表中的关键帧将是接下来进行实际PnP求解和位姿优化的对象。</li></ul></li></ol><h3 id="C-执行重定位尝试-Tracking-Relocalization"><a href="#C-执行重定位尝试-Tracking-Relocalization" class="headerlink" title="C. 执行重定位尝试 (Tracking::Relocalization())"></a>C. 执行重定位尝试 (<code>Tracking::Relocalization()</code>)</h3><p>在获得了经过层层筛选的候选关键帧列表后，系统将逐个尝试用它们来恢复当前丢失帧 <code>mCurrentFrame</code> 的位姿。</p><ol><li><strong>步骤 1：计算当前帧的BoW向量。</strong><ul><li><code>mCurrentFrame.ComputeBoW();</code> (如果尚未计算)。</li></ul></li><li><strong>步骤 2：获取候选关键帧列表。</strong><ul><li>调用 <code>mpKeyFrameDB-&gt;DetectRelocalizationCandidates(&amp;mCurrentFrame)</code> 得到 <code>vpCandidateKFs</code>。</li><li>如果 <code>vpCandidateKFs</code> 为空，则表示没有找到合适的候选，重定位失败，函数返回 <code>false</code>。</li></ul></li><li><strong>步骤 3：初始化 - 遍历候选，进行初步BoW匹配，准备PnP求解器。</strong><ul><li>对 <code>vpCandidateKFs</code> 中的每个候选关键帧 <code>pKF</code>：<ul><li>检查 <code>pKF</code> 是否有效 (例如，<code>pKF-&gt;isBad()</code>)，无效则跳过。</li><li><strong>BoW特征匹配：</strong> 调用 <code>matcher.SearchByBoW(pKF, mCurrentFrame, vvpMapPointMatches[i])</code>。<code>vvpMapPointMatches[i]</code> 是一个 <code>std::vector&lt;MapPoint*&gt;</code>，存储了当前帧 <code>mCurrentFrame</code> 的特征点与候选关键帧 <code>pKF</code> 的地图点之间的匹配关系。函数返回匹配上的点对数量 <code>nmatches</code>。</li><li><strong>初步过滤：</strong> 如果 <code>nmatches &lt; 15</code> (阈值，表示匹配太少)，则认为此候选关键帧不足以进行可靠的位姿估计，将其标记为已丢弃 <code>vbDiscarded[i] = true;</code>，然后继续处理下一个候选。</li><li><strong>创建PnP求解器：</strong> 如果 <code>nmatches &gt;= 15</code>，则为此候选关键帧创建一个 <code>PnPsolver</code> 实例（ORB-SLAM2中使用的是EPnP算法的实现）。这个求解器会与当前帧 <code>mCurrentFrame</code> 以及刚获得的匹配 <code>vvpMapPointMatches[i]</code> 相关联。同时设置PnP求解器所需的RANSAC参数，如：<ul><li><code>probability = 0.99</code> (RANSAC成功概率)</li><li><code>minInliers = 10</code> (RANSAC迭代中，接受一个解所需的最小内点数)</li><li><code>maxIterations = 300</code> (RANSAC最大迭代次数)</li><li><code>minSet = 4</code> (EPnP求解一次位姿所需的最少点对数)</li><li><code>epsilon = 0.5</code> (RANSAC内点比例，用于提前终止)</li><li><code>th2 = 5.991</code> (卡方检验阈值，用于判断一个点是否为内点，会根据特征点金字塔层级调整)</li></ul></li><li>记录有效的候选PnP求解器数量 <code>nCandidates++</code>。</li></ul></li></ul></li><li><strong>步骤 4：核心循环 - 迭代尝试PnP求解、位姿优化和投影匹配。</strong><ul><li>此步骤在一个 <code>while (nCandidates &gt; 0 &amp;&amp; !bMatch)</code> 的循环中进行。<code>bMatch</code> 标志位表示是否已有一个候选关键帧成功重定位了当前帧。</li><li>在循环中，再次遍历所有未被标记为 <code>vbDiscarded[i]</code> 的候选关键帧及其对应的 <code>PnPsolver</code> <code>vpPnPsolvers[i]</code>：<ul><li><strong>a. EPnP迭代求解初始位姿：</strong><ul><li>调用 <code>PnPsolver* pSolver = vpPnPsolvers[i];</code></li><li><code>cv::Mat Tcw = pSolver-&gt;iterate(5, bNoMore, vbInliers, nInliers);</code><ul><li><code>iterate(5, ...)</code>: 尝试进行最多5轮RANSAC迭代（或者直到内部判断已充分探索）。</li><li><code>bNoMore</code>: 输出参数，如果为 <code>true</code>，表示此 <code>PnPsolver</code> 的RANSAC迭代已达到最大次数或无法找到更多解，应丢弃此候选。</li><li><code>vbInliers</code>: 输出参数，一个 <code>std::vector&lt;bool&gt;</code>，标记了EPnP求解后哪些初始匹配点被认为是内点。</li><li><code>nInliers</code>: 输出参数，内点的数量。</li><li><code>Tcw</code>: 如果求解成功，返回估计的从世界到当前相机的位姿变换矩阵。</li></ul></li><li>如果 <code>bNoMore</code> 为 <code>true</code>，则 <code>vbDiscarded[i] = true; nCandidates--;</code> 并继续处理下一个候选。</li></ul></li><li><strong>b. 首次位姿优化 (BA) - 如果EPnP成功：</strong><ul><li>如果 <code>!Tcw.empty()</code> (EPnP求解得到一个位姿)：<ul><li>将求解得到的 <code>Tcw</code> 赋给当前帧：<code>Tcw.copyTo(mCurrentFrame.mTcw);</code>。</li><li>根据 <code>vbInliers</code>，将EPnP认为是内点的那些匹配（即 <code>vvpMapPointMatches[i][j]</code>）关联到当前帧的地图点列表 <code>mCurrentFrame.mvpMapPoints[j]</code>。其他未标记为内点的，在当前帧中对应位置设为 <code>NULL</code>。</li><li>调用 <code>int nGood = Optimizer::PoseOptimization(&amp;mCurrentFrame);</code>。这是一个仅优化位姿的BA，它使用当前帧 <code>mCurrentFrame</code> 中所有已关联的地图点来优化其位姿 <code>mCurrentFrame.mTcw</code>。函数返回优化后的内点数量 <code>nGood</code>。</li><li><strong>初步判断：</strong> 如果 <code>nGood &lt; 10</code> (优化后内点数太少)，说明当前EPnP解引导的BA效果不佳。此时<strong>不会立即丢弃该候选帧</strong> (<code>vbDiscarded[i]</code> 不变)，而是 <code>continue;</code> 跳过后续的投影匹配等步骤，直接尝试此候选帧的下一次EPnP迭代（如果 <code>pSolver-&gt;iterate</code> 允许）或下一个候选帧。</li><li>清除BA优化过程中标记为外点 (<code>mCurrentFrame.mvbOutlier[io]</code>) 的地图点在当前帧的关联 (设为 <code>NULL</code>)。</li></ul></li></ul></li><li><strong>c. 首次投影匹配 (尝试增加匹配点 - Rescue Attempt 1) - 如果首次BA内点数不足：</strong><ul><li>如果 <code>nGood &lt; 50</code> (例如，阈值设为50，表示首次BA后的内点数仍不够理想，但有挽救价值)：<ul><li><code>sFound</code>: 一个 <code>std::set&lt;MapPoint*&gt;</code>，包含当前 <code>mCurrentFrame.mvpMapPoints</code> 中所有非空的地图点（即当前已知的内点）。</li><li><code>int nadditional = matcher2.SearchByProjection(mCurrentFrame, vpCandidateKFs[i], sFound, 10, 100);</code><ul><li><code>mCurrentFrame</code>: 当前帧，其位姿是刚通过首次BA优化过的。</li><li><code>vpCandidateKFs[i]</code>: 当前正在处理的候选关键帧。</li><li><code>sFound</code>: 告诉 <code>SearchByProjection</code> 不要重复匹配这些已经找到的点。</li><li><code>10</code>: 投影搜索窗口大小（像素）。</li><li><code>100</code>: 可能是对地图点深度或与当前帧的距离施加的限制，或者是描述子匹配的某种阈值参数。</li></ul></li><li>此函数的作用是：将候选关键帧 <code>vpCandidateKFs[i]</code> 中那些尚未与当前帧匹配上的地图点，根据当前帧已优化的位姿 <code>mCurrentFrame.mTcw</code>，投影到当前帧的图像平面上。然后在投影点附近搜索当前帧的特征点，如果找到匹配，就将这个新的3D-2D对应关系添加到 <code>mCurrentFrame</code> 中。<code>nadditional</code> 是新增加的匹配点数量。</li></ul></li></ul></li><li><strong>d. 第二次位姿优化 (BA) - 如果首次投影匹配有效：</strong><ul><li>如果 <code>nadditional + nGood &gt;= 50</code> (即首次投影匹配增加了足够的点，使得总数有望达标)：<ul><li>再次调用 <code>nGood = Optimizer::PoseOptimization(&amp;mCurrentFrame);</code> 使用更多的匹配点（原有的 <code>nGood</code> + 新增的 <code>nadditional</code>）来优化位姿。</li></ul></li></ul></li><li><strong>e. 第二次投影匹配 (更精细地增加匹配点 - Rescue Attempt 2) - 如果二次BA后仍有希望：</strong><ul><li>如果第二次BA优化后，内点数 <code>nGood</code> 仍未达到最终目标50，但处于一个有希望的区间，例如 <code>30 &lt; nGood &lt; 50</code>：<ul><li>这表明当前帧的位姿可能因为上一步的BA而变得更准确了。值得用更严格的参数再尝试一次投影匹配，以期找到更多高质量的匹配。</li><li>清空 <code>sFound</code> 并重新加入当前所有内点。</li><li><code>nadditional = matcher2.SearchByProjection(mCurrentFrame, vpCandidateKFs[i], sFound, 3, 64);</code><ul><li><code>3</code>: 使用更小的投影搜索窗口（更精确的位姿允许更小的搜索范围）。</li><li><code>64</code>: 可能是更严格的描述子匹配阈值（例如，ORB描述子汉明距离上限）。</li></ul></li></ul></li></ul></li><li><strong>f. 第三次位姿优化 (BA) - 如果第二次投影匹配有效：</strong><ul><li>如果 <code>nGood + nadditional &gt;= 50</code> (即第二次投影匹配使得总数达标)：<ul><li>最后进行一次 <code>nGood = Optimizer::PoseOptimization(&amp;mCurrentFrame);</code>。</li><li>清除优化后的外点。</li></ul></li></ul></li><li><strong>g. 判断当前候选关键帧是否成功重定位：</strong><ul><li>如果在上述 <strong>任何一次BA优化</strong> (b, d, 或 f) 之后，内点数量 <code>nGood &gt;= 50</code> (阈值，表示找到了足够多的可靠匹配)：<ul><li>则认为使用当前的候选关键帧 <code>vpCandidateKFs[i]</code> 已经成功地重定位了当前帧 <code>mCurrentFrame</code>。</li><li>设置 <code>bMatch = true;</code>。</li><li><strong><code>break;</code></strong> 跳出当前对所有候选关键帧的遍历循环（即<code>for(int i=0; i&lt;nKFs; i++)</code>循环）。一旦有一个候选成功，就不再考虑其他候选了。</li></ul></li></ul></li></ul></li></ul></li><li><strong>步骤 5：返回最终结果。</strong><ul><li>当 <code>while</code> 循环结束（因为 <code>nCandidates &lt;= 0</code> 或 <code>bMatch == true</code>）：<ul><li>如果 <code>!bMatch</code>，则表示尝试了所有（或所有有希望的）候选关键帧后，均未能成功重定位。函数返回 <code>false</code>。</li><li>如果 <code>bMatch</code> 为 <code>true</code>，则重定位成功。<ul><li>记录当前成功重定位的帧ID：<code>mnLastRelocFrameId = mCurrentFrame.mnId;</code> (这可以用于防止系统在短时间内对同一帧反复进行不必要的重定位尝试)。</li><li>函数返回 <code>true</code>。当前帧 <code>mCurrentFrame</code> 的位姿 <code>mTcw</code> 和关联的地图点 <code>mvpMapPoints</code> 已经被更新。</li></ul></li></ul></li></ul></li></ol><h2 id="四、重定位效果与重要性"><a href="#四、重定位效果与重要性" class="headerlink" title="四、重定位效果与重要性"></a>四、重定位效果与重要性</h2><ul><li><strong>鲁棒性强：</strong> 重定位模块的设计使其具有“顽强的生命力”，能够在诸多挑战性场景下（如环境外观发生较大尺度变化、存在动态物体干扰、光照剧变后恢复等）成功找回丢失的相机位姿。</li><li><strong>系统连续性保障：</strong> 它是保证SLAM系统长期稳定运行和从跟踪失败中恢复的关键。没有有效的重定位，一次跟踪丢失就可能导致整个SLAM任务失败。</li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>ORB-SLAM2的重定位是一个精心设计的多阶段过程，它巧妙地结合了：</p><ul><li><strong>高效的全局场景识别</strong>：通过词袋模型和倒排索引技术，快速从大规模地图中检索潜在匹配区域。</li><li><strong>鲁棒的初始位姿估计</strong>：利用EPnP算法和RANSAC策略，从稀疏的初始匹配中求解相机位姿。</li><li><strong>迭代的位姿精化和数据关联</strong>：通过多次BA优化和引导性的投影匹配，不断提升位姿的准确性并增加可靠的3D-2D对应关系。</li></ul><p>这个模块的复杂性正体现了其在应对SLAM核心挑战——跟踪丢失——时所付出的努力和实现的高性能。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跟踪 —— 恒速跟踪</title>
      <link href="/2025/05/13/orbslam2-8/"/>
      <url>/2025/05/13/orbslam2-8/</url>
      
        <content type="html"><![CDATA[<h1 id="TrackWithMotionModel"><a href="#TrackWithMotionModel" class="headerlink" title="TrackWithMotionModel"></a>TrackWithMotionModel</h1><h2 id="一、核心思想与定义"><a href="#一、核心思想与定义" class="headerlink" title="一、核心思想与定义"></a>一、核心思想与定义</h2><p>恒速模型跟踪基于一个核心假设：<strong>在连续的图像帧之间极短的时间内（通常为几十毫秒），相机的运动状态可以近似为匀速运动。</strong></p><p>因此，可以利用<strong>上一帧的位姿</strong>以及先前估计得到的**帧间相对运动（速度和角速度，统称为速度 V）来预测当前帧的位姿，并以此为初始值进行后续的匹配和优化。</p><h2 id="二、为何使用恒速模型跟踪？"><a href="#二、为何使用恒速模型跟踪？" class="headerlink" title="二、为何使用恒速模型跟踪？"></a>二、为何使用恒速模型跟踪？</h2><ol><li><strong>效率优先：</strong><ul><li>在地图初始化并通过参考关键帧跟踪成功获得初始速度后，恒速模型提供了一种<strong>更简单、计算更快</strong>的位姿估计方法。</li><li>相比于参考关键帧跟踪（涉及词袋匹配等），恒速模型直接利用运动先验，对实时性要求高的SLAM系统非常重要。</li></ul></li><li><strong>常用策略：</strong><ul><li>一旦系统有了速度信息，恒速模型便成为跟踪线程中的首选和最常用的跟踪方法。</li></ul></li></ol><h2 id="三、关键公式"><a href="#三、关键公式" class="headerlink" title="三、关键公式"></a>三、关键公式</h2><ol><li><strong>速度 (Velocity) $\mathbf{V}$：</strong><ul><li>表示从上一帧 (<code>l</code>) 到当前帧 (<code>c</code>) 的相对位姿变换 $\mathbf{T}_{\mathrm{cl}}$。</li><li>如果上一帧的世界位姿为 $\mathbf{T}{\mathrm{lw}}$<em>，当前帧的世界位姿为 $\mathbf{T}{\mathrm{cw}}$</em>，则：<br>  $\mathbf{V} &#x3D; \mathbf{T}<em>{\mathrm{cl}} &#x3D; \mathbf{T}</em>{\mathrm{cw}} (\mathbf{T}<em>{\mathrm{lw}})^{-1} &#x3D; \mathbf{T}</em>{\mathrm{cw}} \mathbf{T}_{\mathrm{wl}}$</li><li>在实践中，$\mathbf{V}$ 通常是上上帧到上一帧的运动。</li></ul></li><li><strong>当前帧位姿预测 $\mathbf{T}_{\mathrm{cw}}$：</strong><ul><li>利用速度 $\mathbf{V}$ 和上一帧的世界位姿 $\mathbf{T}<em>{\mathrm{lw}}$*：<br>  $\mathbf{T}</em>{\mathrm{cw}} &#x3D; \mathbf{V} \mathbf{T}_{\mathrm{lw}}$*</li><li>此预测结果作为当前帧位姿优化的初始值。</li></ul></li></ol><h2 id="四、关键步骤与原理"><a href="#四、关键步骤与原理" class="headerlink" title="四、关键步骤与原理"></a>四、关键步骤与原理</h2><p>恒速模型跟踪主要包含两个大的阶段：<code>UpdateLastFrame()</code> 的预处理和 <code>TrackWithMotionModel()</code> 的核心跟踪流程。</p><h3 id="A-预处理：更新上一帧信息-UpdateLastFrame"><a href="#A-预处理：更新上一帧信息-UpdateLastFrame" class="headerlink" title="A. 预处理：更新上一帧信息 (UpdateLastFrame())"></a>A. 预处理：更新上一帧信息 (<code>UpdateLastFrame()</code>)</h3><p>此步骤在正式跟踪当前帧之前，对上一帧 (<code>mLastFrame</code>) 进行关键的更新。</p><ol><li><strong>更新上一帧的世界位姿 $\mathbf{T}_{\mathrm{lw}}$：</strong><ul><li><strong>目的：</strong> 确保用于预测当前帧的上一帧位姿是最新的、最准确的。</li><li><strong>方法：</strong> 不直接使用上一帧跟踪后得到的位姿，而是通过其对应的<strong>参考关键帧 (<code>pRef</code>)</strong> 来间接更新。<br>  $\mathbf{T}<em>{\mathrm{lw}} &#x3D; \mathbf{T}</em>{\mathrm{lr}} \mathbf{T}_{\mathrm{rw}}$<br> 其中：<ul><li>$\mathbf{T}_{\mathrm{lw}}$: 上一帧在世界坐标系下的位姿 (待更新)。</li><li>$\mathbf{T}_{\mathrm{lr}}$: 上一帧相对于其参考关键帧的位姿变换 (已知，存储如 <code>mlRelativeFramePoses</code>)。</li><li>$\mathbf{T}_{\mathrm{rw}}$: 上一帧的参考关键帧在世界坐标系下的位姿 (该位姿可能已被局部建图线程优化过，更准确)。</li></ul></li><li><strong>原理：</strong> 普通帧（如果未被选为关键帧）是“用完即抛”的，其位姿不会被后端持续优化。而关键帧的位姿会通过局部建图和回环检测不断优化。通过上述公式，可以将关键帧的优化成果传递给上一普通帧，从而提高其位姿的准确性。</li></ul></li><li><strong>为双目&#x2F;RGB-D相机的上一帧创建临时地图点：</strong><ul><li><strong>适用条件：</strong> 仅当传感器为双目相机 (System::STEREO) 或 RGB-D 相机 (System::RGBD) 时执行，且上一帧不是关键帧。单目相机 (System::MONOCULAR) 则跳过此步。</li><li><strong>目的：</strong> 利用双目&#x2F;RGB-D可直接获取深度信息的优势，为上一帧中一些有深度但尚未关联地图点的特征点创建<strong>临时地图点 (Temporal MapPoints)</strong>。这些点能显著<strong>增加下一帧（即当前帧）跟踪时的3D信息，提高投影匹配的稳定性和成功率。</strong></li><li><strong>特性：</strong><ul><li><strong>临时性：</strong> 这些点仅用于当前帧的跟踪，不会加入到全局地图中，在跟踪流程的后续阶段会被清除（例如，在创建新关键帧之前）。</li><li><strong>简化属性：</strong> 创建时可能不包含完整的地图点属性，因为其生命周期很短。</li></ul></li><li><strong>创建流程：</strong><ol><li><strong>筛选：</strong> 找出上一帧中所有具有有效深度值 (<code>mLastFrame.mvDepth[i] &gt; 0</code>) 的特征点。</li><li><strong>排序：</strong> 将这些点按深度值从小到大排序。</li><li><strong>创建判断：</strong> 遍历排序后的点：<ul><li>如果该特征点在上一帧中没有对应的地图点 (<code>!mLastFrame.mvpMapPoints[i]</code>)。</li><li>或者其对应的地图点质量差（例如，被创建后从未被其他帧观测到 <code>pMP-&gt;Observations() &lt; 1</code>）。<br> 则认为需要为该特征点创建一个新的临时地图点。</li></ul></li><li><strong>生成：</strong> 利用特征点的2D坐标和深度值，通过反投影 (<code>mLastFrame.UnprojectStereo(i)</code>) 计算其在上一帧相机坐标系下的3D坐标，然后转换到世界坐标系下，创建新的<code>MapPoint</code>对象。</li><li><strong>存储：</strong> 将新创建的临时地图点存入 <code>mLastFrame.mvpMapPoints</code> 的对应位置，并加入一个临时列表 <code>mlpTemporalPoints</code> 以便后续统一清理。</li><li><strong>终止条件：</strong> 当创建的临时点达到一定数量（如 <code>nPoints &gt; 100</code>）且当前处理的点的深度已超过设定阈值 (<code>mThDepth</code>，例如40倍基线）时，停止创建（太远或太多的点可能反而降低效率或引入不确定性）。</li></ol></li></ul></li></ol><h3 id="B-核心跟踪流程-TrackWithMotionModel"><a href="#B-核心跟踪流程-TrackWithMotionModel" class="headerlink" title="B. 核心跟踪流程 (TrackWithMotionModel())"></a>B. 核心跟踪流程 (<code>TrackWithMotionModel()</code>)</h3><ol><li><strong>调用预处理：</strong><ul><li>执行 <code>UpdateLastFrame()</code> 来更新上一帧的位姿并（如果适用）创建临时地图点。</li></ul></li><li><strong>初始位姿估计：</strong><ul><li>使用恒速模型公式预测当前帧 <code>mCurrentFrame</code> 的初始世界位姿：<br> <code>mCurrentFrame.SetPose(mVelocity * mLastFrame.mTcw);</code></li></ul></li><li><strong>投影匹配 (<code>SearchByProjection</code>)：</strong><ul><li><strong>数据源：</strong> 将<strong>上一帧 <code>mLastFrame</code> 中所有有效的地图点</strong>（包括常规地图点和刚刚为双目&#x2F;RGB-D创建的临时地图点）投影到当前帧 <code>mCurrentFrame</code> 的图像平面上（基于当前帧的初始估计位姿）。</li><li><strong>匹配：</strong> 在每个投影点周围的一个预设搜索窗口内（单目通常 <code>th=15</code> 像素，双目&#x2F;RGB-D <code>th=7</code> 像素），为当前帧的ORB特征点寻找匹配的地图点。</li><li><strong>鲁棒性增强 (二次搜索)：</strong><ul><li>如果初次投影匹配找到的匹配点数量不足（如 <code>nmatches &lt; 20</code>），系统会认为初始位姿估计可能不够准确或场景变化稍大。</li><li>此时，会将搜索窗口的半径扩大一倍（<code>2*th</code>），并重新进行一次投影匹配，尝试找回更多潜在的匹配。</li></ul></li><li>如果二次搜索后匹配点仍然过少，则认为恒速模型跟踪失败。</li></ul></li><li><strong>位姿优化 (<code>Optimizer::PoseOptimization</code>)：</strong><ul><li>基于投影匹配成功的3D地图点及其在当前帧中对应的2D特征点，通过非线性优化算法（如Bundle Adjustment的仅优化位姿版本）最小化重投影误差，进一步精确当前帧的位姿。</li><li><strong>注意：</strong> 此阶段仅优化当前帧的位姿，不改变3D地图点的坐标。</li></ul></li><li><strong>外点剔除：</strong><ul><li>在位姿优化后，根据重投影误差等准则，识别并剔除那些可能是错误匹配的特征点（外点）。</li><li>更新当前帧内点（<code>mvpMapPoints</code>）和外点标记（<code>mvbOutlier</code>）。</li></ul></li><li><strong>成功判断：</strong><ul><li>统计最终有效的内点匹配数量 (<code>nmatchesMap</code>)。</li><li>如果内点数量大于等于一个阈值（例如，在非“仅定位”模式下 <code>nmatchesMap &gt;= 10</code>），则认为恒速模型跟踪成功，返回 <code>true</code>。否则返回 <code>false</code>。</li><li>在“仅定位”模式下 (<code>mbOnlyTracking</code>)，对内点数量有更严格的要求（如 <code>nmatchesMap &lt; 10</code> 会标记 <code>mbVO</code> 为 <code>true</code>，表示可能退化为视觉里程计，且总匹配数 <code>nmatches &gt; 20</code> 才认为成功）。</li></ul></li></ol><h2 id="五、优缺点总结"><a href="#五、优缺点总结" class="headerlink" title="五、优缺点总结"></a>五、优缺点总结</h2><ul><li><strong>优点：</strong><ol><li><strong>高效性：</strong> 仅依赖上一帧信息和已知的速度模型，计算量小，速度快，是系统正常运行时的主要跟踪手段。</li><li><strong>稳定性增强技巧：</strong><ul><li>双目&#x2F;RGB-D模式下动态生成临时地图点，有效增加了可用于跟踪的3D点数量。</li><li>投影匹配不足时，采用扩大搜索半径的二次尝试策略，提高了对轻微运动变化的鲁棒性。</li><li>通过参考关键帧更新上一帧位姿，间接利用了后端优化的成果。</li></ul></li></ol></li><li><strong>缺点：</strong><ol><li><strong>理想化假设：</strong> “匀速运动”的假设在相机发生剧烈运动（如快速旋转、急停&#x2F;急加速）或系统帧率较低（导致帧间变化大）时可能不成立。</li><li><strong>易丢失：</strong> 当上述假设不满足时，预测的初始位姿与真实位姿偏差可能过大，导致投影匹配失败，进而跟踪丢失。此时系统需要回退到参考关键帧跟踪或进行重定位。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跟踪 —— 参考关键帧跟踪</title>
      <link href="/2025/05/13/orbslam2-7/"/>
      <url>/2025/05/13/orbslam2-7/</url>
      
        <content type="html"><![CDATA[<h1 id="TrackReferenceKeyFrame"><a href="#TrackReferenceKeyFrame" class="headerlink" title="TrackReferenceKeyFrame"></a>TrackReferenceKeyFrame</h1><h2 id="一、核心目标"><a href="#一、核心目标" class="headerlink" title="一、核心目标"></a>一、核心目标</h2><p>当相机捕获到新的普通帧（位姿未知）时，利用一个已知的、位姿相对准确的<strong>参考关键帧 (Reference KeyFrame)</strong> 来估计当前普通帧的精确位姿。</p><h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><p>参考关键帧跟踪主要在以下两种情况下被调用：</p><ol><li><strong>系统刚初始化后：</strong><ul><li><strong>场景描述：</strong> SLAM 系统通过初始几帧（如第1、2帧）完成地图初始化，并将它们设为关键帧。当后续帧（如第3帧）进入时，系统尚无稳定的运动模型（例如，恒速模型中的速度为空）。</li><li><strong>为何使用：</strong> 此时，最可靠的方式是直接将新帧与已初始化的关键帧进行匹配，以获得新帧的初始位姿。参考关键帧的位姿是后续建图和跟踪的基础，相对可靠。</li></ul></li><li><strong>恒速模型跟踪失败后：</strong><ul><li><strong>场景描述：</strong> 系统尝试使用恒速模型预测当前帧位姿失败（可能由于相机运动剧烈、场景纹理缺乏等）。</li><li><strong>为何使用：</strong><ul><li><strong>恒速模型局限性：</strong> 仅依赖前一帧信息，信息量有限，速度估计可能不准，易导致错误匹配。</li><li><strong>参考关键帧优势：</strong> 通常经过局部建图线程优化，位姿更精确；可能关联了更多地图点，3D信息更丰富。因此，作为一种更稳健的备选方案。</li></ul></li></ul></li></ol><h2 id="三、具体流程与原理"><a href="#三、具体流程与原理" class="headerlink" title="三、具体流程与原理"></a>三、具体流程与原理</h2><p>参考关键帧跟踪主要包含以下步骤：</p><ol><li><strong>当前帧特征编码 (BoW转换)：</strong><ul><li><strong>操作：</strong> 将当前普通帧提取的ORB特征（特别是描述子）转化为词袋 (Bag-of-Words, BoW) 向量。</li><li><strong>原理：</strong> BoW模型通过预训练的视觉词典，将特征描述子映射为“视觉单词”，形成一个表示图像内容的向量。<strong>目的是为后续高效特征匹配做准备，缩小匹配搜索范围。</strong></li></ul></li><li><strong>基于BoW的快速特征匹配：</strong><ul><li><strong>操作：</strong> 利用当前帧和参考关键帧的BoW向量，进行<code>SearchByBoW</code>特征匹配。</li><li><strong>原理：</strong> 只对在BoW空间中属于相同或相近“视觉单词”的特征点进行匹配，<strong>极大提高匹配效率和成功率</strong>。成功匹配后，当前帧的2D特征点就与参考关键帧的3D地图点建立了对应关系。</li></ul></li><li><strong>初始位姿赋予与3D-2D优化：</strong><ul><li><strong>操作：</strong><ol><li><strong>初始位姿估计：</strong> 通常使用<strong>上一帧 (<code>mLastFrame</code>) 的位姿</strong>作为当前帧位姿的初始猜测值，以加速优化过程的收敛。</li><li><strong>位姿优化 (<code>Optimizer::PoseOptimization</code>)：</strong> 基于步骤2建立的“当前帧2D点 - 参考关键帧3D点”的匹配关系，通过最小化<strong>重投影误差 (Reprojection Error)</strong> 来优化当前帧的位姿。</li></ol></li><li><strong>原理：</strong><ul><li><strong>重投影误差：</strong> 将参考关键帧的3D地图点根据当前帧的估计位姿投影到当前帧图像平面，计算投影点与实际匹配的2D特征点之间的像素距离。</li><li><strong>优化目标：</strong> 调整当前帧的位姿，使得所有匹配点的总重投影误差最小。</li><li><strong>重点：</strong> 在此优化步骤中，<strong>仅优化当前帧的位姿，不改变参考关键帧的3D地图点坐标</strong>，因为后者被认为是相对准确的。</li></ul></li></ul></li><li><strong>外点剔除：</strong><ul><li><strong>操作：</strong> 在位姿优化后，识别并剔除那些可能是错误匹配的特征点（外点, Outliers）。</li><li><strong>原理：</strong> 位姿优化过程本身有助于识别外点（例如，重投影误差过大的点）。剔除外点是为了<strong>保证最终位姿估计的鲁棒性和准确性</strong>，只保留高质量的内点 (Inliers) 匹配。</li></ul></li><li><strong>跟踪成功判断：</strong><ul><li><strong>操作：</strong> 检查经过外点剔除后，剩余的有效内点匹配数量。</li><li><strong>原理：</strong> 如果内点数量超过预设阈值（例如，ORB-SLAM2中初始匹配少于15个或优化后内点少于10个则认为失败），则认为参考关键帧跟踪成功，当前帧位姿得到可靠估计；否则，跟踪失败。</li></ul></li></ol><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>参考关键帧跟踪是ORB-SLAM2跟踪线程中的一个<strong>核心且鲁棒的位姿估计算法</strong>。它通过利用位姿已知的参考关键帧，结合高效的BoW特征匹配和精确的3D-2D位姿优化技术，为当前帧提供可靠的位姿估计，尤其在系统初始化阶段或快速运动模型失效时发挥着关键作用。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>投影匹配--闭环版</title>
      <link href="/2025/05/13/orbslam2-6/"/>
      <url>/2025/05/13/orbslam2-6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-函数背景与目标"><a href="#1-函数背景与目标" class="headerlink" title="1. 函数背景与目标"></a>1. 函数背景与目标</h2><p>这个特定版本的 <code>SearchByProjection</code> 函数在 ORB-SLAM2 的<strong>闭环检测 (Loop Closing)</strong> 流程中被调用。</p><ul><li><strong>调用时机</strong>：当系统检测到一个潜在的闭环（当前关键帧 <code>pKF</code> 与过去的某个关键帧 <code>pLoopKF</code> 在同一位置），并且已经<strong>成功计算出</strong>连接这两个关键帧位姿的 <strong>Sim3 变换矩阵 <code>Scw</code></strong> 之后。</li><li><strong>函数目标</strong>：利用已知的 <code>Scw</code> 变换，为当前关键帧 <code>pKF</code> 中那些<strong>尚未建立地图点关联</strong>的特征点，去寻找并建立与<strong>闭环候选帧 <code>pLoopKF</code> 及其共视帧相关的地图点 (<code>vpPoints</code>)</strong> 之间的<strong>新匹配关系</strong>。其核心目的是<strong>增加闭环约束的数量和质量</strong>。</li></ul><h2 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. 核心思想</h2><p><strong>利用已计算出的 Sim3 变换 <code>Scw</code> 作为几何先验，指导特征匹配过程，从而在两个看似分离的地图部分之间建立更多可靠的连接点。</strong></p><p>具体来说，是将 <code>pLoopKF</code> 相关区域的 3D 地图点 (<code>vpPoints</code>)，通过 <code>Scw</code> 变换投影到当前关键帧 <code>pKF</code> 的图像平面上，然后在投影点附近搜索匹配的 <code>pKF</code> 特征点。</p><h2 id="3-主要执行步骤与思想解析"><a href="#3-主要执行步骤与思想解析" class="headerlink" title="3. 主要执行步骤与思想解析"></a>3. 主要执行步骤与思想解析</h2><h3 id="a-输入与准备-Code-Step-1-Initialization"><a href="#a-输入与准备-Code-Step-1-Initialization" class="headerlink" title="a. 输入与准备 (Code Step 1 &amp; Initialization)"></a>a. 输入与准备 (Code Step 1 &amp; Initialization)</h3><ul><li><strong>输入</strong>：当前关键帧 <code>pKF</code>，Sim3 变换 <code>Scw</code>，闭环候选区域的地图点 <code>vpPoints</code>，<code>pKF</code> 的匹配向量 <code>vpMatched</code> (既是输入也是输出)，搜索半径阈值 <code>th</code>。</li><li><strong>分解 Sim3</strong>：从 <code>Scw</code> 中提取出尺度 <code>scw</code>、旋转 <code>Rcw</code>、平移 <code>tcw</code> 以及 <code>pKF</code> 的相机光心世界坐标 <code>Ow</code>。这为后续的投影和检查做准备。</li><li><strong>初始化已匹配集合 <code>spAlreadyFound</code></strong>：将 <code>vpMatched</code> 中已存在的有效匹配放入 <code>set</code> 中，用于快速判断某个地图点是否已在 <code>pKF</code> 中有匹配，避免重复处理。</li></ul><h3 id="b-遍历候选地图点并尝试匹配-Code-Step-2"><a href="#b-遍历候选地图点并尝试匹配-Code-Step-2" class="headerlink" title="b. 遍历候选地图点并尝试匹配 (Code Step 2)"></a>b. 遍历候选地图点并尝试匹配 (Code Step 2)</h3><p>对 <code>vpPoints</code> 中的每一个地图点 <code>pMP</code> 进行如下尝试：</p><ol><li><strong>过滤</strong> (Step 2.1):<ul><li>跳过坏点 (<code>pMP-&gt;isBad()</code>)。</li><li>跳过在 <code>pKF</code> 中已经有对应匹配的 <code>pMP</code> (<code>spAlreadyFound.count(pMP)</code>)。 <strong>目标是寻找新匹配。</strong></li></ul></li><li><strong>投影与有效性检查</strong> (Step 2.2):<ul><li>将 <code>pMP</code> 的世界坐标 <code>p3Dw</code> 通过 <code>Rcw</code>, <code>tcw</code> 变换到 <code>pKF</code> 的相机坐标 <code>p3Dc</code>。</li><li>执行<strong>标准投影检查</strong>：<ul><li>深度为正 (点在相机前方)。</li><li>投影点 <code>(u, v)</code> 在 <code>pKF</code> 图像边界内。</li></ul></li><li>执行<strong>闭环特定的鲁棒性检查</strong>：<ul><li><strong>尺度不变性距离检查</strong>：计算 <code>pMP</code> 到 <code>pKF</code> 光心 <code>Ow</code> 的距离 <code>dist</code>，检查其是否在 <code>pMP</code> 的有效观测距离范围 (<code>minDistance</code>, <code>maxDistance</code>) 内。距离过远或过近可能导致描述子变化过大。</li><li><strong>视角检查</strong>：检查 <code>pKF</code> 对 <code>pMP</code> 的观测角度是否过大（&gt; 60度）。视角过大同样会导致外观变化剧烈。</li><li><strong>目的</strong>：这些额外检查是为了确保即使经过了可能的尺度漂移和较大的视角变化，匹配仍然是可靠的。</li></ul></li></ul></li><li><strong>预测尺度与搜索半径</strong>：<ul><li>根据 <code>pMP</code> 到 <code>pKF</code> 的距离 <code>dist</code>，预测 <code>pMP</code> 在 <code>pKF</code> 中应出现的金字塔层级 <code>nPredictedLevel</code>。</li><li>计算在该预测层级下的搜索半径 <code>radius</code>。</li></ul></li><li><strong>局部候选点搜索</strong> (Step 2.3):<ul><li>调用 <code>pKF-&gt;GetFeaturesInArea(u, v, radius)</code>，在投影点 <code>(u, v)</code> 附近找到空间上接近的 <code>pKF</code> 特征点索引 <code>vIndices</code>。</li></ul></li><li><strong>描述子匹配与最终确认</strong> (Step 2.4):<ul><li>遍历 <code>vIndices</code> 中的候选 <code>pKF</code> 特征点 <code>idx</code>：<ul><li><strong>再次过滤</strong>：跳过 <code>pKF</code> 中已匹配的特征点 (<code>vpMatched[idx]</code>)。</li><li><strong>严格尺度检查</strong>：要求候选点层级 <code>kpLevel</code> 必须与预测层级 <code>nPredictedLevel</code> 非常接近（通常是 <code>nPredictedLevel-1</code> 或 <code>nPredictedLevel</code>）。</li><li><strong>计算描述子距离</strong>：计算 <code>pMP</code> 描述子与候选点 <code>idx</code> 描述子之间的汉明距离 <code>dist</code>。</li><li><strong>寻找最佳匹配</strong>：找到距离最小 (<code>bestDist</code>) 的候选点 <code>bestIdx</code>。</li><li><strong>严格阈值判断</strong>：只有当 <code>bestDist</code> 小于一个<strong>较低的阈值 <code>TH_LOW</code></strong> 时，才认为匹配成功。这要求比普通跟踪更高的匹配置信度。</li><li><strong>存储新匹配</strong>：如果成功，更新 <code>vpMatched[bestIdx] = pMP</code>，并增加 <code>nmatches</code>。</li></ul></li></ul></li></ol><h3 id="c-返回结果-Code-Step-3"><a href="#c-返回结果-Code-Step-3" class="headerlink" title="c. 返回结果 (Code Step 3)"></a>c. 返回结果 (Code Step 3)</h3><ul><li>函数返回本次调用新发现并建立的匹配数量 <code>nmatches</code>。</li></ul><h2 id="4-函数意义与重要性"><a href="#4-函数意义与重要性" class="headerlink" title="4. 函数意义与重要性"></a>4. 函数意义与重要性</h2><ul><li>这个函数是<strong>闭环流程的关键一步</strong>，它利用已有的 Sim3 几何关系来指导匹配，可以<strong>挖掘出比初始检测更多的可靠匹配点</strong>。</li><li>这些新增的匹配点对于后续的 <strong>Sim3 位姿优化</strong> 和 <strong>地图点融合 (Map Fusion)</strong> 过程至关重要，它们提供了更强的约束，有助于精确地对齐地图、消除累积误差并修正尺度。</li><li>函数中各种严格的检查（尺度不变性、视角、低描述子距离阈值、严格尺度层级检查）确保了新增匹配的高质量，这对于保持地图一致性非常重要。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>投影匹配--帧间跟踪版</title>
      <link href="/2025/05/13/orbslam2-5/"/>
      <url>/2025/05/13/orbslam2-5/</url>
      
        <content type="html"><![CDATA[<h1 id="SearchByProjection-函数"><a href="#SearchByProjection-函数" class="headerlink" title="(SearchByProjection) 函数"></a>(SearchByProjection) 函数</h1><h2 id="1-函数目标与核心思想"><a href="#1-函数目标与核心思想" class="headerlink" title="1. 函数目标与核心思想"></a>1. 函数目标与核心思想</h2><p><code>SearchByProjection</code> 是 ORB-SLAM2 中用于<strong>连续帧间跟踪 (Frame-to-Frame Tracking)</strong> 的核心函数之一。</p><p><strong>核心思想</strong>：利用<strong>上一帧 (<code>LastFrame</code>) 已经构建好的三维地图点 (<code>MapPoint</code>)</strong>，结合<strong>当前帧 (<code>CurrentFrame</code>) 的初始位姿估计</strong>，来<strong>预测</strong>这些三维点在当前帧图像上的二维投影位置。然后在这些投影位置附近的小范围内搜索，以找到对应的二维特征点，从而建立匹配关系。</p><p>这是一种<strong>基于模型的预测与搜索策略</strong>，比盲目搜索或纯二维匹配更高效和鲁棒。</p><h2 id="2-前提条件"><a href="#2-前提条件" class="headerlink" title="2. 前提条件"></a>2. 前提条件</h2><ul><li><code>LastFrame</code> 中已经有一些特征点被成功三角化，并形成了稳定的 <code>MapPoint</code>（即已知其三维世界坐标）。</li><li>对 <code>CurrentFrame</code> 的相机位姿 <code>CurrentFrame.mTcw</code> (从世界坐标系到当前相机坐标系的变换) 有一个初始的估计。这个估计可能来自：<ul><li>匀速运动模型。</li><li>上一帧成功跟踪后的位姿。</li><li>重定位成功后的位姿。</li></ul></li></ul><h2 id="3-主要执行步骤与思想"><a href="#3-主要执行步骤与思想" class="headerlink" title="3. 主要执行步骤与思想"></a>3. 主要执行步骤与思想</h2><h3 id="a-准备工作与帧间运动估计-Code-Steps-1-2"><a href="#a-准备工作与帧间运动估计-Code-Steps-1-2" class="headerlink" title="a. 准备工作与帧间运动估计 (Code Steps 1, 2)"></a>a. 准备工作与帧间运动估计 (Code Steps 1, 2)</h3><ul><li><strong>初始化旋转直方图 (<code>rotHist</code>)</strong> (Code Step 1):<ul><li><strong>思想</strong>：用于后续的旋转一致性检查，以剔除外点。直方图统计匹配特征点对之间的主方向角度差。</li></ul></li><li><strong>计算当前帧相对于上一帧的运动信息</strong> (Code Step 2):<ul><li><strong>思想</strong>：了解相机是前进、后退还是基本保持距离，对于后续指导特征搜索的尺度（金字塔层级）非常重要。</li><li>通过两帧的位姿，计算出当前相机中心在上一帧相机坐标系下的平移向量 <code>tlc</code>。</li><li>根据 <code>tlc</code> 的 Z 分量判断前进 (<code>bForward</code>) 或后退 (<code>bBackward</code>) 状态（主要针对非单目）。</li></ul></li></ul><h3 id="b-投影地图点并进行局部搜索-Code-Steps-3-4"><a href="#b-投影地图点并进行局部搜索-Code-Steps-3-4" class="headerlink" title="b. 投影地图点并进行局部搜索 (Code Steps 3, 4)"></a>b. 投影地图点并进行局部搜索 (Code Steps 3, 4)</h3><ul><li><strong>遍历 <code>LastFrame</code> 的有效地图点 (<code>MapPoint</code>)</strong> (Code Step 3):<ul><li>对于每个与 <code>LastFrame</code> 特征点关联的 <code>MapPoint</code>：<ol><li>获取其三维世界坐标 <code>x3Dw</code>。</li><li>使用 <code>CurrentFrame</code> 的位姿 <code>Rcw</code>, <code>tcw</code> 将 <code>x3Dw</code> 变换到当前相机坐标系下，得到 <code>x3Dc</code>。</li><li><strong>检查有效性</strong>：确保点在相机前方 (<code>invzc &gt; 0</code>)。</li><li><strong>投影</strong>：使用 <code>CurrentFrame</code> 的相机内参将 <code>x3Dc</code> 投影到图像平面，得到预测的二维像素坐标 <code>(u, v)</code>。</li><li><strong>边界检查</strong>：确保 <code>(u, v)</code> 在图像有效范围内。</li></ol></li></ul></li><li><strong>在投影点附近使用 <code>GetFeaturesInArea</code> 进行局部搜索</strong> (Code Step 4):<ul><li><strong>思想</strong>：由于位姿估计、地图点定位等存在误差，真实匹配点会在投影位置附近。同时，物体由于相机远近移动，其在图像中的尺度会变化。</li><li><strong>确定搜索半径 <code>radius</code></strong>：基于上一帧特征点的金字塔层级进行缩放 (<code>th * CurrentFrame.mvScaleFactors[nLastOctave]</code>)。尺度大的特征（通常对应更远或更大的物体部分，或者在低分辨率金字塔层级检测到的特征），其不确定性可能更大，搜索半径也相应调整。</li><li><strong>自适应搜索金字塔层级</strong>：<ul><li>若相机前进 (<code>bForward</code>)：物体变大，当前帧特征可能在更高或相同层级。搜索范围 <code>[nLastOctave, maxLevel]</code>。</li><li>若相机后退 (<code>bBackward</code>)：物体变小，当前帧特征可能在更低或相同层级。搜索范围 <code>[0, nLastOctave]</code>。</li><li>若相机运动不明显：在上一帧层级附近搜索，如 <code>[nLastOctave-1, nLastOctave+1]</code>。</li></ul></li><li>调用 <code>CurrentFrame.GetFeaturesInArea(u,v, radius, minLevel, maxLevel)</code> 获得候选匹配特征点列表 <code>vIndices2</code>。</li></ul></li></ul><h3 id="c-描述子匹配与最佳选择-Code-Step-5"><a href="#c-描述子匹配与最佳选择-Code-Step-5" class="headerlink" title="c. 描述子匹配与最佳选择 (Code Step 5)"></a>c. 描述子匹配与最佳选择 (Code Step 5)</h3><ul><li><strong>思想</strong>：在位置和尺度上接近的候选点中，通过特征描述子的相似性（外观）来确定最佳匹配。</li><li>遍历 <code>vIndices2</code> 中的候选特征点：<ol><li><strong>排除已匹配点</strong>：若当前帧的候选特征点已有关联地图点，则跳过。</li><li><strong>（可选）双目&#x2F;RGB-D 一致性检查</strong>：对右目图像或深度值进行额外约束。</li><li><strong>计算描述子距离</strong>：计算 <code>LastFrame</code> 地图点 <code>pMP</code> 的描述子与当前帧候选特征点描述子之间的汉明距离 (<code>DescriptorDistance</code>)。</li><li><strong>选择最佳匹配</strong>：在所有候选点中，选择汉明距离最小且小于阈值 <code>TH_HIGH</code> 的作为最佳匹配点 <code>bestIdx2</code>。</li></ol></li></ul><h3 id="d-存储匹配并更新旋转直方图-Code-Step-6"><a href="#d-存储匹配并更新旋转直方图-Code-Step-6" class="headerlink" title="d. 存储匹配并更新旋转直方图 (Code Step 6)"></a>d. 存储匹配并更新旋转直方图 (Code Step 6)</h3><ul><li>如果找到有效匹配：<ol><li>在 <code>CurrentFrame</code> 中记录该匹配：<code>CurrentFrame.mvpMapPoints[bestIdx2] = pMP</code>。</li><li>增加成功匹配计数 <code>nmatches</code>。</li><li>若启用朝向检查 (<code>mbCheckOrientation</code>)：计算 <code>LastFrame</code> 特征点与 <code>CurrentFrame</code> 匹配特征点的主方向角度差，更新 <code>rotHist</code> 直方图。</li></ol></li></ul><h3 id="e-旋转一致性检查与外点剔除-Code-Step-7"><a href="#e-旋转一致性检查与外点剔除-Code-Step-7" class="headerlink" title="e. 旋转一致性检查与外点剔除 (Code Step 7)"></a>e. 旋转一致性检查与外点剔除 (Code Step 7)</h3><ul><li><strong>思想</strong>：利用刚体场景下特征点旋转角度变化的一致性来剔除误匹配。</li><li>分析 <code>rotHist</code> 直方图，找出票数最高的前三个主导旋转角度区间。</li><li>遍历所有之前建立的匹配，如果某个匹配的角度差不在这三个主导区间内，则将其视作外点，并从当前帧的匹配中移除 (<code>CurrentFrame.mvpMapPoints[rotHist[i][j]] = NULL</code>)，同时减少 <code>nmatches</code>。</li></ul><h2 id="4-函数优势"><a href="#4-函数优势" class="headerlink" title="4. 函数优势"></a>4. 函数优势</h2><ul><li><strong>高效性</strong>：通过投影预测，将搜索范围大大缩小，避免了全局或大范围的盲目搜索。</li><li><strong>鲁棒性</strong>：结合了位置预测、尺度自适应、外观（描述子）匹配以及几何（旋转）一致性等多重约束，能够有效地找到正确匹配并剔除外点。</li><li><strong>利用地图信息</strong>：充分利用了已建立的地图点信息，使得跟踪更为稳定。</li></ul><p>此方法是视觉 SLAM 中实现稳定、高效帧间跟踪的关键技术之一。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通过词袋进行匹配</title>
      <link href="/2025/05/13/orbslam2-4/"/>
      <url>/2025/05/13/orbslam2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="词袋模型-Bag-of-Words-BoW"><a href="#词袋模型-Bag-of-Words-BoW" class="headerlink" title="词袋模型 (Bag-of-Words, BoW)"></a>词袋模型 (Bag-of-Words, BoW)</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>词袋模型源于自然语言处理，在计算机视觉中被借鉴用于图像表示和检索。其核心思想是：</p><ul><li>将图像看作是由一些基本的“视觉单词”（Visual Words）组成的文档。</li><li>忽略特征点的空间布局信息（至少在生成 BoW 向量时），只关心图像中出现了哪些视觉单词以及它们的频率。</li><li>目的是得到一个能够概括图像内容的、紧凑的全局描述符。</li></ul><h2 id="2-ORB-SLAM2-中的-BoW-实现"><a href="#2-ORB-SLAM2-中的-BoW-实现" class="headerlink" title="2. ORB-SLAM2 中的 BoW 实现"></a>2. ORB-SLAM2 中的 BoW 实现</h2><h3 id="a-视觉词典-Visual-Vocabulary-Dictionary"><a href="#a-视觉词典-Visual-Vocabulary-Dictionary" class="headerlink" title="a. 视觉词典 (Visual Vocabulary &#x2F; Dictionary)"></a>a. 视觉词典 (Visual Vocabulary &#x2F; Dictionary)</h3><ul><li><strong>构建</strong>：这是一个<strong>离线预训练</strong>的过程。使用大量不同场景下的 ORB 特征描述子，通过聚类算法（如层次 K-Means）构建一个<strong>词典树（Vocabulary Tree）</strong>。</li><li><strong>结构</strong>：树的叶子节点代表一个<strong>视觉单词</strong>。每个视觉单词对应着描述子空间中的一个聚类中心。词典通常包含大量（例如 $10^4$ - $10^6$）视觉单词。</li><li><strong>作用</strong>：提供一个标准化的参照系，用于将连续的 ORB 描述子**量化（Quantize）**为离散的视觉单词 ID。</li></ul><h3 id="b-特征描述子量化"><a href="#b-特征描述子量化" class="headerlink" title="b. 特征描述子量化"></a>b. 特征描述子量化</h3><ul><li>对于图像中提取的每一个 ORB 特征描述子，在词典树中进行高效查找，找到与其最相似（距离最近）的视觉单词。</li><li>该特征点就被赋予了这个视觉单词的 ID。</li></ul><h3 id="c-BoW-向量生成"><a href="#c-BoW-向量生成" class="headerlink" title="c. BoW 向量生成"></a>c. BoW 向量生成</h3><ul><li>对整个图像（通常是关键帧），统计其中所有特征点被量化后的视觉单词 ID。</li><li>生成一个<strong>稀疏向量</strong>（BoW Vector），其维度等于词典中视觉单词的总数。</li><li>向量的每个元素表示对应视觉单词在该图像中出现的<strong>频率</strong>或<strong>权重</strong>（常用 <strong>TF-IDF</strong> - Term Frequency–Inverse Document Frequency - 来计算权重，以突出那些在当前帧常见但在整个数据集中不常见的词，增强区分度）。</li><li>这个 BoW 向量可以看作是该图像的<strong>全局“指纹”</strong>。</li></ul><h2 id="3-BoW-在-ORB-SLAM2-中的主要应用"><a href="#3-BoW-在-ORB-SLAM2-中的主要应用" class="headerlink" title="3. BoW 在 ORB-SLAM2 中的主要应用"></a>3. BoW 在 ORB-SLAM2 中的主要应用</h2><p>BoW 的核心优势在于<strong>高效的相似性检索</strong>，主要用于：</p><h3 id="a-闭环检测-Loop-Closure-Detection"><a href="#a-闭环检测-Loop-Closure-Detection" class="headerlink" title="a. 闭环检测 (Loop Closure Detection)"></a>a. 闭环检测 (Loop Closure Detection)</h3><ul><li><strong>目标</strong>：检测相机是否回到了先前经过的区域。</li><li><strong>方法</strong>：<ol><li>将当前帧（或新生成的关键帧）的 BoW 向量与数据库中存储的历史关键帧的 BoW 向量进行比较（计算相似度得分）。</li><li>利用 <strong>DBoW2</strong> 库中的倒排索引等加速结构，可以非常快速地找到 BoW 向量相似度高的候选关键帧。</li><li>高相似度意味着两个关键帧在视觉内容上可能很接近，是潜在的闭环候选帧。</li></ol></li></ul><h3 id="b-重定位-Relocalization"><a href="#b-重定位-Relocalization" class="headerlink" title="b. 重定位 (Relocalization)"></a>b. 重定位 (Relocalization)</h3><ul><li><strong>目标</strong>：当跟踪丢失时，确定相机当前在地图中的位置。</li><li><strong>方法</strong>：<ol><li>计算当前帧的 BoW 向量。</li><li>在关键帧数据库中搜索与之 BoW 向量最相似的关键帧。</li><li>这些相似的关键帧及其位姿可以为当前帧提供一个初始的位姿估计。</li></ol></li></ul><h2 id="4-BoW-在-ORB-SLAM2-中的次要应用：加速特征匹配"><a href="#4-BoW-在-ORB-SLAM2-中的次要应用：加速特征匹配" class="headerlink" title="4. BoW 在 ORB-SLAM2 中的次要应用：加速特征匹配"></a>4. BoW 在 ORB-SLAM2 中的次要应用：加速特征匹配</h2><ul><li><strong>场景</strong>：当通过 BoW 向量比较<strong>已找到</strong>潜在的闭环&#x2F;重定位候选帧后，需要在当前帧和候选帧之间进行精确的<strong>特征点匹配</strong>，以进行几何验证和位姿计算。</li><li><strong>方法</strong>：可以利用特征点所属的视觉单词信息来加速匹配。如果两个特征点是真匹配，它们的描述子很可能属于同一个视觉单词。因此，可以：<ul><li><strong>优先</strong>匹配属于同一视觉单词的特征点对。</li><li><strong>只</strong>在属于同一视觉单词的特征点子集之间进行匹配尝试。</li></ul></li><li><strong>优势</strong>：减少了需要进行暴力匹配的特征点对数量，提高了后续几何验证步骤的效率。</li></ul><h2 id="5-与连续帧跟踪的区别"><a href="#5-与连续帧跟踪的区别" class="headerlink" title="5. 与连续帧跟踪的区别"></a>5. 与连续帧跟踪的区别</h2><ul><li>在**连续帧跟踪（Tracking）**过程中，ORB-SLAM2 <strong>主要不依赖</strong> BoW 进行特征匹配。</li><li>Tracking 更多地使用基于<strong>上一帧位姿和地图点</strong>的<strong>投影匹配</strong>，并结合<strong>局部区域搜索</strong>（如 <code>Frame::GetFeaturesInArea</code>）来高效、准确地找到匹配。</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>ORB-SLAM2 中的 BoW 模型是一个强大的工具，它通过将图像内容表示为视觉单词的集合，生成紧凑的全局描述符 (BoW Vector)。这使得系统能够<strong>极快地在大量关键帧中检索视觉上相似的场景</strong>，是实现高效<strong>闭环检测</strong>和<strong>重定位</strong>的关键技术。同时，它也能在后续步骤中<strong>辅助加速特征点匹配</strong>过程。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单目初始化中的特征匹配</title>
      <link href="/2025/05/13/orbslam2-3/"/>
      <url>/2025/05/13/orbslam2-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Frame-GetFeaturesInArea-函数"><a href="#Frame-GetFeaturesInArea-函数" class="headerlink" title="Frame::GetFeaturesInArea 函数"></a><code>Frame::GetFeaturesInArea</code> 函数</h1><h2 id="1-函数目标"><a href="#1-函数目标" class="headerlink" title="1. 函数目标"></a>1. 函数目标</h2><p>该函数的核心目的是在给定的图像帧 (<code>Frame</code>) 中，<strong>高效地</strong>查找满足以下条件的特征点：</p><ol><li>位于以指定点 <code>(x, y)</code> 为圆心、<code>r</code> 为半径的<strong>圆形区域</strong>内。</li><li>其所在的<strong>图像金字塔层级</strong> (<code>octave</code>) 在指定的 <code>[minLevel, maxLevel]</code> 范围内（可选）。</li></ol><p>这在特征匹配、局部地图跟踪等场景中非常常用，需要在某个预期位置附近搜索对应的特征点。</p><h2 id="2-面临的挑战与常规思路"><a href="#2-面临的挑战与常规思路" class="headerlink" title="2. 面临的挑战与常规思路"></a>2. 面临的挑战与常规思路</h2><p>如果图像中有大量特征点（例如上千个），最直观的方法是：</p><ul><li>遍历当前帧中的<strong>所有</strong>特征点。</li><li>对<strong>每一个</strong>特征点，计算它到圆心 <code>(x, y)</code> 的距离。</li><li>判断距离是否小于 <code>r</code>，并且层级是否符合要求。</li></ul><p><strong>缺点：</strong> 计算量巨大，需要对所有点进行距离计算，对于实时性要求高的 SLAM 系统来说效率太低。</p><h2 id="3-ORB-SLAM2-的优化策略：网格化加速-Grid-based-Acceleration"><a href="#3-ORB-SLAM2-的优化策略：网格化加速-Grid-based-Acceleration" class="headerlink" title="3. ORB-SLAM2 的优化策略：网格化加速 (Grid-based Acceleration)"></a>3. ORB-SLAM2 的优化策略：网格化加速 (Grid-based Acceleration)</h2><p>为了解决效率问题，ORB-SLAM2 采用了<strong>空间划分</strong>的思想，具体为<strong>网格化</strong>：</p><ul><li><strong>预处理</strong>：在提取特征点后，系统会根据每个特征点的坐标，将其分配到预先划分好的<strong>二维网格</strong> (<code>mGrid</code>) 中。每个网格单元存储落入其中的特征点的索引列表。</li><li><strong><code>GetFeaturesInArea</code> 的执行逻辑</strong>：<ol><li><strong>确定相关网格 (Coarse Filtering)</strong>：<ul><li>根据输入的圆心 <code>(x, y)</code> 和半径 <code>r</code>，计算出这个圆形区域<strong>可能覆盖</strong>到的<strong>网格单元</strong>的最小&#x2F;最大行号和列号 (<code>nMinCellX</code> 到 <code>nMaxCellX</code>, <code>nMinCellY</code> 到 <code>nMaxCellY</code>)。</li><li><strong>目的</strong>：快速确定一个包含搜索圆的<strong>矩形网格区域</strong>，将搜索范围从整个图像缩小到少数几个网格单元。</li></ul></li><li><strong>遍历候选特征点</strong>：<ul><li><strong>只</strong>遍历上一步确定的相关网格单元。</li><li>获取这些网格单元中包含的所有特征点索引。这些点是“候选点”。</li><li><strong>目的</strong>：大大减少需要进一步检查的特征点数量。</li></ul></li><li><strong>精确筛选 (Fine Filtering)</strong>：<ul><li>对<strong>每一个候选点</strong>执行精确检查：<ul><li><strong>层级检查</strong>：<code>kpUn.octave</code> 是否在 <code>[minLevel, maxLevel]</code> 之间。</li><li><strong>距离检查</strong>：计算该点到圆心 <code>(x, y)</code> 的<strong>精确距离</strong>，判断是否 <code>&lt; r</code> （通常用距离平方 <code>&lt; r*r</code> 来避免开方运算）。</li></ul></li><li><strong>目的</strong>：从候选点中精确找出真正符合圆形区域和层级要求的点。</li></ul></li><li><strong>返回结果</strong>：收集所有通过精确筛选的特征点的索引。</li></ol></li></ul><h2 id="4-核心思想总结：为何需要“网格-距离判断”？"><a href="#4-核心思想总结：为何需要“网格-距离判断”？" class="headerlink" title="4. 核心思想总结：为何需要“网格+距离判断”？"></a>4. 核心思想总结：为何需要“网格+距离判断”？</h2><ul><li><strong>网格是矩形的，搜索区是圆形的</strong>：网格能快速定位到包含搜索圆的<strong>矩形</strong>区域内的候选点，但这个矩形区域比圆形区域要大。</li><li><strong>网格提供粗筛</strong>：它能高效排除大量无关的点，提供一个较小的<strong>候选集</strong>。</li><li><strong>距离判断提供精筛</strong>：对于网格筛选出的候选点，必须进行精确的距离计算，才能判断它们是否<strong>真正</strong>位于<strong>圆形</strong>区域内部，排除那些在矩形网格内但在圆形区域外的点。</li></ul><p><strong>结论：</strong> <code>GetFeaturesInArea</code> 通过<strong>网格进行快速粗筛</strong>，然后对<strong>少量候选点进行精确的距离和层级判断</strong>，实现了在保证准确性的前提下，大幅提升邻域特征点搜索效率的目标。这是一种典型的<strong>空间换时间</strong>优化策略。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关键帧类</title>
      <link href="/2025/05/13/orbslam2-2/"/>
      <url>/2025/05/13/orbslam2-2/</url>
      
        <content type="html"><![CDATA[<p><code>KeyFrame</code>（关键帧）是 ORB_SLAM2 系统中非常核心的一个概念和数据结构。它不是每一帧都创建，而是从普通的 <code>Frame</code> 对象中选取具有代表性的帧来创建。关键帧构成了地图的基础，用于跟踪、局部建图和回环检测。</p><p>以下是对 <code>KeyFrame</code> 类的详细解析：</p><h3 id="1-关键帧的角色与创建"><a href="#1-关键帧的角色与创建" class="headerlink" title="1. 关键帧的角色与创建"></a><strong>1. 关键帧的角色与创建</strong></h3><ul><li><strong>作用</strong>：关键帧是地图的基本单元，存储了比普通帧更持久和重要的信息，用于优化相机轨迹和构建环境地图。它们之间通过共视图（Covisibility Graph）和生成树（Spanning Tree）等结构连接起来。</li><li><strong>创建</strong>：关键帧由一个 <code>Frame</code> 对象、一个指向地图 <code>Map</code> 的指针和一个指向关键帧数据库 <code>KeyFrameDatabase</code> 的指针来构造。构造时，它会从父 <code>Frame</code> 复制大量信息，如时间戳、相机参数、特征点、描述子、地图点关联等，并被赋予一个唯一的 <code>mnId</code>。</li></ul><h3 id="2-核心数据成员（属性）"><a href="#2-核心数据成员（属性）" class="headerlink" title="2. 核心数据成员（属性）"></a><strong>2. 核心数据成员（属性）</strong></h3><p><code>KeyFrame</code> 类包含了众多成员变量来存储其状态和信息，主要分为几类：</p><ul><li><strong>标识与时间戳</strong>：<ul><li><code>mnId</code>: 关键帧的唯一 ID。</li><li><code>mnFrameId</code>: 创建此关键帧的原始 <code>Frame</code> 的 ID。</li><li><code>mTimeStamp</code>: 时间戳。</li></ul></li><li><strong>位姿信息</strong>：<ul><li><code>Tcw</code>: 从世界坐标系到当前相机坐标系的变换矩阵。</li><li><code>Twc</code>: 从相机坐标系到世界坐标系的变换矩阵（Tcw 的逆）。</li><li><code>Ow</code>: 相机光心在世界坐标系下的坐标。</li><li>这些位姿信息通过 <code>mMutexPose</code> 互斥锁保护，需要通过 <code>SetPose</code>, <code>GetPose</code>, <code>GetPoseInverse</code>, <code>GetCameraCenter</code> 等函数访问。</li></ul></li><li><strong>相机与图像信息</strong>：<ul><li>相机内参 (<code>fx</code>, <code>fy</code>, <code>cx</code>, <code>cy</code>, <code>invfx</code>, <code>invfy</code>, <code>mK</code>)。</li><li>双目&#x2F;深度信息 (<code>mbf</code>, <code>mb</code>, <code>mThDepth</code>)。</li><li>图像边界 (<code>mnMinX</code>, <code>mnMinY</code>, <code>mnMaxX</code>, <code>mnMaxY</code>)。</li><li>图像网格 (<code>mGrid</code>)：用于加速特征点匹配，存储每个网格单元内的特征点索引。</li></ul></li><li><strong>特征点与描述子</strong>：<ul><li><code>N</code>: 特征点数量。</li><li><code>mvKeys</code>: 原始特征点 (cv::KeyPoint 格式)。</li><li><code>mvKeysUn</code>: 去畸变后的归一化特征点坐标。</li><li><code>mDescriptors</code>: 特征点的 ORB 描述子。</li><li><code>mvuRight</code> &#x2F; <code>mvDepth</code>: 双目或 RGB-D 下特征点的右图像坐标或深度信息。</li></ul></li><li><strong>地图点关联</strong>：<ul><li><code>mvpMapPoints</code>: 一个 <code>std::vector&lt;MapPoint*&gt;</code>，存储与该关键帧中特征点关联的地图点指针。如果某个特征点没有关联地图点，或关联的地图点被删除，则对应指针为 <code>NULL</code>。该变量由 <code>mMutexFeatures</code> 保护。</li></ul></li><li><strong>词袋模型 (BoW)</strong>：<ul><li><code>mBowVec</code>: DBoW2 格式的词袋向量，用于快速进行图像识别（回环检测、重定位）。</li><li><code>mFeatVec</code>: DBoW2 格式的特征向量，记录了特征点到词典内部节点的映射关系。</li><li>通过 <code>ComputeBoW()</code> 函数计算生成。</li></ul></li><li><strong>图结构信息</strong>（由 <code>mMutexConnections</code> 保护）：<ul><li><strong>共视图 (Covisibility Graph)</strong>：<ul><li><code>mConnectedKeyFrameWeights</code>: 存储与其他关键帧的连接及其权重（共视地图点数量）。</li><li><code>mvpOrderedConnectedKeyFrames</code>, <code>mvOrderedWeights</code>: 按权重排序后的共视关键帧列表及其权重。</li></ul></li><li><strong>生成树 (Spanning Tree)</strong>：<ul><li><code>mpParent</code>: 指向父关键帧（通常是共视程度最高的那个）。</li><li><code>mspChildrens</code>: 指向子关键帧的集合。</li></ul></li><li><strong>回环边 (Loop Edges)</strong>：<ul><li><code>mspLoopEdges</code>: 存储与当前关键帧形成闭环关系的关键帧集合。</li></ul></li></ul></li><li><strong>状态标志</strong>：<ul><li><code>mbBad</code>: 标记该关键帧是否已被标记为“坏点”，准备或已经被删除。</li><li><code>mbNotErase</code>, <code>mbToBeErased</code>: 用于控制删除逻辑，例如在进行回环优化时暂时阻止删除。</li></ul></li><li><strong>指针</strong>：<ul><li><code>mpMap</code>: 指向所属的 <code>Map</code> 对象。</li><li><code>mpKeyFrameDB</code>: 指向 <code>KeyFrameDatabase</code>。</li><li><code>mpORBvocabulary</code>: 指向 ORB 词典。</li></ul></li></ul><h3 id="3-核心功能（成员函数）"><a href="#3-核心功能（成员函数）" class="headerlink" title="3. 核心功能（成员函数）"></a><strong>3. 核心功能（成员函数）</strong></h3><ul><li><strong>位姿管理</strong>：<code>SetPose</code> 设置位姿并计算相关变量 (Ow, Twc)，<code>GetPose</code> 等函数提供线程安全的位姿访问。</li><li><strong>BoW 计算</strong>：<code>ComputeBoW</code> 使用 ORB 词典计算关键帧的词袋表示。</li><li><strong>共视图管理</strong>：<ul><li><code>AddConnection</code>: 添加与其他关键帧的共视连接。</li><li><code>EraseConnection</code>: 删除共视连接。</li><li><code>UpdateConnections</code>: 核心函数，根据共享的地图点重新计算并更新与其他关键帧的共视权重和连接关系。</li><li><code>UpdateBestCovisibles</code>: 对共视关键帧按权重排序。</li><li><code>GetConnectedKeyFrames</code>, <code>GetVectorCovisibleKeyFrames</code>, <code>GetBestCovisibilityKeyFrames</code>, <code>GetCovisiblesByWeight</code>, <code>GetWeight</code>: 提供不同方式查询共视关键帧。</li></ul></li><li><strong>生成树管理</strong>：<code>AddChild</code>, <code>EraseChild</code>, <code>ChangeParent</code>, <code>GetChilds</code>, <code>GetParent</code>, <code>hasChild</code> 用于维护生成树结构。</li><li><strong>回环边管理</strong>：<code>AddLoopEdge</code>, <code>GetLoopEdges</code> 用于记录和查询回环信息。</li><li><strong>地图点管理</strong>：<ul><li><code>AddMapPoint</code>: 关联一个地图点到指定的特征点索引。</li><li><code>EraseMapPointMatch</code>: 断开与某个地图点的关联（将指针设为 NULL）。</li><li><code>ReplaceMapPointMatch</code>: 替换某个索引处的地图点关联。</li><li><code>GetMapPoints</code>, <code>GetMapPointMatches</code>, <code>GetMapPoint</code>: 获取关联的地图点信息。</li><li><code>TrackedMapPoints</code>: 统计被有效跟踪（观测次数达标）的地图点数量。</li></ul></li><li><strong>特征点相关操作</strong>：<ul><li><code>GetFeaturesInArea</code>: 在指定区域内快速查找特征点。</li><li><code>UnprojectStereo</code>: 将双目或 RGB-D 特征点反投影到三维空间。</li><li><code>IsInImage</code>: 判断某个二维点是否在图像范围内。</li></ul></li><li><strong>删除管理</strong>：<ul><li><code>SetNotErase</code>, <code>SetErase</code>: 控制是否允许删除该关键帧。</li><li><code>SetBadFlag</code>: 标记关键帧为坏点，并执行复杂的清理逻辑，包括：断开与其他关键帧的连接、通知地图点移除观测、更新生成树结构、从地图和关键帧数据库中移除自身。这是一个非常关键的操作，确保地图结构的完整性。</li><li><code>isBad</code>: 查询关键帧是否已被标记为坏点。</li></ul></li><li><strong>其他</strong>：<ul><li><code>ComputeSceneMedianDepth</code>: 估计场景深度（主要用于单目初始化）。</li></ul></li></ul><h3 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4. 线程安全"></a><strong>4. 线程安全</strong></h3><p>由于 ORB_SLAM2 是多线程系统（Tracking, Local Mapping, Loop Closing），<code>KeyFrame</code> 的很多数据会被多个线程同时访问。因此，关键数据（位姿、图连接、地图点关联）都使用了 <code>std::mutex</code> 进行保护，以确保线程安全。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><code>KeyFrame</code> 类是 ORB_SLAM2 中地图表示的核心，它不仅存储了自身的详细信息（位姿、特征、BoW），更重要的是维护了与其他关键帧（通过共视图、生成树、回环边）和地图点之间的复杂连接关系。这些关系是 SLAM 系统进行优化和保持一致性的基础。对 <code>KeyFrame</code> 的管理（创建、更新连接、删除）是 Local Mapping 和 Loop Closing 线程的关键任务。</p><h2 id="何时插入关键帧"><a href="#何时插入关键帧" class="headerlink" title="何时插入关键帧"></a>何时插入关键帧</h2><ol><li><strong>距离上一个关键帧足够远</strong>: 确保自从上一次插入关键帧后，已经过了一定的时间或者处理了足够数量的帧，以防止关键帧插入过于密集。</li><li><strong>跟踪质量下降</strong>: 当前帧能够稳定跟踪到的地图点数量显著减少。这通常通过以下两种方式之一来判断：<ul><li>当前帧跟踪到的地图点总数低于某个下限阈值。</li><li>当前帧跟踪到的地图点数量，相比于其参考关键帧（通常是距离最近的关键帧）所能看到的地图点数量，低于一个特定的比例（例如90%）。这表明视角或场景发生了显著变化。</li></ul></li><li><strong>局部建图线程准备就绪</strong>: 负责处理新关键帧和进行局部优化的“局部建图”（Local Mapping）线程当前不是非常繁忙，并且允许接受新的关键帧。如果它正在进行耗时的局部BA（Bundle Adjustment）或者全局BA，或者被其他原因阻塞，则会暂停插入。</li><li><strong>满足最小跟踪点数</strong>: 即使满足了与参考关键帧的比例条件，通常也要求当前帧跟踪到的点数不能过少（要高于另一个更低的阈值），以保证关键帧的质量。</li></ol><p>简单来说，插入关键帧是为了在<strong>视角变化足够大（跟踪点减少）、距离上一关键帧有一定间隔、且后端处理单元有能力处理</strong>时，向地图中添加新的、带有足够信息的节点。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mappoint类</title>
      <link href="/2025/05/13/orbslam2-1/"/>
      <url>/2025/05/13/orbslam2-1/</url>
      
        <content type="html"><![CDATA[<p><strong><code>MapPoint</code> 类的核心定位：场景中的三维点</strong></p><p>简单来说，<code>MapPoint</code> 类代表了在三维真实世界中的一个<strong>静态点</strong>。在 SLAM 系统运行过程中，相机会从不同的视角观测到场景中的特征点（比如墙角、纹理清晰的物体表面等）。当系统通过三角化等方法确定了这些二维图像特征点对应的三维空间位置后，就会创建一个 <code>MapPoint</code> 对象来存储这个三维点的信息。</p><p><strong><code>MapPoint</code> 类的主要职责和包含的信息：</strong></p><p><code>MapPoint</code> 类不仅仅存储一个三维点的坐标，它还包含了大量与这个三维点相关的观测信息、几何属性以及在 SLAM 系统不同模块中用于追踪和优化的状态信息。</p><p>以下是 <code>MapPoint</code> 类的主要成员变量和功能的概览：</p><hr><p><strong>1. 核心属性 (Core Properties):</strong></p><ul><li><strong><code>mWorldPos</code> (类型: <code>cv::Mat</code>)</strong>:<ul><li><strong>含义</strong>: 地图点在<strong>世界坐标系</strong>下的三维坐标 (通常是一个 3x1 的列向量)。这是 <code>MapPoint</code> 最基本也是最重要的信息。</li><li><strong>获取&#x2F;设置</strong>: 通过 <code>GetWorldPos()</code> 和 <code>SetWorldPos()</code> 方法。</li></ul></li><li><strong><code>mnId</code> (类型: <code>long unsigned int</code>)</strong>:<ul><li><strong>含义</strong>: 每个 <code>MapPoint</code> 对象都有一个全局唯一的 ID。通过静态成员变量 <code>nNextId</code> 自增生成，确保了 ID 的唯一性。</li></ul></li><li><strong><code>mpRefKF</code> (类型: <code>KeyFrame*</code>)</strong>:<ul><li><strong>含义</strong>: 指向该地图点的<strong>参考关键帧</strong> (Reference KeyFrame) 的指针。通常是第一个创建该地图点的关键帧，或者与该地图点关联最紧密的关键帧。参考关键帧对于计算地图点的观测距离范围等属性非常重要。</li><li><strong>获取</strong>: 通过 <code>GetReferenceKeyFrame()</code> 方法。</li></ul></li><li><strong><code>mDescriptor</code> (类型: <code>cv::Mat</code>)</strong>:<ul><li><strong>含义</strong>: 该地图点的<strong>代表性描述子 (Descriptor)</strong>。一个三维点可能被多个关键帧观测到，每个观测都会对应一个二维特征点的描述子（例如 ORB 描述子）。<code>mDescriptor</code> 存储的是从这些观测到的描述子中挑选出来的一个“最具代表性”的描述子。这个描述子用于后续的特征匹配，例如在重定位或闭环检测中快速识别该地图点。</li><li><strong>计算</strong>: 通过 <code>ComputeDistinctiveDescriptors()</code> 方法计算。该方法会比较所有观测到该点的描述子，选择与其他描述子平均距离最小的那个。</li><li><strong>获取</strong>: 通过 <code>GetDescriptor()</code> 方法。</li></ul></li></ul><hr><p><strong>2. 观测信息 (Observation Information):</strong></p><ul><li><strong><code>mObservations</code> (类型: <code>std::map&lt;KeyFrame*, size_t&gt;</code>)</strong>:<ul><li><strong>含义</strong>: 一个 <code>std::map</code> 容器，记录了所有<strong>观测到</strong>这个地图点的关键帧 (<code>KeyFrame*</code>) 以及该地图点在对应关键帧中特征点的索引 (<code>size_t</code>)。这是维护地图点与关键帧之间关联的核心数据结构，也是构建共视图的基础。</li><li><strong>操作</strong>:<ul><li><code>AddObservation()</code>: 添加一个新的观测关系。</li><li><code>EraseObservation()</code>: 移除一个观测关系。</li><li><code>GetObservations()</code>: 获取所有观测关系。</li></ul></li><li><strong><code>nObs</code> (类型: <code>int</code>)</strong>:<ul><li><strong>含义</strong>: 观测到该地图点的<strong>相机数目</strong>。对于单目相机，每次观测 <code>nObs</code> 加1；对于双目或 RGB-D 相机（可以提供深度信息，相当于两个独立的观测），每次观测 <code>nObs</code> 加2。这个值用于判断地图点的可靠性。</li><li><strong>获取</strong>: 通过 <code>Observations()</code> 方法。</li></ul></li></ul></li></ul><hr><p><strong>3. 几何与尺度属性 (Geometric and Scale Properties):</strong></p><ul><li><strong><code>mNormalVector</code> (类型: <code>cv::Mat</code>)</strong>:<ul><li><strong>含义</strong>: 地图点的<strong>平均观测方向</strong>。计算方法是：将所有观测到该点的关键帧相机光心指向该点的方向向量进行归一化，然后求平均。这个向量指示了该点主要从哪个方向被观测。</li><li><strong>用途</strong>: 用于判断地图点是否在当前相机视野内（可见性剔除）。</li><li><strong>更新</strong>: 通过 <code>UpdateNormalAndDepth()</code> 方法。</li><li><strong>获取</strong>: 通过 <code>GetNormal()</code> 方法。</li></ul></li><li><strong><code>mfMinDistance</code>, <code>mfMaxDistance</code> (类型: <code>float</code>)</strong>:<ul><li><strong>含义</strong>: 地图点的<strong>最小和最大有效观测距离</strong>。这两个值是基于该地图点在其参考关键帧中的观测情况（特征点所在的金字塔层级和到相机的距离）来估计的。它们定义了一个深度范围，在这个范围内，该地图点可以被认为是可靠的观测。</li><li><strong>用途</strong>: 用于 <code>PredictScale()</code> 函数，预测当地图点投影到新图像时，对应的特征点应该在图像金字塔的哪个尺度层级。</li><li><strong>更新</strong>: 通过 <code>UpdateNormalAndDepth()</code> 方法。</li><li><strong>获取</strong>: 通过 <code>GetMinDistanceInvariance()</code> 和 <code>GetMaxDistanceInvariance()</code> (这两个方法会返回 <code>0.8f*mfMinDistance</code> 和 <code>1.2f*mfMaxDistance</code>，增加了一些容错范围)。</li></ul></li></ul><hr><p><strong>4. 状态与追踪计数器 (Status and Tracking Counters):</strong></p><ul><li><strong><code>mbBad</code> (类型: <code>bool</code>)</strong>:<ul><li><strong>含义</strong>: 标记该地图点是否为<strong>坏点 (Bad Point)</strong>。如果一个地图点的观测过少，或者在优化过程中被认为是外点，就可能被标记为坏点。坏点将不再参与后续的追踪和优化。</li><li><strong>设置</strong>: 通过 <code>SetBadFlag()</code> 方法。该方法不仅设置 <code>mbBad</code> 为 <code>true</code>，还会清除其所有观测关系，并通知所属的地图 (<code>mpMap</code>) 将其从地图中移除。</li><li><strong>检查</strong>: 通过 <code>isBad()</code> 方法。</li></ul></li><li><strong><code>mpReplaced</code> (类型: <code>MapPoint*</code>)</strong>:<ul><li><strong>含义</strong>: 指向<strong>替换</strong>当前地图点的另一个地图点的指针。在地图点融合（MapPoint fusion）的过程中，如果发现两个地图点实际上是同一个三维点，质量较差的那个会被质量较好的那个替换掉。<code>mpReplaced</code> 就指向那个质量更好的地图点。</li><li><strong>设置&#x2F;获取</strong>: 通过 <code>Replace()</code> 和 <code>GetReplaced()</code> 方法。</li></ul></li><li><strong><code>mnVisible</code> (类型: <code>int</code>)</strong>:<ul><li><strong>含义</strong>: 该地图点<strong>在帧视野中出现的次数</strong>。只要一个地图点通过了 <code>Frame::isInFrustum()</code> 的判断（即理论上在当前相机视野内），即使没有成功匹配上特征点，<code>mnVisible</code> 也会增加。</li><li><strong>操作</strong>: 通过 <code>IncreaseVisible()</code> 方法增加计数。</li></ul></li><li><strong><code>mnFound</code> (类型: <code>int</code>)</strong>:<ul><li><strong>含义</strong>: 该地图点<strong>成功匹配到帧中特征点的次数</strong>。这个计数比 <code>mnVisible</code> 更严格，要求地图点不仅在视野内，而且成功地与某一帧的特征点建立了对应关系。</li><li><strong>操作</strong>: 通过 <code>IncreaseFound()</code> 方法增加计数。</li><li><strong>获取</strong>: 通过 <code>GetFound()</code> 方法。</li><li><strong><code>GetFoundRatio()</code></strong>: 返回 <code>mnFound / mnVisible</code> 的比例，可以用来评估地图点的追踪稳定性。</li></ul></li></ul><hr><p><strong>5. 用于不同线程的状态标记 (Status Flags for Different Threads):</strong></p><p>ORB-SLAM2 是一个多线程系统，<code>MapPoint</code> 类中包含了一些用于在不同线程（Tracking, Local Mapping, Loop Closing）中同步状态或避免重复操作的标记性成员变量。这些变量通常存储的是关键帧的 ID 或帧的 ID。</p><ul><li><strong>用于 Tracking 线程</strong>:<ul><li><code>mTrackProjX</code>, <code>mTrackProjY</code>, <code>mTrackProjXR</code>: 存储地图点投影到当前帧的像素坐标（<code>XR</code> 为右目坐标）。</li><li><code>mnTrackScaleLevel</code>: 预测该地图点在当前帧中对应的特征点的金字塔层级。</li><li><code>mTrackViewCos</code>: 地图点的平均观测方向与当前相机到该点方向的夹角的余弦值，用于判断视角是否合适。</li><li><code>mbTrackInView</code>: 标记该地图点在当前帧的追踪过程中是否已经被处理过或是否在视野内。</li><li><code>mnTrackReferenceForFrame</code>: 在 <code>TrackLocalMap</code> 的 <code>UpdateLocalPoints</code> 步骤中，用于防止将同一个地图点重复添加到局部地图点列表 <code>mvpLocalMapPoints</code>。</li><li><code>mnLastFrameSeen</code>: 记录上一次“看到”（即使只是在视野内）该地图点的帧的 ID。</li></ul></li><li><strong>用于 Local Mapping 线程</strong>:<ul><li><code>mnBALocalForKF</code>: 记录该地图点上一次参与局部 BA (Bundle Adjustment) 时对应的关键帧 ID。</li><li><code>mnFuseCandidateForKF</code>: 在地图点融合过程中，标记该地图点是哪个关键帧的融合候选者。</li></ul></li><li><strong>用于 Loop Closing 线程</strong>:<ul><li><code>mnLoopPointForKF</code>: 标记该地图点在闭环检测中是作为哪个“当前关键帧”的闭环候选地图点。</li><li><code>mnCorrectedByKF</code>: 记录上一次通过闭环校正更新该地图点位置时，是基于哪个关键帧的校正。</li><li><code>mnCorrectedReference</code>: 类似 <code>mnCorrectedByKF</code>，用于更细致的校正跟踪。</li><li><code>mPosGBA</code>: 存储在全局 BA (Global Bundle Adjustment) 优化后的地图点位置。</li><li><code>mnBAGlobalForKF</code>: 记录该地图点上一次参与全局 BA 时，触发全局 BA 的关键帧 ID。</li></ul></li></ul><hr><p><strong>6. 构造函数 (Constructors):</strong></p><p><code>MapPoint</code> 类有两个主要的构造函数：</p><ul><li><strong><code>MapPoint(const cv::Mat &amp;Pos, KeyFrame* pRefKF, Map* pMap)</code></strong>:<ul><li>最常用的构造函数，用于根据一个已知的<strong>三维坐标 <code>Pos</code></strong> 和一个<strong>参考关键帧 <code>pRefKF</code></strong> 来创建一个新的地图点。</li><li>通常在三角化新的地图点时（例如单目初始化、双目&#x2F;RGB-D 初始化、局部建图线程创建新点）被调用。</li></ul></li><li><strong><code>MapPoint(const cv::Mat &amp;Pos, Map* pMap, Frame* pFrame, const int &amp;idxF)</code></strong>:<ul><li>用于根据一个已知的<strong>三维坐标 <code>Pos</code></strong> 和一个<strong>普通帧 <code>pFrame</code></strong> 以及该点在帧中对应的特征点索引 <code>idxF</code> 来创建地图点。</li><li>这种构造方式通常用于双目或 RGB-D 相机，当可以直接从一帧图像中获取到某些特征点的三维信息时（例如，在 <code>Tracking::UpdateLastFrame()</code> 中为双目&#x2F;RGB-D 创建临时地图点以增强追踪鲁棒性）。这种方式创建的点，其初始参考关键帧 <code>mpRefKF</code> 会被设为 <code>NULL</code>。</li></ul></li></ul><hr><p><strong>7. 核心方法 (Key Methods):</strong></p><p>除了上面提到的获取&#x2F;设置方法和计数器增加方法外，还有一些核心的功能性方法：</p><ul><li><strong><code>UpdateNormalAndDepth()</code></strong>: 更新平均观测方向和观测距离范围，这在之前已经详细讲过。</li><li><strong><code>ComputeDistinctiveDescriptors()</code></strong>: 计算并更新最具代表性的描述子。</li><li><strong><code>SetBadFlag()</code></strong>: 将地图点标记为坏点，并进行清理。</li><li><strong><code>Replace(MapPoint* pMP)</code></strong>: 用另一个地图点 <code>pMP</code> 替换当前地图点，主要发生在地图点融合时。此操作会将被替换点的观测关系等信息转移到替换它的点上，然后将被替换点标记为坏点。</li><li><strong><code>AddObservation(KeyFrame* pKF, size_t idx)</code></strong>: 添加一个关键帧对该地图点的观测。</li><li><strong><code>EraseObservation(KeyFrame* pKF)</code></strong>: 移除一个关键帧对该地图点的观测。</li><li><strong><code>PredictScale(const float &amp;currentDist, KeyFrame* pKF / Frame* pF)</code></strong>: 根据地图点到当前相机光心的距离，以及其参考观测距离范围，预测该地图点在当前帧&#x2F;关键帧中应该位于图像金字塔的哪个层级。</li></ul><hr><p><strong>8. 线程安全 (Thread Safety):</strong></p><p>由于 <code>MapPoint</code> 的成员变量可能被多个线程（Tracking, Local Mapping, Loop Closing）同时访问和修改，类中使用了一些互斥锁 (<code>std::mutex</code>) 来保护关键数据的读写，以保证线程安全：</p><ul><li><strong><code>mMutexPos</code></strong>: 保护与位置相关的成员变量，如 <code>mWorldPos</code>, <code>mNormalVector</code>, <code>mfMinDistance</code>, <code>mfMaxDistance</code>。</li><li><strong><code>mMutexFeatures</code></strong>: 保护与特征和观测相关的成员变量，如 <code>mObservations</code>, <code>mDescriptor</code>, <code>mpRefKF</code>, <code>mnVisible</code>, <code>mnFound</code>, <code>mbBad</code>, <code>mpReplaced</code>。</li><li><strong><code>mGlobalMutex</code> (静态成员)</strong>: 一个全局互斥锁，在 <code>SetWorldPos</code> 中被使用，可能用于某些更全局的同步操作，但其具体必要性需要结合上下文分析（在 ORB-SLAM2 中，一些静态全局锁的使用有时是为了简化设计，但也可能引入不必要的串行化）。</li><li><strong><code>mpMap-&gt;mMutexPointCreation</code></strong>: 在构造函数中，当分配新的 <code>mnId</code> 时，会使用所属地图 <code>mpMap</code> 的一个互斥锁 <code>mMutexPointCreation</code>，以确保 ID 分配的原子性。</li></ul><hr><p><strong>总结:</strong></p><p><code>MapPoint</code> 类是 ORB-SLAM2 中对三维空间点的抽象表示。它不仅仅是一个三维坐标，更是一个包含了丰富几何信息、观测历史、追踪状态和优化标记的复杂对象。理解 <code>MapPoint</code> 的这些属性和方法，对于深入理解 ORB-SLAM2 如何进行地图构建、追踪定位、闭环优化等核心流程至关重要。它就像是连接不同图像观测之间的桥梁，构成了整个 SLAM 系统所依赖的稀疏三维地图的基石。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—现代C++代码命名规范</title>
      <link href="/2025/05/05/c12/"/>
      <url>/2025/05/05/c12/</url>
      
        <content type="html"><![CDATA[<h2 id="命名规范总览"><a href="#命名规范总览" class="headerlink" title="命名规范总览"></a>命名规范总览</h2><table><thead><tr><th>类别</th><th>命名规则</th><th>示例</th></tr></thead><tbody><tr><td>函数名</td><td>小驼峰式 (camelCase)</td><td><code>calculateTotal()</code>, <code>getUserName()</code></td></tr><tr><td>变量名</td><td>小驼峰式 (camelCase)</td><td><code>userCount</code>, <code>totalAmount</code></td></tr><tr><td>参数名</td><td>小驼峰式 (camelCase)</td><td><code>inputValue</code>, <code>maxSize</code></td></tr><tr><td>成员变量</td><td>尾缀下划线或m_前缀</td><td><code>userName_</code>, <code>m_userName</code></td></tr><tr><td>类名</td><td>大驼峰式 (PascalCase)</td><td><code>UserAccount</code>, <code>DataProcessor</code></td></tr><tr><td>常量</td><td>全大写+下划线</td><td><code>MAX_BUFFER_SIZE</code>, <code>PI_VALUE</code></td></tr><tr><td>宏定义</td><td>全大写+下划线</td><td><code>DEBUG_MODE</code>, <code>SAFE_DELETE</code></td></tr></tbody></table><h2 id="详细规则及示例"><a href="#详细规则及示例" class="headerlink" title="详细规则及示例"></a>详细规则及示例</h2><h3 id="1-函数名-小驼峰式"><a href="#1-函数名-小驼峰式" class="headerlink" title="1. 函数名 (小驼峰式)"></a>1. 函数名 (小驼峰式)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculateTotal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">getUserName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setConfiguration</span><span class="params">(<span class="type">const</span> Config&amp; config)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-变量名-小驼峰式"><a href="#2-变量名-小驼峰式" class="headerlink" title="2. 变量名 (小驼峰式)"></a>2. 变量名 (小驼峰式)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> userCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> totalAmount = <span class="number">0.0</span>;</span><br><span class="line">std::string fullName;</span><br><span class="line"><span class="type">bool</span> isActive = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="3-参数名-小驼峰式"><a href="#3-参数名-小驼峰式" class="headerlink" title="3. 参数名 (小驼峰式)"></a>3. 参数名 (小驼峰式)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; inputData, <span class="type">int</span> maxItems)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setUserInfo</span><span class="params">(<span class="type">const</span> std::string&amp; userName, <span class="type">int</span> userAge, <span class="type">bool</span> isPremium)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-成员变量-尾缀下划线或m-前缀"><a href="#4-成员变量-尾缀下划线或m-前缀" class="headerlink" title="4. 成员变量 (尾缀下划线或m_前缀)"></a>4. 成员变量 (尾缀下划线或m_前缀)</h3><p>两种常见风格，选择一种并保持一致：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 风格1: 尾缀下划线</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">    <span class="type">bool</span> isActive_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 风格2: m_前缀</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">bool</span> m_isActive;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-类名-大驼峰式"><a href="#5-类名-大驼峰式" class="headerlink" title="5. 类名 (大驼峰式)"></a>5. 类名 (大驼峰式)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserAccount</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkConnection</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConfigOptions</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-常量-全大写-下划线"><a href="#6-常量-全大写-下划线" class="headerlink" title="6. 常量 (全大写+下划线)"></a>6. 常量 (全大写+下划线)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_USERS = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> PI_VALUE = <span class="number">3.14159265359</span>;</span><br><span class="line"><span class="type">const</span> std::string DEFAULT_CONFIG_PATH = <span class="string">&quot;/etc/app/config&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="7-宏定义-全大写-下划线"><a href="#7-宏定义-全大写-下划线" class="headerlink" title="7. 宏定义 (全大写+下划线)"></a>7. 宏定义 (全大写+下划线)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_MODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAFE_DELETE(ptr) <span class="keyword">if</span>(ptr) &#123; delete ptr; ptr = nullptr; &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(msg) std::cerr &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl</span></span><br></pre></td></tr></table></figure><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><p>下面是一个结合以上规则的完整示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_USERS = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> TAX_RATE = <span class="number">0.08</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAFE_DELETE(ptr) <span class="keyword">if</span>(ptr) &#123; delete ptr; ptr = nullptr; &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(msg) std::cout &lt;&lt; <span class="string">&quot;INFO: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserAccount</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">UserAccount</span>(<span class="type">const</span> std::string&amp; userName, <span class="type">int</span> userAge)</span><br><span class="line">        : <span class="built_in">name_</span>(userName), <span class="built_in">age_</span>(userAge), <span class="built_in">isActive_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">activateAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age_ &gt;= MIN_AGE) &#123;</span><br><span class="line">            isActive_ = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">getDisplayName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name_ + (isActive_ ? <span class="string">&quot; (Active)&quot;</span> : <span class="string">&quot; (Inactive)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateLastLoginTime</span><span class="params">(<span class="type">const</span> std::string&amp; loginTime)</span> </span>&#123;</span><br><span class="line">        lastLogin_ = loginTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员变量</span></span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">    <span class="type">bool</span> isActive_;</span><br><span class="line">    std::string lastLogin_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有常量</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> MIN_AGE = <span class="number">18</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processUserData</span><span class="params">(<span class="type">const</span> std::vector&lt;UserAccount&gt;&amp; userList, <span class="type">bool</span> includeInactive)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> activeCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; user : userList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (includeInactive || user.<span class="built_in">getDisplayName</span>().<span class="built_in">find</span>(<span class="string">&quot;Active&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(user.<span class="built_in">getDisplayName</span>());</span><br><span class="line">            activeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processed &quot;</span> &lt;&lt; activeCount &lt;&lt; <span class="string">&quot; users.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变量定义</span></span><br><span class="line">    std::vector&lt;UserAccount&gt; users;</span><br><span class="line">    <span class="type">int</span> totalUsers = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建用户</span></span><br><span class="line">    users.<span class="built_in">push_back</span>(<span class="built_in">UserAccount</span>(<span class="string">&quot;Alice Smith&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    users.<span class="built_in">push_back</span>(<span class="built_in">UserAccount</span>(<span class="string">&quot;Bob Johnson&quot;</span>, <span class="number">17</span>));</span><br><span class="line">    users.<span class="built_in">push_back</span>(<span class="built_in">UserAccount</span>(<span class="string">&quot;Carol Williams&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理用户</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; user : users) &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">activateAccount</span>()) &#123;</span><br><span class="line">            totalUsers++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    <span class="built_in">processUserData</span>(users, <span class="literal">true</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total active users: &quot;</span> &lt;&lt; totalUsers &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="额外建议"><a href="#额外建议" class="headerlink" title="额外建议"></a>额外建议</h2><ol><li><strong>保持一致性</strong>：选择一种风格后，在整个项目中保持一致。</li><li><strong>避免使用匈牙利命名法</strong>：现代C++不推荐使用类型前缀（如<code>iCount</code>、<code>strName</code>）。</li><li><strong>使用有意义的名称</strong>：避免使用单字母变量名（除了临时变量如循环索引）。</li><li><strong>使用现代C++特性</strong>：优先使用<code>constexpr</code>而非宏定义常量，使用<code>nullptr</code>而非<code>NULL</code>。</li><li><strong>注释规范</strong>：为类、函数和复杂逻辑添加适当的注释。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—指针和const</title>
      <link href="/2025/05/05/c11/"/>
      <url>/2025/05/05/c11/</url>
      
        <content type="html"><![CDATA[<h2 id="理解const与指针的规则"><a href="#理解const与指针的规则" class="headerlink" title="理解const与指针的规则"></a>理解const与指针的规则</h2><p>在C++中理解const与指针的组合，可以遵循两个简单规则：</p><ol><li><strong>星号(<code>*</code>)前的const</strong>：表示指针指向的内容不能修改</li><li><strong>星号(<code>*</code>)后的const</strong>：表示指针本身不能改变指向</li></ol><h2 id="详细分析各种情况"><a href="#详细分析各种情况" class="headerlink" title="详细分析各种情况"></a>详细分析各种情况</h2><h3 id="1-指向常量的指针"><a href="#1-指向常量的指针" class="headerlink" title="1. 指向常量的指针"></a>1. 指向常量的指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;value;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* p2 = &amp;value;  <span class="comment">// 与上面等价</span></span><br></pre></td></tr></table></figure><p>可以理解为const int 和 int const是同一种类型，创建了一个指针指向了这个类型</p><p>这两种写法完全等价，都表示：</p><ul><li><strong>类型</strong>：指向整型常量的指针</li><li><strong>限制</strong>：不能通过此指针修改所指向的值</li><li><strong>可以</strong>：改变指针指向的地址</li><li><strong>读法</strong>：”p1是一个指针，指向const int”</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;a;  <span class="comment">// p指向a</span></span><br><span class="line">*p = <span class="number">6</span>;  <span class="comment">// 错误！不能通过p修改a的值</span></span><br><span class="line">p = &amp;b;  <span class="comment">// 正确，p可以改变指向</span></span><br></pre></td></tr></table></figure><h3 id="2-常量指针"><a href="#2-常量指针" class="headerlink" title="2. 常量指针"></a>2. 常量指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p3 = &amp;value;</span><br></pre></td></tr></table></figure><ul><li><strong>类型</strong>：指向整型的常量指针</li><li><strong>限制</strong>：指针本身不能改变指向（必须始终指向初始化时的地址）</li><li><strong>可以</strong>：通过此指针修改所指向的值</li><li><strong>读法</strong>：”p3是一个const指针，指向int”</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;a;  <span class="comment">// p指向a</span></span><br><span class="line">*p = <span class="number">6</span>;  <span class="comment">// 正确，可以通过p修改a的值</span></span><br><span class="line">p = &amp;b;  <span class="comment">// 错误！p不能改变指向</span></span><br></pre></td></tr></table></figure><h3 id="3-指向常量的常量指针"><a href="#3-指向常量的常量指针" class="headerlink" title="3. 指向常量的常量指针"></a>3. 指向常量的常量指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p4 = &amp;value;</span><br></pre></td></tr></table></figure><ul><li><strong>类型</strong>：指向整型常量的常量指针</li><li><strong>限制</strong>：既不能通过此指针修改所指向的值，也不能改变指针的指向</li><li><strong>读法</strong>：”p4是一个const指针，指向const int”</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p = &amp;a;  <span class="comment">// p指向a</span></span><br><span class="line">*p = <span class="number">6</span>;  <span class="comment">// 错误！不能通过p修改a的值</span></span><br><span class="line">p = &amp;b;  <span class="comment">// 错误！p不能改变指向</span></span><br></pre></td></tr></table></figure><h2 id="简化记忆方法"><a href="#简化记忆方法" class="headerlink" title="简化记忆方法"></a>简化记忆方法</h2><p>一个简单的记忆技巧是从右向左读声明：</p><ol><li><code>const int* p</code> → “p是一个指针，指向const int”</li><li><code>int* const p</code> → “p是一个const指针，指向int”</li><li><code>const int* const p</code> → “p是一个const指针，指向const int”</li></ol><h2 id="图解不同情况"><a href="#图解不同情况" class="headerlink" title="图解不同情况"></a>图解不同情况</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const int* p;</span><br><span class="line">┌─────┐    ┌─────┐</span><br><span class="line">│  p  │───▶│ 数据 │  // p可以改变指向，但不能通过p修改数据</span><br><span class="line">└─────┘    └─────┘</span><br><span class="line"></span><br><span class="line">int* const p;</span><br><span class="line">┌─────┐    ┌─────┐</span><br><span class="line">│  p  │═══▶│ 数据 │  // p不能改变指向，但可以通过p修改数据</span><br><span class="line">└─────┘    └─────┘</span><br><span class="line"></span><br><span class="line">const int* const p;</span><br><span class="line">┌─────┐    ┌─────┐</span><br><span class="line">│  p  │═══▶│ 数据 │  // p不能改变指向，也不能通过p修改数据</span><br><span class="line">└─────┘    └─────┘</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>───▶</code> 表示可以改变的指向</li><li><code>═══▶</code> 表示不可改变的指向</li><li>数据是否可通过指针修改取决于是否有<code>const int</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>orbslam2</title>
      <link href="/2025/04/30/orbslam2/"/>
      <url>/2025/04/30/orbslam2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Docker-容器创建"><a href="#一、Docker-容器创建" class="headerlink" title="一、Docker 容器创建"></a>一、Docker 容器创建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -dit \</span><br><span class="line">--gpus all \</span><br><span class="line">-e NVIDIA_DRIVER_CAPABILITIES=all \</span><br><span class="line">--name=orbslam2 \</span><br><span class="line">--privileged  \</span><br><span class="line">-v /dev:/dev \</span><br><span class="line">-v /home/xfy/docker_practice/orbslam2Base20.04:/home/docker \</span><br><span class="line">-v /tmp/.X11-unix:/tmp/.X11-unix  \</span><br><span class="line">-e DISPLAY=unix<span class="variable">$DISPLAY</span> \</span><br><span class="line">-w /home \</span><br><span class="line">--net=host \</span><br><span class="line">ubuntu:20.04</span><br></pre></td></tr></table></figure><h2 id="二、Ubuntu-源配置"><a href="#二、Ubuntu-源配置" class="headerlink" title="二、Ubuntu 源配置"></a>二、Ubuntu 源配置</h2><ol><li><p>安装 vim</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install vim</span><br></pre></td></tr></table></figure></li><li><p>备份原始源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.backup</span><br></pre></td></tr></table></figure></li><li><p>编辑源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># gg dG 移动到文件第一行并删除所有内容</span></span><br><span class="line"><span class="comment"># i进入编辑模式</span></span><br><span class="line"><span class="comment"># 编辑完esc退出到普通模式，：进入命令行模式输入wq保存并退出</span></span><br></pre></td></tr></table></figure></li><li><p>替换为阿里云源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"># deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、安装基础开发工具"><a href="#三、安装基础开发工具" class="headerlink" title="三、安装基础开发工具"></a>三、安装基础开发工具</h2><ol><li><p>安装 build-essential</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install build-essential</span><br></pre></td></tr></table></figure></li><li><p>安装新版本的 git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install -y software-properties-common</span><br><span class="line">add-apt-repository -y ppa:git-core/ppa</span><br><span class="line">apt update</span><br><span class="line">apt install -y git</span><br></pre></td></tr></table></figure></li><li><p>安装新版本的 cmake</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install -y apt-transport-https ca-certificates gnupg wget</span><br><span class="line">wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2&gt;/dev/null | gpg --dearmor - | <span class="built_in">tee</span> /etc/apt/trusted.gpg.d/kitware.gpg &gt;/dev/null</span><br><span class="line">apt-add-repository <span class="string">&quot;deb https://apt.kitware.com/ubuntu/ <span class="subst">$(lsb_release -cs)</span> main&quot;</span></span><br><span class="line">apt update</span><br><span class="line"><span class="comment"># apt install -y cmake  # 这会安装4.*版本的cmake</span></span><br><span class="line">apt install cmake=3.29.6-*</span><br></pre></td></tr></table></figure></li></ol><h2 id="四、安装-ORB-SLAM2-所需第三方库"><a href="#四、安装-ORB-SLAM2-所需第三方库" class="headerlink" title="四、安装 ORB-SLAM2 所需第三方库"></a>四、安装 ORB-SLAM2 所需第三方库</h2><h3 id="1-安装-Pangolin-0-6"><a href="#1-安装-Pangolin-0-6" class="headerlink" title="1. 安装 Pangolin 0.6"></a>1. 安装 Pangolin 0.6</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 https://github.com/stevenlovegrove/Pangolin/releases 下载安装包</span></span><br><span class="line">tar -xzf Pangolin-0.6.tar.gz</span><br><span class="line"><span class="comment"># 安装 Pangolin 依赖</span></span><br><span class="line">apt install libgl1-mesa-dev</span><br><span class="line">apt install libglew-dev</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="2-安装-Eigen-3-3-8"><a href="#2-安装-Eigen-3-3-8" class="headerlink" title="2. 安装 Eigen 3.3.8"></a>2. 安装 Eigen 3.3.8</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf eigen-3.3.8.tar.gz</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make install</span><br><span class="line"><span class="comment"># eigen不需要执行make</span></span><br></pre></td></tr></table></figure><h3 id="3-安装-Boost"><a href="#3-安装-Boost" class="headerlink" title="3. 安装 Boost"></a>3. 安装 Boost</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install libboost-all-dev</span><br></pre></td></tr></table></figure><h3 id="4-安装-libssl-dev"><a href="#4-安装-libssl-dev" class="headerlink" title="4. 安装 libssl-dev"></a>4. 安装 libssl-dev</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install libssl-dev</span><br></pre></td></tr></table></figure><h3 id="5-安装-OpenCV-4-6"><a href="#5-安装-OpenCV-4-6" class="headerlink" title="5. 安装 OpenCV 4.6"></a>5. 安装 OpenCV 4.6</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 OpenCV 依赖</span></span><br><span class="line">apt install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg-dev libtiff5-dev libswscale-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 OpenCV</span></span><br><span class="line">apt install unzip</span><br><span class="line">unzip opencv-4.6.0.zip  <span class="comment"># 假设压缩包名称</span></span><br><span class="line"><span class="built_in">cd</span> opencv-4.6.0</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j6</span><br></pre></td></tr></table></figure><h2 id="五、克隆并编译-ORB-SLAM2"><a href="#五、克隆并编译-ORB-SLAM2" class="headerlink" title="五、克隆并编译 ORB-SLAM2"></a>五、克隆并编译 ORB-SLAM2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆有详细注释的版本</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/electech6/ORB_SLAM2_detailed_comments.git</span><br><span class="line"><span class="comment"># 把CMakeLists.txt 中的 OpenCV 依赖版本为 4，c++标准改为14</span></span><br></pre></td></tr></table></figure><h3 id="1-编译-DBoW2-ORB-SLAM2-自带-无需make-install"><a href="#1-编译-DBoW2-ORB-SLAM2-自带-无需make-install" class="headerlink" title="1. 编译 DBoW2 (ORB-SLAM2 自带)无需make install"></a>1. 编译 DBoW2 (ORB-SLAM2 自带)无需make install</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ORB_SLAM2_detailed_comments/Thirdparty/DBoW2</span><br><span class="line"><span class="comment"># 先修改 CMakeLists.txt 中的 OpenCV 依赖版本为 4</span></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="2-编译-g2o-ORB-SLAM2-自带-无需make-install"><a href="#2-编译-g2o-ORB-SLAM2-自带-无需make-install" class="headerlink" title="2. 编译 g2o (ORB-SLAM2 自带)无需make install"></a>2. 编译 g2o (ORB-SLAM2 自带)无需make install</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ORB_SLAM2_detailed_comments/Thirdparty/g2o</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h2 id="六、常见问题及解决方案"><a href="#六、常见问题及解决方案" class="headerlink" title="六、常见问题及解决方案"></a>六、常见问题及解决方案</h2><h3 id="问题1-opencv-cv-h-头文件缺失"><a href="#问题1-opencv-cv-h-头文件缺失" class="headerlink" title="问题1: opencv&#x2F;cv.h 头文件缺失"></a>问题1: opencv&#x2F;cv.h 头文件缺失</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: opencv/cv.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>: 修改 ORBextractor.h</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将</span></span><br><span class="line"><span class="comment">#include &lt;opencv/cv.h&gt;</span></span><br><span class="line"><span class="comment"># 换成</span></span><br><span class="line"><span class="comment">#include &lt;opencv2/imgproc/imgproc_c.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;opencv2/highgui/highgui_c.h&gt;</span></span><br></pre></td></tr></table></figure><h3 id="问题2-std-map-类型错误"><a href="#问题2-std-map-类型错误" class="headerlink" title="问题2: std::map 类型错误"></a>问题2: std::map 类型错误</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/c++/9/bits/stl_map.h:122:71: error: static assertion failed: std::map must have the same value_type as its allocator</span><br><span class="line">static_assert(is_same&lt;typename _Alloc::value_type, value_type&gt;::value,</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>: 修改 LoopClosing.h 第49行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将</span></span><br><span class="line">typedef map&lt;KeyFrame*,g2o::Sim3,std::less&lt;KeyFrame*&gt;,</span><br><span class="line">    Eigen::aligned_allocator&lt;std::pair&lt;const KeyFrame*, g2o::Sim3&gt; &gt; &gt; KeyFrameAndPose;</span><br><span class="line"><span class="comment"># 改成</span></span><br><span class="line">typedef map&lt;KeyFrame*,g2o::Sim3,std::less&lt;KeyFrame*&gt;,</span><br><span class="line">    Eigen::aligned_allocator&lt;std::pair&lt;KeyFrame* const, g2o::Sim3&gt; &gt; &gt; KeyFrameAndPose;</span><br></pre></td></tr></table></figure><h3 id="问题3-5-CV-LOAD-IMAGE-UNCHANGED-未定义"><a href="#问题3-5-CV-LOAD-IMAGE-UNCHANGED-未定义" class="headerlink" title="问题3-5: CV_LOAD_IMAGE_UNCHANGED 未定义"></a>问题3-5: CV_LOAD_IMAGE_UNCHANGED 未定义</h3><p><strong>解决方法</strong>: 在相关文件中替换 OpenCV 常量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有 CV_LOAD_IMAGE_UNCHANGED 替换为 cv::IMREAD_UNCHANGED</span></span><br><span class="line"><span class="comment"># 需要修改的文件包括：</span></span><br><span class="line"><span class="comment"># - tum.cc</span></span><br><span class="line"><span class="comment"># - stereo_kitti.cc</span></span><br><span class="line"><span class="comment"># - stereo_euroc.cc</span></span><br><span class="line"><span class="comment"># 以及其他类似文件</span></span><br></pre></td></tr></table></figure><h2 id="七、测试安装结果"><a href="#七、测试安装结果" class="headerlink" title="七、测试安装结果"></a>七、测试安装结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压词汇表</span></span><br><span class="line"><span class="built_in">cd</span> ORB_SLAM2_detailed_comments/Vocabulary</span><br><span class="line">tar -xzf ORBvoc.txt.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 TUM 数据集，从官网下载并使用 associate.py 生成 associate.txt 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行测试</span></span><br><span class="line">/home/orbslam/ORB_SLAM2_detailed_comments/Examples/RGB-D/rgbd_tum \</span><br><span class="line">/home/orbslam/ORB_SLAM2_detailed_comments/Vocabulary/ORBvoc.txt \</span><br><span class="line">/home/orbslam/ORB_SLAM2_detailed_comments/Examples/RGB-D/TUM3.yaml \</span><br><span class="line">/home/docker/rgbd_dataset_freiburg3_sitting_static \</span><br><span class="line">/home/docker/rgbd_dataset_freiburg3_sitting_static/associate.txt</span><br></pre></td></tr></table></figure><p>如果运行成功，说明 ORB-SLAM2 安装配置已完成。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令</title>
      <link href="/2025/04/30/docker2/"/>
      <url>/2025/04/30/docker2/</url>
      
        <content type="html"><![CDATA[<h3 id="镜像管理-Image-Management"><a href="#镜像管理-Image-Management" class="headerlink" title="镜像管理 (Image Management)"></a>镜像管理 (Image Management)</h3><ul><li><code>docker image ls</code> &#x2F; <code>docker images</code>: 查看镜像</li><li><code>docker search [image]</code>: 检索镜像<ul><li><code>eg. docker search nginx</code></li></ul></li><li><code>docker pull [image]</code>: 拉取镜像</li><li><code>docker push [image]</code>: 上传镜像<ul><li><code>eg. docker push geekhour/hello-docker:latest</code></li></ul></li><li><code>docker save [image] -o FILE</code> &#x2F; <code>docker save [image] &gt; FILE</code>: 保存镜像<ul><li><code>eg. docker save geekhour/hello-docker:latest &gt; hello-docker.tar</code></li></ul></li><li><code>docker load -i FILE</code>: 导入镜像<ul><li><code>eg. docker load -i hello-docker.tar</code></li></ul></li><li><code>docker history [image]</code>: 查看镜像历史</li><li><code>docker rmi [image]</code> &#x2F; <code>docker image rm [image]</code>: 删除镜像</li><li><code>docker image prune</code>: 删除不再使用的镜像</li><li><code>docker import [URL/FILE]</code>: 将文件系统导入为镜像</li><li><code>docker commit [container] [image]</code>: 从容器创建镜像</li></ul><h3 id="容器管理-Container-Management"><a href="#容器管理-Container-Management" class="headerlink" title="容器管理 (Container Management)"></a>容器管理 (Container Management)</h3><ul><li><code>docker create [image]</code>: 创建容器 (仅创建, 不运行)</li><li><code>docker run [image]</code>: 创建并运行容器</li><li><code>docker start [container]</code>: 启动容器</li><li><code>docker stop [container]</code>: 停止容器</li><li><code>docker restart [container]</code>: 重启容器</li><li><code>docker ps</code> &#x2F; <code>docker container ls</code>: 列出正在运行的容器</li><li><code>docker ps -a</code> &#x2F; <code>docker container ls -a</code>: 列出所有容器</li><li><code>docker exec -it [container] bash</code> &#x2F; <code>docker attach [container]</code>: 以交互模式进入容器</li><li><code>docker export [container] -o FILE</code> &#x2F; <code>docker export [container] &gt; FILE</code>: 导出容器</li><li><code>docker import FILE</code>: 导入容器快照</li><li><code>docker logs [container]</code>: 查看容器日志</li><li><code>docker rm [container]</code> &#x2F; <code>docker container rm [container]</code>: 删除容器</li><li><code>docker port [container]</code>: 查看容器端口映射</li><li><code>docker top [container]</code>: 显示容器内进程</li><li><code>docker cp [FILE] [container]:[PATH]</code>: 复制本地文件到容器内的指定路径</li><li><code>docker diff [container]</code>: 显示容器内的变化</li><li><code>docker stats [container]</code>: 显示容器资源使用情况</li></ul><h3 id="容器运行-Container-Run"><a href="#容器运行-Container-Run" class="headerlink" title="容器运行 (Container Run)"></a>容器运行 (Container Run)</h3><ul><li><strong>语法格式</strong>: <code>docker run [options] image [command] [arg...]</code></li><li><code>docker run --name [name] [image]</code>: 创建运行并命名容器</li><li><code>docker run -d [image]</code>: 创建一个容器并后台运行</li><li><code>docker run -p [hostPort]:[containerPort] [image]</code>: 创建一个容器并指定端口映射</li><li><code>docker run -P [image]</code>: 创建一个容器并指定端口映射 (随机分配)</li><li><code>docker run -e [key=value] [image]</code>: 创建一个容器并指定环境变量</li><li><code>docker run -w [PATH] [image]</code>: 创建一个容器并指定工作目录</li><li><code>docker run [image] [command]</code>: 创建一个容器并在容器中执行命令 (交互模式)</li><li><code>docker run -d -p [hostPort]:[containerPort] -e [key=value] -w [PATH] --name [name] [image]</code>: 创建一个容器, 并指定容器名称、后台运行、端口映射、环境变量和工作目录<ul><li><code>eg. docker run -it nginx:latest /bin/bash</code>: 使用镜像 nginx:latest 来启动一个容器, 并在容器内执行交互式 bash shell</li><li><code>eg. docker run -it -p 3316:3306 -v /data:/data -d mysql:latest</code>: 创建一个 mysql 容器, 后台模式启动, 主机 3316 端口映射到容器 3306 端口, 主机 &#x2F;data 目录映射到容器 &#x2F;data 目录</li></ul></li></ul><h3 id="网络管理-Network-Management"><a href="#网络管理-Network-Management" class="headerlink" title="网络管理 (Network Management)"></a>网络管理 (Network Management)</h3><ul><li><code>docker network ls</code>: 列出可用网络</li><li><code>docker network inspect [network]</code>: 查看网络详细信息</li><li><code>docker network create [network]</code>: 创建一个新的网络</li><li><code>docker network rm [network]</code>: 删除一个网络</li><li><code>docker network connect [network] [container]</code>: 将容器连接到网络</li><li><code>docker network disconnect [network] [container]</code>: 将容器从网络断开</li></ul><h3 id="数据卷管理-Volume-Management"><a href="#数据卷管理-Volume-Management" class="headerlink" title="数据卷管理 (Volume Management)"></a>数据卷管理 (Volume Management)</h3><ul><li><code>docker volume create [volume]</code>: 创建一个数据卷</li><li><code>docker volume ls</code>: 查看数据卷</li><li><code>docker volume inspect [volume]</code>: 查看数据卷详细信息</li><li><code>docker volume rm [volume]</code>: 删除数据卷</li><li><code>docker volume prune</code>: 删除所有未使用的数据卷</li></ul><h3 id="插件管理-Plugin-Management"><a href="#插件管理-Plugin-Management" class="headerlink" title="插件管理 (Plugin Management)"></a>插件管理 (Plugin Management)</h3><ul><li><code>docker plugin ls</code>: 列出插件</li><li><code>docker plugin install [plugin]</code>: 安装插件</li><li><code>docker plugin enable [plugin]</code>: 启用插件</li><li><code>docker plugin disable [plugin]</code>: 禁用插件</li><li><code>docker plugin rm [plugin]</code>: 卸载插件</li></ul><h3 id="日常操作-Daily-Operations"><a href="#日常操作-Daily-Operations" class="headerlink" title="日常操作 (Daily Operations)"></a>日常操作 (Daily Operations)</h3><ul><li><code>docker info</code>: 查看 docker 系统信息</li><li><code>docker version</code>: 查看 Docker 版本</li><li><code>docker --help</code>: 查看 Docker 帮助文档</li><li><code>docker [command] --help</code>: 查看 Docker 命令帮助</li><li><code>docker login/logout</code>: 登录&#x2F;退出 DockerHub</li></ul><h3 id="常用-Dockerfile-指令-Common-Dockerfile-Instructions"><a href="#常用-Dockerfile-指令-Common-Dockerfile-Instructions" class="headerlink" title="常用 Dockerfile 指令 (Common Dockerfile Instructions)"></a>常用 Dockerfile 指令 (Common Dockerfile Instructions)</h3><ul><li><strong><code>FROM [base_image]</code></strong>: 指定基础镜像, 必须为 Dockerfile 的第一条指令。</li><li><strong><code>ADD</code></strong>: 用于将文件复制到镜像中, 源可以是 URL 或者本地文件, 也可以是一个压缩文件 (自动解压)。</li><li><strong><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [源路径] [目标路径]</code></strong>: 用于将文件拷贝到镜像中, 源只能是本地文件。</li><li><strong><code>WORKDIR [PATH]</code></strong>: 用于指定工作目录, 可以使用多个 WORKDIR 指令, 如果使用相对路径, 则是相对于上一条 WORKDIR 指令所指定的目录。</li><li><strong><code>ENV &lt;key&gt; &lt;value&gt;</code> &#x2F; <code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></strong>: 用于设置环境变量。</li><li><strong><code>CMD &lt;命令&gt;</code> &#x2F; <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></strong>: 用于指定默认的容器主进程, 每个 Dockerfile 中只能有一条 CMD 指令, 如果有多条, 则只有最后一条会生效。</li><li><strong><code>VOLUME &lt;路径&gt;</code> &#x2F; <code>VOLUME [&quot;路径1&quot;, &quot;路径2&quot;...]</code></strong>: 用于定义匿名卷 (持久化目录)。</li></ul><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2025/04/29/docker/"/>
      <url>/2025/04/29/docker/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>1. 拉取镜像 (docker pull)</strong></p><ul><li><strong>作用:</strong> 从镜像仓库 (默认是 Docker Hub) 下载镜像到你的本地机器。</li><li><strong>语法:</strong> <code>docker pull &lt;仓库名&gt;/&lt;镜像名&gt;:&lt;标签&gt;</code><ul><li><code>&lt;仓库名&gt;</code>: 可选，如果是 Docker Hub 上的官方镜像或知名镜像，通常可以省略。如果是个人或其他组织的镜像，需要指定，例如 <code>osrf/ros</code>。</li><li><code>&lt;镜像名&gt;</code>: 必须，例如 <code>ubuntu</code>, <code>ros</code>。</li><li><code>&lt;标签&gt;</code>: 可选，用于指定镜像的版本。如果不指定，默认拉取 <code>latest</code> 标签。<strong>强烈建议总是指定明确的标签</strong>，以保证环境的可复现性。例如 <code>ubuntu:22.04</code>, <code>ros:noetic-ros-base</code>。</li></ul></li><li><strong>示例:</strong><ul><li><p>拉取官方的 Ubuntu 22.04 镜像：你会看到 Docker 开始下载镜像的各个层 (layer)。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:22.04</span><br></pre></td></tr></table></figure></li><li><p>拉取 ROS Noetic 的基础镜像 (来自 Open Source Robotics Foundation)：(这个镜像会大一些，因为它包含了 ROS Noetic 的核心组件)</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ros:noetic-ros-base</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>2. 查看本地镜像 (docker images)</strong></p><ul><li><p><strong>作用:</strong> 列出你本地已经下载的所有镜像。</p></li><li><p><strong>语法:</strong> <code>docker images</code></p></li><li><p><strong>示例:</strong> 你会看到类似以下的输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG               IMAGE ID       CREATED        SIZE</span><br><span class="line">ubuntu              22.04             xxxxxxxxxxxx   xx weeks ago   77.8MB</span><br><span class="line">ros                 noetic-ros-base   yyyyyyyyyyyy   xx weeks ago   1.07GB</span><br><span class="line">hello-world         latest            zzzzzzzzzzzz   xx months ago  13.3kB</span><br></pre></td></tr></table></figure><ul><li><code>REPOSITORY</code>: 镜像所在的仓库名。</li><li><code>TAG</code>: 镜像的标签 (版本)。</li><li><code>IMAGE ID</code>: 镜像的唯一标识符。</li><li><code>CREATED</code>: 镜像创建的时间。</li><li><code>SIZE</code>: 镜像的大小。</li></ul></li></ul><p><strong>3. 运行容器 (docker run)</strong></p><ul><li><p><strong>作用:</strong> 使用指定的镜像创建一个新的容器并运行它。这是 Docker 最核心的命令之一。</p></li><li><p><strong>语法:</strong> <code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p></li><li><p><strong>常用选项 (OPTIONS):</strong></p><p>  以下这些选项非常关键：</p><ol><li><p><strong><code>-it</code> (交互式 TTY)</strong></p><ul><li><p><code>-i</code> (<code>--interactive</code>): 保持标准输入（STDIN）打开，即使没有附加连接。简单说，允许你向容器输入命令。</p></li><li><p><code>-t</code> (<code>--tty</code>): 分配一个伪终端（pseudo-TTY）。这会模拟一个真实的终端，让你可以像在普通 Linux Shell 里一样交互，比如使用 Tab 补全、看到命令提示符等。</p></li><li><p><strong>为什么重要？</strong> 你通常需要进入容器的 Shell 环境进行编译、运行节点、调试等操作，<code>-it</code> 几乎是必备组合。</p></li><li><p><strong>示例:</strong> 这个命令会启动一个基于 <code>ubuntu:20.04</code> 镜像的容器，并直接进入容器的 <code>bash</code> Shell。你可以像在普通的 Ubuntu 终端里一样操作。退出 Shell（输入 <code>exit</code> 或按 <code>Ctrl+D</code>）后，容器通常会停止。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:20.04 bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>--rm</code> (自动移除)</strong></p><ul><li><p>当容器退出时，自动删除容器文件系统。</p></li><li><p><strong>为什么重要？</strong> 每次 <code>docker run</code> 都会创建一个新的容器。如果你只是临时运行一个命令或者进入 Shell 调试，用完就扔，<code>--rm</code> 可以避免产生大量无用的、停止状态的容器，保持 Docker 环境整洁。对于调试和测试非常方便。</p></li><li><p><strong>示例:</strong> 当你退出这个 <code>bash</code> 后，这个容器会被彻底删除，<code>docker ps -a</code> 也看不到它了。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> ubuntu:20.04 bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>-d</code> (<code>--detach</code>) (后台运行)</strong></p><ul><li><p>让容器在后台运行，并打印出容器 ID。</p></li><li><p><strong>为什么重要？</strong> 有时候你希望容器作为一个服务在后台持续运行（比如运行一个 ROS Master 或者一个模拟器），而不是占用你的当前终端。</p></li><li><p><strong>注意:</strong> 如果使用 <code>-d</code>，通常容器需要运行一个长期在前台执行的进程（比如一个 web 服务、一个 <code>sleep infinity</code> 或者 ROS 节点），否则容器一启动执行完默认命令（如果该命令会结束）就会立刻退出。</p></li><li><p><strong>示例:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个后台运行的容器，里面无限睡眠 (常用于创建一个长期运行的基础容器)</span></span><br><span class="line">docker run -d --name my_background_ubuntu ubuntu:20.04 <span class="built_in">sleep</span> infinity</span><br><span class="line"><span class="comment"># 你可以使用 docker exec 进入这个后台运行的容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it my_background_ubuntu bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>--name &lt;container_name&gt;</code> (指定名称)</strong></p><ul><li><p>给容器指定一个易于记忆的名字。如果不指定，Docker 会随机生成一个（比如 <code>vigilant_mclean</code>）。</p></li><li><p><strong>为什么重要？</strong> 有了名字，你可以方便地通过名字来管理容器，比如 <code>docker stop my_slam_container</code>、<code>docker start my_slam_container</code>、<code>docker exec -it my_slam_container bash</code> 等。</p></li><li><p><strong>示例:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> --name slam_dev_session ubuntu:20.04 bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>-v</code> 或 <code>--volume</code> (挂载卷)</strong> &#x2F; <code>--mount</code> (更推荐的挂载方式)</p><ul><li><p>将宿主机（你的 Ubuntu 22.04）的目录或文件挂载到容器内部。这是<strong>实现代码&#x2F;数据共享和持久化的关键</strong>。</p></li><li><p><strong>为什么对 SLAM 重要？</strong></p><ul><li><strong>代码开发:</strong> 你可以在宿主机上用你喜欢的 IDE 编辑代码，然后在容器里编译和运行，代码是实时同步的。</li><li><strong>数据集:</strong> SLAM 数据集通常很大，你不需要把它们复制到镜像里，直接挂载宿主机上的数据集目录即可。</li><li><strong>结果保存:</strong> 容器运行产生的结果（地图、轨迹、日志）可以保存到挂载的宿主机目录，容器删除后结果依然存在。</li></ul></li><li><p><strong>语法 (<code>-v</code>)</strong>: <code>-v &lt;host_path&gt;:&lt;container_path&gt;[:options]</code></p></li><li><p><strong>语法 (<code>--mount</code>)</strong>: <code>--mount type=bind,source=&lt;host_path&gt;,target=&lt;container_path&gt;[,readonly]</code> (bind mount 是最常用的类型，效果类似 <code>-v</code>)</p></li><li><p><strong>示例 (使用 <code>-v</code>)</strong>:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将宿主机的 ~/slam_ws 目录挂载到容器内的 /root/slam_ws 目录</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> -v ~/slam_ws:/root/slam_ws ubuntu:20.04 bash</span><br><span class="line"><span class="comment"># 进入容器后，你在 /root/slam_ws 看到的就是宿主机 ~/slam_ws 的内容</span></span><br><span class="line"><span class="comment"># 在容器内修改 /root/slam_ws/some_file.txt，宿主机的 ~/slam_ws/some_file.txt 也会同步改变</span></span><br></pre></td></tr></table></figure></li><li><p><strong>示例 (使用 <code>--mount</code>)</strong>:<code>--mount</code> 语法更清晰，推荐使用。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=~/slam_ws,target=/root/slam_ws ubuntu:20.04 bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>-p</code> 或 <code>--publish</code> (端口映射)</strong></p><ul><li><p>将容器的端口映射到宿主机的端口。格式：<code>-p &lt;host_port&gt;:&lt;container_port&gt;</code>。</p></li><li><p><strong>为什么对 SLAM 重要？</strong> 如果你在容器里运行了需要网络访问的服务（比如 RViz 的 Web 版本、或者某些算法的监控界面），需要将容器端口暴露给宿主机或其他机器。</p></li><li><p><strong>示例:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设容器内 8080 端口运行了一个 web 服务</span></span><br><span class="line">docker run -d -p 8888:8080 my_web_service_image</span><br><span class="line"><span class="comment"># 现在你可以通过访问宿主机的 8888 端口 (http://localhost:8888) 来访问容器内的 8080 服务</span></span><br></pre></td></tr></table></figure></li><li><p><strong>对于 ROS:</strong> 很多时候直接使用 <code>--net=host</code> (见下一点) 更方便，避免复杂的端口映射。</p></li></ul></li><li><p><strong><code>--net</code> 或 <code>--network</code> (网络模式)</strong></p><ul><li><p>配置容器的网络连接方式。常用模式：</p><ul><li><code>bridge</code> (默认): 容器有自己独立的网络栈，通过 Docker 网桥连接宿主机。需要端口映射 (<code>p</code>) 才能从外部访问容器服务。</li><li><code>host</code>: 容器共享宿主机的网络栈。容器直接使用宿主机的 IP 地址和端口，无需端口映射。性能最好，但隔离性差。</li><li><code>none</code>: 容器没有网络连接。</li></ul></li><li><p><strong>为什么 <code>host</code> 对 SLAM&#x2F;ROS 重要？</strong> ROS 节点间通信、RViz 连接 ROS Master、与连接到宿主机的传感器（如网络摄像头）通信等，使用 <code>--net=host</code> 可以极大简化网络配置，让容器内的 ROS 环境像直接在宿主机运行一样方便。</p></li><li><p><strong>示例:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 host 网络模式运行容器</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --net=host ubuntu:20.04 bash</span><br><span class="line"><span class="comment"># 在容器内运行 ifconfig，你会看到宿主机的网络接口</span></span><br><span class="line"><span class="comment"># 在容器内运行的 ROS 节点可以直接与宿主机或其他局域网内的 ROS 节点通信</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>-e</code> 或 <code>--env</code> (环境变量)</strong></p><ul><li><p>设置容器内的环境变量。格式：<code>-e KEY=VALUE</code>。</p></li><li><p><strong>为什么对 SLAM 重要？</strong></p><ul><li><strong>ROS 配置:</strong> 设置 <code>ROS_MASTER_URI</code>, <code>ROS_IP</code>, <code>ROS_HOSTNAME</code> 等。</li><li><strong>显示转发 (X11 Forwarding):</strong> 让容器内的 GUI 程序（如 RViz, Gazebo, rqt_plot）能显示在宿主机的屏幕上。通常需要设置 <code>DISPLAY</code> 环境变量。</li></ul></li><li><p>**示例 (X11 Forwarding):**<em>注意:</em> X11 Forwarding 配置有时比较棘手，可能因系统而异。<code>-net=host</code> 通常能简化这个问题。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在宿主机先执行 xhost +local:docker (允许本地 docker 容器连接 X server)</span></span><br><span class="line">xhost +<span class="built_in">local</span>:docker</span><br><span class="line"><span class="comment"># 运行容器时传递 DISPLAY 环境变量，并挂载 X11 socket</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> \</span><br><span class="line">       -e DISPLAY=<span class="variable">$DISPLAY</span> \</span><br><span class="line">       -v /tmp/.X11-unix:/tmp/.X11-unix \</span><br><span class="line">       --net=host \</span><br><span class="line">       ubuntu:20.04 bash</span><br><span class="line"><span class="comment"># 在容器内安装并运行一个简单的 GUI 程序试试，比如 xeyes (apt update &amp;&amp; apt install -y x11-apps &amp;&amp; xeyes)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>--device</code> (挂载设备)</strong></p><ul><li><p>将宿主机的设备文件挂载到容器内。</p></li><li><p><strong>为什么对 SLAM 重要？</strong> SLAM 严重依赖传感器！你需要让容器访问连接到宿主机的摄像头、IMU、LiDAR 等设备。</p></li><li><p>**示例:**<em>注意:</em> 确保运行 Docker 的用户在宿主机上对这些设备文件有读写权限（通常需要将用户添加到 <code>video</code>, <code>dialout</code> 等用户组）。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载第一个 USB 摄像头 (/dev/video0)</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --device=/dev/video0 ubuntu:20.04 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载串口设备 (例如 IMU)</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --device=/dev/ttyUSB0 ubuntu:20.04 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载多个设备</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --device=/dev/video0 --device=/dev/ttyUSB0 ubuntu:20.04 bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>--gpus</code> (GPU 支持)</strong></p><ul><li>允许容器访问宿主机的 NVIDIA GPU。这对需要 CUDA 加速的 SLAM 算法（如基于深度学习的特征提取、GPU 加速的优化）至关重要。</li><li><strong>前提:</strong> 宿主机需要安装 NVIDIA 驱动和 <code>nvidia-docker2</code> (或称为 NVIDIA Container Toolkit)。</li><li><strong>示例:</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许容器访问所有可用的 GPU</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --gpus all nvidia/cuda:11.4.0-base-ubuntu20.04 nvidia-smi</span><br><span class="line"><span class="comment"># 上例使用了 NVIDIA 官方提供的包含 CUDA 的基础镜像，并运行 nvidia-smi 检查 GPU 是否可用</span></span><br><span class="line"><span class="comment"># 你也可以在你自己的 ubuntu:20.04 镜像基础上，在容器内安装 CUDA Toolkit，然后用 --gpus all 启动</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --gpus all ubuntu:20.04 bash</span><br><span class="line"><span class="comment"># (进入容器后需要自行安装 CUDA 和相关驱动)</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><strong>4. 查看容器 (docker ps)</strong></p><ul><li><strong>作用:</strong> 列出正在运行的容器。</li><li><strong>语法:</strong> <code>docker ps</code></li><li><strong>查看所有容器 (包括已停止的):</strong><ul><li><strong>语法:</strong> <code>docker ps -a</code></li></ul></li></ul><p><strong>5. 进入正在运行的容器 (docker exec)</strong></p><ul><li><strong>作用:</strong> 在一个已经在后台运行的容器内部执行命令。</li><li><strong>语法:</strong> <code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></li><li><strong>常用选项:</strong><ul><li><code>-i</code>, <code>-t</code>: 与 <code>docker run</code> 中的含义相同，通常一起使用 (<code>-it</code>) 来获取交互式 Shell。</li></ul></li><li><strong>示例:</strong><ul><li><p>进入我们之前后台运行的 <code>my-nginx</code> 容器，并启动一个 bash shell:执行后你将进入 <code>my-nginx</code> 容器的 Shell。输入 <code>exit</code> 退出该 Shell，但容器本身仍在后台运行。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it my-nginx bash</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>6. 管理容器 (停止、启动、删除)</strong></p><ul><li><strong>停止容器:</strong><ul><li><strong>语法:</strong> <code>docker stop &lt;容器ID或名称&gt;</code></li><li><strong>示例:</strong> <code>docker stop my-nginx</code></li></ul></li><li><strong>启动已停止的容器:</strong><ul><li><strong>语法:</strong> <code>docker start &lt;容器ID或名称&gt;</code></li><li><strong>示例:</strong> <code>docker start my-nginx</code> (容器会继续在后台运行)</li></ul></li><li><strong>删除容器:</strong><ul><li><strong>注意:</strong> 只能删除已停止的容器。</li><li><strong>语法:</strong> <code>docker rm &lt;容器ID或名称&gt;</code></li><li><strong>示例:</strong> (先停止) <code>docker stop my-nginx</code> (再删除) <code>docker rm my-nginx</code></li><li><strong>强制删除运行中的容器 (不推荐，除非你知道后果):</strong> <code>docker rm -f &lt;容器ID或名称&gt;</code></li></ul></li><li><strong>清理所有已停止的容器:</strong><ul><li><strong>语法:</strong> <code>docker container prune</code> (会提示确认)</li></ul></li></ul><p><strong>7. 删除镜像 (docker rmi)</strong></p><ul><li><strong>作用:</strong> 删除本地的一个或多个镜像。</li><li><strong>注意:</strong> 如果有容器 (即使是已停止的) 正在使用该镜像，需要先删除这些容器才能删除镜像。</li><li><strong>语法:</strong> <code>docker rmi &lt;镜像ID或仓库名:标签&gt;</code></li><li><strong>示例:</strong><ul><li>删除 <code>hello-world</code> 镜像: <code>docker rmi hello-world:latest</code></li><li>删除 <code>ubuntu:22.04</code> 镜像 (如果之前没有基于它创建并保留的容器): <code>docker rmi ubuntu:22.04</code></li></ul></li><li><strong>清理悬空镜像 (dangling images):</strong> 这些是没有标签且没有被任何容器使用的镜像层，通常是构建过程中产生的中间层或旧版本。<ul><li><strong>语法:</strong> <code>docker image prune</code></li></ul></li></ul><h2 id="我自己的实例"><a href="#我自己的实例" class="headerlink" title="我自己的实例"></a>我自己的实例</h2><h3 id="1-需要用gpu的话先配置gpu"><a href="#1-需要用gpu的话先配置gpu" class="headerlink" title="1. 需要用gpu的话先配置gpu"></a>1. 需要用gpu的话先配置gpu</h3><p><a href="https://blog.csdn.net/GritYearner/article/details/133679403">https://blog.csdn.net/GritYearner/article/details/133679403</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | <span class="built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \</span><br><span class="line">  &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">    sed <span class="string">&#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27;</span> | \</span><br><span class="line">    <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list \</span><br><span class="line">  &amp;&amp; \</span><br><span class="line">    <span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y nvidia-docker2</span><br><span class="line"><span class="built_in">sudo</span> nvidia-ctk runtime configure --runtime=docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line">测试</span><br><span class="line"><span class="built_in">sudo</span> docker run --<span class="built_in">rm</span> --gpus all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-利用鱼香ros的镜像启动一个容器"><a href="#2-利用鱼香ros的镜像启动一个容器" class="headerlink" title="2. 利用鱼香ros的镜像启动一个容器"></a>2. 利用鱼香ros的镜像启动一个容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -dit \</span><br><span class="line">--gpus all \</span><br><span class="line">-e NVIDIA_DRIVER_CAPABILITIES=all \</span><br><span class="line">--name=[your_container_name] \</span><br><span class="line">--privileged  \</span><br><span class="line">-v /dev:/dev \</span><br><span class="line">-v /home/[your_username]:/home/[your_username] \</span><br><span class="line">-v /tmp/.X11-unix:/tmp/.X11-unix  \</span><br><span class="line">-e DISPLAY=unix<span class="variable">$DISPLAY</span> \</span><br><span class="line">-w /home/[your_username] \</span><br><span class="line">--net=host \</span><br><span class="line">fishros2/ros:noetic-desktop-full </span><br></pre></td></tr></table></figure><p>这里注意不要直接使用鱼香的容器，他的默认的启动跟这个不太一样。启动时候的这些指令一旦运行，就不能再改了，最好是删除容器重新从镜像用正确指令生成一个容器，实在不想放弃这个容器的话就通过将这个容器生成为新的镜像，再从新镜像用正确指令生成容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器名 新镜像名:标签</span><br></pre></td></tr></table></figure><p>要使用图形界面需要在外面终端运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是鱼香ros默认运行的</span></span><br><span class="line">xhost +<span class="built_in">local</span>: &gt;&gt; /dev/null</span><br><span class="line"><span class="comment"># 这是gpt推荐的</span></span><br><span class="line">xhost +<span class="built_in">local</span>:docker</span><br></pre></td></tr></table></figure><h3 id="3-已经装好了ORB-SLAM3和ROS的镜像"><a href="#3-已经装好了ORB-SLAM3和ROS的镜像" class="headerlink" title="3. 已经装好了ORB-SLAM3和ROS的镜像"></a>3. 已经装好了ORB-SLAM3和ROS的镜像</h3><p>我通过之前的鱼香镜像生成容器配置好orbslam3自己做了一个镜像上传到了dockerhub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line">docker pull 用户名/仓库名:标签</span><br><span class="line"><span class="built_in">sudo</span> docker run -dit \</span><br><span class="line">--gpus all \</span><br><span class="line">-e NVIDIA_DRIVER_CAPABILITIES=all \</span><br><span class="line">--name=rosslam \</span><br><span class="line">--privileged  \</span><br><span class="line">-v /dev:/dev \</span><br><span class="line">-v /home/xfy/docker-ros:/home/rosslam/workspace \ //记得改这个挂载目录</span><br><span class="line">-v /tmp/.X11-unix:/tmp/.X11-unix  \</span><br><span class="line">-e DISPLAY=unix<span class="variable">$DISPLAY</span> \</span><br><span class="line">-w /home/rosslam \</span><br><span class="line">--net=host \</span><br><span class="line">xuefeiyang/fyslam:slam3WithRos</span><br></pre></td></tr></table></figure><ol><li><p><strong><code>sudo docker run</code></strong>:</p><ul><li><code>sudo</code>: 以超级用户（root）权限执行后面的命令。运行 Docker 命令，特别是涉及硬件访问（如 GPU、设备挂载 <code>/dev</code>）或修改网络设置（<code>--net=host</code>）时，通常需要 <code>sudo</code> 权限。</li><li><code>docker run</code>: 这是 Docker 的核心命令，用于根据指定的镜像创建一个新的容器并运行它。</li></ul></li><li><p><strong><code>-dit</code></strong>: 这是三个选项的缩写合并：</p><ul><li><code>-d</code> (<code>--detach</code>): 让容器在后台运行（Detached mode）。执行此命令后，你会立即返回到宿主机的终端提示符，而不是直接进入容器的 Shell。容器会在后台保持运行状态。这对于运行需要长时间提供服务的容器（如 ROS Master、模拟器）很有用。</li><li><code>-i</code> (<code>--interactive</code>): 保持标准输入（STDIN）对容器开放，即使没有连接到容器。这通常与 <code>-t</code> 一起使用，以便后续可以通过 <code>docker attach</code> 或 <code>docker exec</code> 进行交互。</li><li><code>-t</code> (<code>--tty</code>): 为容器分配一个伪终端（pseudo-TTY）。这使得你后续通过 <code>docker exec</code> 进入容器时，能获得一个类似真实终端的交互体验（例如，有命令提示符、支持 Tab 补全等）。</li><li><strong>组合效果</strong>: <code>-dit</code> 启动一个后台运行的容器，但保持其交互接口可用，方便你之后使用 <code>docker exec -it rosslam bash</code> 等命令进入容器内部进行操作。</li></ul></li><li><p><strong><code>--gpus all</code></strong>:</p><ul><li>允许这个容器访问宿主机上所有可用的 NVIDIA GPU。</li><li><strong>前提</strong>: 你的宿主机需要正确安装 NVIDIA 显卡驱动，并且安装了 NVIDIA Container Toolkit (nvidia-docker2)。</li><li><strong>用途</strong>: 对于需要 CUDA 进行加速的 SLAM 算法（例如，基于深度学习的特征提取、GPU 加速的后端优化、仿真渲染等）至关重要。</li></ul></li><li><p><strong><code>-e NVIDIA_DRIVER_CAPABILITIES=all</code></strong>:</p><ul><li><code>-e</code> (<code>--env</code>): 设置容器内部的环境变量。</li><li><code>NVIDIA_DRIVER_CAPABILITIES=all</code>: 这个特定的环境变量告诉 NVIDIA 驱动程序，允许容器使用驱动程序的所有功能（如图形、计算、工具、视频编解码等）。通常与 <code>--gpus</code> 选项配合使用，以确保容器内应用能充分利用 GPU 能力。</li></ul></li><li><p><strong><code>--name=rosslam</code></strong>:</p><ul><li>给这个新创建的容器指定一个名字，叫做 “rosslam”。</li><li><strong>好处</strong>: 你可以使用这个名字来方便地管理容器，例如 <code>docker stop rosslam</code>、<code>docker start rosslam</code>、<code>docker logs rosslam</code>、<code>docker exec -it rosslam bash</code> 等，而不需要记住 Docker 自动生成的长 ID。</li></ul></li><li><p><strong><code>--privileged</code></strong>:</p><ul><li>赋予这个容器扩展的权限。这基本上禁用了容器和宿主机之间的大部分安全隔离机制。</li><li><strong>效果</strong>: 容器几乎拥有与宿主机上 root 用户相同的权限，可以访问宿主机的所有设备（<code>/dev</code> 下的所有内容），修改内核参数等。</li><li><strong>使用场景</strong>: 通常是为了确保容器能够无障碍地访问各种硬件设备（摄像头、IMU、LiDAR 等），尤其是在 <code>-v /dev:/dev</code> 挂载了整个设备目录的情况下，确保权限足够。</li><li><strong>注意</strong>: 这是一个强大的选项，但<strong>有安全风险</strong>。如果可能，优先考虑使用更精细的 <code>--device</code> 选项来只挂载必要的设备，而不是使用 <code>--privileged</code>。但有时为了方便或解决特定权限问题会使用它。</li></ul></li><li><p><strong><code>-v /dev:/dev</code></strong>:</p><ul><li><code>-v</code> (<code>--volume</code>): 将宿主机的目录或文件挂载到容器内部。这里是挂载宿主机的 <code>/dev</code> 目录到容器的 <code>/dev</code> 目录。</li><li><strong>目的</strong>: 让容器可以直接访问宿主机上的所有硬件设备文件。这对于 SLAM 来说非常方便，因为你可以直接在容器内像在宿主机上一样使用 <code>/dev/video0</code>（摄像头）、<code>/dev/ttyUSB0</code>（串口设备如 IMU 或 LiDAR）等设备。</li><li><strong>与 <code>--privileged</code> 的关系</strong>: 这个挂载让容器 <em>看到</em> 设备文件，而 <code>--privileged</code> 通常用来确保容器 <em>有权限</em> 去操作这些设备文件。</li></ul></li><li><p><strong><code>-v /home/xfy/docker-ros:/home/rosslam/workspace</code></strong>:</p><ul><li>这是另一个卷挂载。</li><li><code>宿主机路径</code>: <code>/home/xfy/docker-ros</code> （<strong>这是你宿主机上的一个具体目录，其他人使用时需要修改成他们自己的路径！</strong>）</li><li><code>容器内路径</code>: <code>/home/rosslam/workspace</code></li><li><strong>目的</strong>: 这是实现代码和数据共享的关键。你在宿主机的 <code>/home/xfy/docker-ros</code> 目录下修改代码、存放数据，这些内容会实时同步到容器内的 <code>/home/rosslam/workspace</code> 目录，反之亦然。这样你可以在宿主机使用你喜欢的编辑器，而在容器内编译和运行。容器删除后，这个目录下的工作成果依然保存在宿主机上。</li></ul></li><li><p><strong><code>-v /tmp/.X11-unix:/tmp/.X11-unix</code></strong>:</p><ul><li>挂载宿主机的 X11 Unix Domain Socket 目录到容器内部对应的位置。</li><li><strong>目的</strong>: 这是实现 X11 转发（让容器内的 GUI 程序显示在宿主机屏幕上）的关键步骤之一。GUI 程序通过这个 Socket 与宿主机的 X Server 通信。</li></ul></li><li><p><strong><code>-e DISPLAY=unix$DISPLAY</code></strong>:</p><ul><li>设置容器内的 <code>DISPLAY</code> 环境变量。</li><li><code>$DISPLAY</code>: 这会取用你<strong>当前宿主机</strong>的 <code>DISPLAY</code> 环境变量的值（通常是 <code>:0</code> 或 <code>:1</code> 等）。</li><li><code>unix</code>: 有时会加上这个前缀，但很多时候直接 <code>-e DISPLAY=$DISPLAY</code> 也能工作。</li><li><strong>目的</strong>: 告诉容器内的 GUI 应用程序应该将图形界面发送到哪个显示服务器（即你的宿主机屏幕）。需要与上一步的 X11 Socket 挂载配合使用。</li><li><strong>前提</strong>: 在运行这个 <code>docker run</code> 命令之前，你可能需要在宿主机上执行 <code>xhost +local:docker</code> （或者更安全的特定容器授权命令）来允许来自 Docker 容器的 X11 连接。</li></ul></li><li><p><strong><code>-w /home/rosslam</code></strong>:</p><ul><li><code>-w</code> (<code>--workdir</code>): 指定容器启动后的默认工作目录。</li><li><strong>效果</strong>: 当你使用 <code>docker exec -it rosslam bash</code> 进入容器时，你的 Shell 会话将直接从容器内的 <code>/home/rosslam</code> 目录开始，而不是默认的根目录 <code>/</code>。这通常是为了方便，让你直接进入项目相关的主目录。</li></ul></li><li><p><strong><code>--net=host</code></strong>:</p><ul><li>让容器共享宿主机的网络命名空间（Network Namespace）。</li><li><strong>效果</strong>: 容器不会获得自己独立的 IP 地址，而是直接使用宿主机的网络接口和 IP 地址。容器内监听的端口会直接暴露在宿主机的对应端口上，无需使用 <code>-p</code> 进行端口映射。</li><li><strong>对 ROS&#x2F;SLAM 的好处</strong>: 极大地简化了网络配置。容器内的 ROS 节点可以像在宿主机上运行一样，轻松地被局域网内（包括宿主机）的其他 ROS 节点发现和通信（例如 RViz 连接容器内的 ROS Master）。也方便访问连接到宿主机的网络摄像头等设备。</li><li><strong>缺点</strong>: 降低了网络隔离性。</li></ul></li><li><p><strong><code>xuefeiyang/fyslam:slam3WithRos</code></strong>:</p><ul><li>这是用来创建容器的<strong>镜像</strong>（Image）。</li><li><code>xuefeiyang/fyslam</code>: 镜像的仓库名&#x2F;用户名和镜像名，这看起来是一个用户（xuefeiyang）构建并可能分享在 Docker Hub 或私有仓库的自定义镜像。</li><li><code>slam3WithRos</code>: 镜像的标签（Tag），通常表示镜像的版本或者配置。这个名字暗示了这个镜像里面很可能已经预装了 ROS (Robot Operating System) 和一些 SLAM 相关的库或工具。</li></ul></li></ol><p><strong>总结</strong></p><p>这个命令启动了一个名为 <code>rosslam</code> 的后台容器，该容器基于 <code>xuefeiyang/fyslam:slam3WithRos</code> 镜像。它被赋予了很高的权限 (<code>--privileged</code>)，可以直接访问宿主机的所有 GPU (<code>--gpus all</code>) 和所有设备 (<code>-v /dev:/dev</code>)，并且共享宿主机的网络 (<code>--net=host</code>)。它还设置了 GUI 转发 (<code>-v /tmp/.X11-unix</code>, <code>-e DISPLAY</code>)，并将宿主机的 <code>/home/xfy/docker-ros</code> 目录映射到容器的 <code>/home/rosslam/workspace</code> 以共享工作文件。容器启动后的默认工作目录是 <code>/home/rosslam</code>。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—g2o库—ICP</title>
      <link href="/2025/04/29/c10/"/>
      <url>/2025/04/29/c10/</url>
      
        <content type="html"><![CDATA[<p>这个例子解决的是一个常见的 3D 重建或配准问题：我们有两组对应的三维点云（或者说，已知点之间的匹配关系），并且已经有了一个初始的、可能不太精确的相对位姿估计（旋转 R 和平移 t），我们希望通过优化来获得一个更精确的相对位姿。</p><p><strong>与 Bundle Adjustment 的关键区别：</strong></p><ul><li>BA 通常处理的是 3D 点到 2D 图像点的投影关系。</li><li>这个例子处理的是 <strong>3D 点到 3D 点</strong> 的直接变换关系。</li><li>这个特定的例子<strong>只优化位姿</strong>，而<strong>不优化三维点的坐标</strong> (尽管也可以扩展为同时优化点坐标)。</li></ul><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>假设我们有两组三维点：</p><ul><li><code>pts1</code>: 第一组三维点的坐标（在坐标系 1 中）。</li><li><code>pts2</code>: 第二组三维点的坐标（在坐标系 2 中）。</li></ul><p>我们知道 <code>pts1[i]</code> 和 <code>pts2[i]</code> 是<strong>对应</strong>的点。我们还有一个从坐标系 2 变换到坐标系 1 的初始位姿估计 $T_{12} &#x3D; (R, t)$。</p><p>目标是：<strong>优化位姿 $T_{12}$</strong>，使得将 <code>pts2</code> 中的每个点 $\mathbf{p}_{2,i}$ 通过优化后的位姿 $T_{12}$ 变换到坐标系 1 后，得到的结果 $T_{12} \mathbf{p}_{2,i}$ 与其对应的点 $\mathbf{p}_{1,i}$ 之间的<strong>距离（误差）</strong> 的总和最小。</p><p>误差项可以定义为： $\mathbf{e}_i &#x3D; \mathbf{p}_{1,i} - T_{12} \mathbf{p}_{2,i}$</p><p>我们要最小化 $\sum_i ||\mathbf{e}_i||^2$。</p><h3 id="2-思考过程：如何用图优化解决？"><a href="#2-思考过程：如何用图优化解决？" class="headerlink" title="2. 思考过程：如何用图优化解决？"></a>2. 思考过程：如何用图优化解决？</h3><ul><li><p><strong>顶点 (Vertex) 代表什么？</strong></p><ul><li>未知变量是待优化的相对位姿 $T_{12}$。</li><li><strong>因此，我们将 $T_{12}$ 定义为一个 <code>g2o::VertexSE3Expmap</code> 顶点。</strong> 只需要一个顶点。</li></ul></li><li><p><strong>边 (Edge) 代表什么？</strong></p><ul><li>约束来自于每一对匹配点 $(\mathbf{p}_{1,i}, \mathbf{p}_{2,i})$。</li><li>每一对点都要求：变换后的点 $T_{12} \mathbf{p}_{2,i}$ 应该接近目标点 $\mathbf{p}_{1,i}$。</li><li><strong>因此，每一对匹配点 $(\mathbf{p}_{1,i}, \mathbf{p}_{2,i})$ 都对应图中的一条边。</strong> 这条边衡量了 $\mathbf{p}_{1,i}$ 和 $T_{12} \mathbf{p}_{2,i}$ 之间的三维向量误差。</li></ul></li><li><p><strong>顶点和边如何连接？</strong></p><ul><li>计算第 $i$ 对点的误差 $\mathbf{e}_i &#x3D; \mathbf{p}_{1,i} - T_{12} \mathbf{p}_{2,i}$ 时，我们只用到<strong>一个</strong>待优化的变量——位姿 $T_{12}$。点 $\mathbf{p}_{1,i}$ 和 $\mathbf{p}_{2,i}$ 的坐标在这个例子中是<strong>固定</strong>的。</li><li><strong>因此，每条边只连接到那个唯一的位姿顶点上，是 一元边 (Unary Edge)。</strong></li></ul></li><li><p><strong>点坐标如何处理？</strong></p><ul><li>$\mathbf{p}_{1,i}$：可以看作是这条边的 <strong>测量值 (Measurement)</strong>，即我们期望变换后的点应该到达的目标位置。</li><li>$\mathbf{p}_{2,i}$：它是计算误差时需要用到的<strong>固定数据</strong>，它不是测量值，也不是待优化变量。它需要与边实例关联起来。</li></ul></li></ul><p><strong>总结思路：</strong> 创建一个图，包含：</p><ul><li>1 个 <code>VertexSE3Expmap</code> 顶点 (表示待优化的位姿 $T_{12}$)。</li><li>N 条 <strong>自定义的一元边</strong> (每条边对应一对匹配点 $(\mathbf{p}_{1,i}, \mathbf{p}_{2,i})$)。<ul><li>每条边存储 $\mathbf{p}_{2,i}$ 作为固定数据。</li><li>每条边以 $\mathbf{p}_{1,i}$ 作为测量值。</li><li>每条边计算误差 $\mathbf{e}_i &#x3D; \mathbf{p}_{1,i} - T_{12} \mathbf{p}_{2,i}$。<br>让 g2o 优化这个图，调整位姿顶点的值，使得所有边的误差平方和（考虑信息矩阵）最小。</li></ul></li></ul><h3 id="3-g2o-实现步骤"><a href="#3-g2o-实现步骤" class="headerlink" title="3. g2o 实现步骤"></a>3. g2o 实现步骤</h3><p><strong>3.1 自定义边的类型 (<code>EdgeProjectXYZRGBDPoseOnly</code>)</strong></p><ul><li><strong>原因:</strong> g2o 没有预定义完全符合 $\mathbf{e}_i &#x3D; \mathbf{p}_{1,i} - T \mathbf{p}_{2,i}$ 这种形式误差的一元边。我们需要自己创建一个。</li><li><strong>实现:</strong><ul><li><strong>继承:</strong> <code>g2o::BaseUnaryEdge&lt;D, E, VertexType&gt;</code>。<ul><li><code>D</code> (误差维度): 误差是 3D 向量差，<code>D = 3</code>。</li><li><code>E</code> (测量值类型): 测量值是目标点 $\mathbf{p}_{1,i}$，类型为 <code>Eigen::Vector3d</code>。</li><li><code>VertexType</code>: 连接的顶点是位姿，类型为 <code>g2o::VertexSE3Expmap</code>。</li><li>所以继承 <code>g2o::BaseUnaryEdge&lt;3, Eigen::Vector3d, g2o::VertexSE3Expmap&gt;</code>。</li></ul></li><li><strong>构造函数:</strong> 需要传入并存储固定的点坐标 $\mathbf{p}_{2,i}$。代码中将其命名为 <code>_point</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EdgeProjectXYZRGBDPoseOnly</span>(<span class="type">const</span> Eigen::Vector3d&amp; point) : _point(point) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><strong>重写 <code>computeError()</code>:</strong><ol><li>获取位姿顶点 <code>pose = _vertices[0]</code>。</li><li>获取当前位姿估计 <code>T = pose-&gt;estimate()</code>。</li><li>使用当前位姿 T 变换存储的固定点 <code>_point</code> (即 $\mathbf{p}_{2,i}$): <code>transformed_point = T.map(_point)</code>。</li><li>计算误差：<code>_error = _measurement - transformed_point</code>。其中 <code>_measurement</code> 存储的是目标点 $\mathbf{p}_{1,i}$。</li></ol></li><li><strong>重写 <code>linearizeOplus()</code> (计算雅可比):</strong><ol><li>获取当前位姿 <code>T</code> 和变换后的点 <code>xyz_trans = T.map(_point)</code>。</li><li>计算误差 $\mathbf{e} &#x3D; \mathbf{p}_1 - T \mathbf{p}_2$ 对位姿顶点（在 se(3) 李代数上的 6D 扰动 $\delta \boldsymbol{\xi} &#x3D; (\delta \omega_x, \delta \omega_y, \delta \omega_z, \delta t_x, \delta t_y, \delta t_z)^T$）的雅可比矩阵 $\frac{\partial \mathbf{e}}{\partial \delta \boldsymbol{\xi}}$。</li><li>根据链式法则和 SE(3) 的性质，可以推导出（假设扰动是左乘的）：<br>$$\frac{\partial \mathbf{e}}{\partial \delta \boldsymbol{\xi}} &#x3D; - \frac{\partial (T \mathbf{p}_2)}{\partial \delta \boldsymbol{\xi}} &#x3D; - \begin{pmatrix} -[\mathbf{p}’]_\times &amp; \mathbf{I} \end{pmatrix} &#x3D; \begin{pmatrix} [\mathbf{p}’]_\times &amp; -\mathbf{I} \end{pmatrix}$$<br>其中 $\mathbf{p}’ &#x3D; T \mathbf{p}_2 &#x3D; \text{xyz_trans}$。</li><li>将这个 3x6 的雅可比矩阵赋值给 <code>_jacobianOplusXi</code> (因为是一元边，只有 Xi)。代码中直接给出了展开形式。</li></ol></li><li><code>read</code>&#x2F;<code>write</code> 函数在此例中留空。</li></ul></li></ul><p><strong>3.2 顶点类型</strong></p><ul><li>使用 g2o 预定义的 <code>g2o::VertexSE3Expmap</code> 来表示待优化的位姿。</li></ul><p><strong>3.3 配置优化器</strong></p><ul><li>与 BA 示例类似，配置 <code>BlockSolver</code> (这里用了 <code>BlockSolverTraits&lt;6, 3&gt;</code>)、<code>LinearSolverCSparse</code> 和 <code>OptimizationAlgorithmLevenberg</code>。</li><li>创建 <code>SparseOptimizer</code> 并设置算法和 <code>verbose</code>。</li></ul><p><strong>3.4 构建图</strong></p><ul><li><strong>添加顶点:</strong><ol><li>创建 <code>VertexSE3Expmap</code> 对象。</li><li>设置 ID (0)。</li><li>设置<strong>初始位姿估计</strong> (<code>setEstimate</code>)。注意：代码中给了单位阵和零向量作为初始值，但在实际应用中，应该传入通过其他方法（如 RANSAC+SVD 或 粗略 ICP）得到的初始 R 和 t。</li><li>添加到优化器。</li></ol></li><li><strong>添加边:</strong><ol><li>遍历所有匹配点对 (<code>pts1[i]</code>, <code>pts2[i]</code>)。</li><li>创建自定义的 <code>EdgeProjectXYZRGBDPoseOnly</code> 对象，<strong>将 <code>pts2[i]</code> (转换成 <code>Eigen::Vector3d</code>) 传入构造函数</strong>。</li><li>设置边的唯一 ID (从 1 开始)。</li><li><strong>连接到顶点:</strong> <code>edge-&gt;setVertex(0, pose)</code>，连接到唯一的位姿顶点。</li><li><strong>设置测量值:</strong> <code>edge-&gt;setMeasurement(...)</code>，传入目标点 <code>pts1[i]</code> (转换成 <code>Eigen::Vector3d</code>)。</li><li><strong>设置信息矩阵:</strong> <code>edge-&gt;setInformation(Eigen::Matrix3d::Identity() * 1e4)</code>。这里使用了单位矩阵乘以一个较大的数 <code>1e4</code>。这意味着我们对所有的点对匹配给予了<strong>很高的信任度（权重）</strong>，假设它们的误差都应该很小。在实际应用中，可以根据匹配质量或点的不确定性来设置不同的信息矩阵。</li><li>添加到优化器。</li></ol></li></ul><p><strong>3.5 执行优化</strong></p><ul><li>调用 <code>optimizer.initializeOptimization()</code>。</li><li>调用 <code>optimizer.optimize(num_iterations)</code> (代码中是 10 次)。</li></ul><p><strong>3.6 获取结果</strong></p><ul><li>从位姿顶点 <code>pose</code> 获取优化后的估计值 <code>pose-&gt;estimate()</code>。</li><li>将其转换为 <code>Eigen::Isometry3d</code> 并输出变换矩阵。</li></ul><h3 id="4-准备工作"><a href="#4-准备工作" class="headerlink" title="4. 准备工作"></a>4. 准备工作</h3><ul><li><strong>包含头文件:</strong> g2o 核心库、求解器、算法、<code>VertexSE3Expmap</code>、<code>BaseUnaryEdge</code>、Eigen 等。</li><li><strong>准备输入数据:</strong><ul><li><code>std::vector&lt;cv::Point3f&gt; pts1</code>: 目标点云坐标。</li><li><code>std::vector&lt;cv::Point3f&gt; pts2</code>: 源点云坐标（待变换的点）。<strong>注意 <code>pts1</code> 和 <code>pts2</code> 必须是严格对应的</strong>。</li><li><code>cv::Mat R</code>, <code>cv::Mat t</code>: 初始的位姿估计（尽管代码中 <code>bundleAdjustment</code> 函数内部没有使用传入的 R, t 来设置初始值，而是用了单位阵，但在实际调用时应该用它们来设置 <code>pose-&gt;setEstimate</code>）。</li></ul></li><li><strong>数据类型转换:</strong> 将 <code>cv::Point3f</code> 转换为 <code>Eigen::Vector3d</code>。</li></ul><h3 id="5-关键代码片段-带注释"><a href="#5-关键代码片段-带注释" class="headerlink" title="5. 关键代码片段 (带注释)"></a>5. 关键代码片段 (带注释)</h3><pre><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;// Eigen 核心库#include &lt;Eigen/Core&gt;#include &lt;Eigen/Geometry&gt;// g2o 核心库#include &lt;g2o/core/sparse_optimizer.h&gt;#include &lt;g2o/core/block_solver.h&gt;#include &lt;g2o/core/optimization_algorithm_levenberg.h&gt;#include &lt;g2o/core/base_vertex.h&gt;#include &lt;g2o/core/base_unary_edge.h&gt; // 一元边基类// g2o 线性求解器#include &lt;g2o/solvers/csparse/linear_solver_csparse.h&gt;// g2o 类型定义#include &lt;g2o/types/slam3d/vertex_se3_expmap.h&gt; // VertexSE3Expmap#include &lt;g2o/types/slam3d/se3quat.h&gt;          // SE3Quat// OpenCV (仅用于数据结构 Point3f, Mat)#include &lt;opencv2/core/core.hpp&gt;using namespace std;using namespace g2o;// --- 1. 自定义边：用于 3D-3D 点对的位姿优化 ---// 模板参数：误差维度 D=3, 测量值类型 E=Eigen::Vector3d, 连接顶点类型 VertexSE3Expmapclass EdgeProjectXYZRGBDPoseOnly : public BaseUnaryEdge&lt;3, Eigen::Vector3d, VertexSE3Expmap&gt; &#123;public:    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;    // 构造函数：传入需要被变换的点 p2 的坐标    EdgeProjectXYZRGBDPoseOnly(const Eigen::Vector3d &amp;point) : _point(point) &#123;&#125;    // 读写函数 (本例忽略)    virtual bool read(istream &amp;in) override &#123; return false; &#125;    virtual bool write(ostream &amp;out) const override &#123; return false; &#125;    // 计算误差函数： error = p1 - T * p2    virtual void computeError() override &#123;        // 获取连接的位姿顶点        const VertexSE3Expmap *pose = static_cast&lt;const VertexSE3Expmap *&gt;(_vertices[0]);        // 计算变换后的点 T * p2 (其中 p2 是存储在 _point 中的)        Eigen::Vector3d transformed_point = pose-&gt;estimate().map(_point);        // 计算误差 error = measurement - transformed_point (measurement 是 p1)        _error = _measurement - transformed_point;    &#125;    // 计算雅可比矩阵： d(error) / d(delta_xi) = [p&#39;]_x, -I    virtual void linearizeOplus() override &#123;        VertexSE3Expmap *pose = static_cast&lt;VertexSE3Expmap *&gt;(_vertices[0]);        SE3Quat T(pose-&gt;estimate());        // 计算变换后的点 p&#39; = T * p2        Eigen::Vector3d xyz_trans = T.map(_point);        double x = xyz_trans[0];        double y = xyz_trans[1];        double z = xyz_trans[2];        // 雅可比矩阵 _jacobianOplusXi (3x6)        // 对应扰动 delta_xi = (omega_x, omega_y, omega_z, v_x, v_y, v_z)        // J = [ [p&#39;]_x   -I ]        _jacobianOplusXi(0, 0) = 0;    // d(error_x)/d(omega_x)        _jacobianOplusXi(0, 1) = -z;   // d(error_x)/d(omega_y)        _jacobianOplusXi(0, 2) = y;    // d(error_x)/d(omega_z)        _jacobianOplusXi(0, 3) = -1;   // d(error_x)/d(v_x)        _jacobianOplusXi(0, 4) = 0;    // d(error_x)/d(v_y)        _jacobianOplusXi(0, 5) = 0;    // d(error_x)/d(v_z)        _jacobianOplusXi(1, 0) = z;    // d(error_y)/d(omega_x)        _jacobianOplusXi(1, 1) = 0;    // d(error_y)/d(omega_y)        _jacobianOplusXi(1, 2) = -x;   // d(error_y)/d(omega_z)        _jacobianOplusXi(1, 3) = 0;    // d(error_y)/d(v_x)        _jacobianOplusXi(1, 4) = -1;   // d(error_y)/d(v_y)        _jacobianOplusXi(1, 5) = 0;    // d(error_y)/d(v_z)        _jacobianOplusXi(2, 0) = -y;   // d(error_z)/d(omega_x)        _jacobianOplusXi(2, 1) = x;    // d(error_z)/d(omega_y)        _jacobianOplusXi(2, 2) = 0;    // d(error_z)/d(omega_z)        _jacobianOplusXi(2, 3) = 0;    // d(error_z)/d(v_x)        _jacobianOplusXi(2, 4) = 0;    // d(error_z)/d(v_y)        _jacobianOplusXi(2, 5) = -1;   // d(error_z)/d(v_z)    &#125;protected:    Eigen::Vector3d _point; // 存储需要被变换的点 p2 的坐标&#125;;// --- 2. BA 函数主体 (ICP 位姿精化) ---void bundleAdjustment(    const std::vector&lt;cv::Point3f&gt; &amp;pts1, // 目标点云 (坐标系 1)    const std::vector&lt;cv::Point3f&gt; &amp;pts2, // 源点云 (坐标系 2)    cv::Mat &amp;R, cv::Mat &amp;t) &#123;             // 初始/优化后的位姿 (R, t 从系统 2 到系统 1)    // --- 配置 g2o 优化器 (与之前类似) ---    typedef BlockSolver&lt;BlockSolverTraits&lt;6, 3&gt;&gt; BlockSolverType;    typedef LinearSolverCSparse&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType;    auto linearSolver = std::make_unique&lt;LinearSolverType&gt;();    auto blockSolver = std::make_unique&lt;BlockSolverType&gt;(std::move(linearSolver));    OptimizationAlgorithmLevenberg *algorithm = new OptimizationAlgorithmLevenberg(std::move(blockSolver));    SparseOptimizer optimizer;    optimizer.setAlgorithm(algorithm);    optimizer.setVerbose(true);    // --- 添加顶点 (只有一个位姿顶点) ---    VertexSE3Expmap *pose = new VertexSE3Expmap();    pose-&gt;setId(0);    // **注意:** 这里设置了单位阵初始值，实际应用中应使用传入的 R, t    // Eigen::Matrix3d R_mat; // ... 从 cv::Mat R 转换 ...    // Eigen::Vector3d t_vec; // ... 从 cv::Mat t 转换 ...    // pose-&gt;setEstimate(SE3Quat(R_mat, t_vec));    pose-&gt;setEstimate(SE3Quat(Eigen::Matrix3d::Identity(), Eigen::Vector3d(0, 0, 0))); // 示例中使用单位阵    optimizer.addVertex(pose);    // --- 添加边 (每个点对一条边) ---    int index = 1; // 边 ID 从 1 开始    for (size_t i = 0; i &lt; pts1.size(); i++) &#123;        // 创建自定义边，传入需要变换的点 pts2[i]        EdgeProjectXYZRGBDPoseOnly *edge = new EdgeProjectXYZRGBDPoseOnly(            Eigen::Vector3d(pts2[i].x, pts2[i].y, pts2[i].z));        edge-&gt;setId(index);        // 连接到唯一的位姿顶点 (ID=0)        edge-&gt;setVertex(0, pose); // dynamic_cast 在这里可能更安全，但如果确定类型可以省略        // 设置测量值 (目标点 pts1[i])        edge-&gt;setMeasurement(Eigen::Vector3d(pts1[i].x, pts1[i].y, pts1[i].z));        // 设置信息矩阵 (权重)        // 使用单位阵乘以较大的系数，表示对匹配点对的信任度高        edge-&gt;setInformation(Eigen::Matrix3d::Identity() * 1e4);        optimizer.addEdge(edge);        index++;    &#125;    // --- 执行优化 ---    cout &lt;&lt; &quot;Starting optimization...&quot; &lt;&lt; endl;    optimizer.initializeOptimization();    optimizer.optimize(10); // 执行 10 次迭代    // --- 输出结果 ---    cout &lt;&lt; &quot;Optimization finished.&quot; &lt;&lt; endl;    SE3Quat optimized_pose = pose-&gt;estimate();    cout &lt;&lt; &quot;Optimized Transformation Matrix (T_1_2): &quot; &lt;&lt; endl &lt;&lt; Eigen::Isometry3d(optimized_pose).matrix() &lt;&lt; endl;    // (可选) 将优化后的 pose 更新回输入的 R, t&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—g2o库—BA</title>
      <link href="/2025/04/28/c9/"/>
      <url>/2025/04/28/c9/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>我们有一个相机，它在某个未知的位置和姿态（合称<strong>位姿</strong>）下拍摄了一张照片。我们知道：</p><ol><li>一些三维空间点的坐标 (<code>points_3d</code>)。</li><li>这些三维点在相机拍摄的照片上对应的二维像素坐标 (<code>points_2d</code>)。</li><li>相机的内部参数（焦距、主点），通常表示为一个<strong>内参矩阵 K</strong>。</li><li>相机位姿的一个<strong>初始估计值</strong>（旋转矩阵 <code>R</code> 和平移向量 <code>t</code>）。</li></ol><p>由于三维点坐标的测量、二维点观测以及初始位姿估计都可能存在误差，直接将三维点通过初始位姿和内参投影到图像平面，得到的二维坐标通常不会精确地等于观测到的二维坐标。</p><p><strong>目标：</strong> 同时<strong>优化调整</strong>相机的<strong>位姿 (R, t)</strong> 和 <strong>三维点的空间坐标 (<code>points_3d</code>)</strong>，使得所有三维点在优化后的位姿下，根据相机内参投影到图像平面上的<strong>重投影坐标</strong>与<strong>观测到的二维坐标 (<code>points_2d</code>)</strong> 之间的<strong>误差（重投影误差）</strong> 的总和最小。</p><p>这本质上是一个大规模的非线性最小二乘优化问题。</p><h3 id="2-思考过程：如何用图优化解决？"><a href="#2-思考过程：如何用图优化解决？" class="headerlink" title="2. 思考过程：如何用图优化解决？"></a>2. 思考过程：如何用图优化解决？</h3><p>我们将 BA 问题转化为 g2o 的图模型：</p><ul><li><p><strong>顶点 (Vertex) 代表什么？</strong></p><ul><li>顶点代表需要优化的未知变量。</li><li>在这个问题中，未知变量有两类：<ol><li><strong>相机的位姿 (Pose):</strong> 它有 6 个自由度（3 个旋转，3 个平移）。我们将用一个顶点来表示它。</li><li><strong>每个三维空间点的坐标 (3D Point):</strong> 每个点有 3 个自由度（x, y, z）。我们将为<strong>每一个</strong>三维点创建一个对应的顶点。</li></ol></li><li><strong>因此，图中将包含 1 个位姿顶点和 N 个三维点顶点 (N 是点的数量)。</strong></li></ul></li><li><p><strong>边 (Edge) 代表什么？</strong></p><ul><li>边代表变量之间的约束或测量误差。</li><li>我们的约束来自于观测：每个三维点 $P_i$ 在图像上被观测为一个二维点 $p_i$。这个观测关系同时关联了三维点 $P_i$ 的坐标和相机的位姿。</li><li><strong>因此，每一个观测 $(P_i, p_i)$ 都对应图中的一条边。</strong> 这条边表达的是：根据当前估计的相机位姿和当前估计的三维点 $P_i$ 坐标，计算出的 $P_i$ 的重投影坐标 $p’_{i}$，与实际观测到的 $p_i$ 之间的误差 $e_i = p_i - p’_{i}$。</li></ul></li><li><p><strong>顶点和边如何连接？</strong></p><ul><li>计算第 $i$ 个观测的重投影误差 $e_i$ 时，我们需要用到：<ol><li>相机的位姿（位姿顶点）。</li><li>第 $i$ 个三维点的坐标（第 $i$ 个点顶点）。</li><li>相机的内参 $K$（这个不是变量，而是已知参数）。</li></ol></li><li>这意味着每条边都需要连接<strong>一个位姿顶点</strong>和<strong>一个对应的三维点顶点</strong>。</li><li><strong>因此，这些边都是二元边 (Binary Edge)。</strong></li></ul></li><li><p><strong>相机内参 K 如何处理？</strong></p><ul><li>在这个例子中，相机内参 $K$ 是<strong>已知且固定</strong>的，我们<strong>不优化它</strong>。</li><li>但是，在计算重投影误差（边的工作）时又必须用到它。</li><li>g2o 提供了一种<strong>参数 (Parameter)</strong> 机制来处理这种情况。我们可以将相机内参封装成一个 <code>g2o::CameraParameters</code> 对象，并将其添加到优化器中。边在计算误差时可以访问这些参数。</li></ul></li></ul><p><strong>总结思路：</strong> 我们将创建一个图，包含：</p><ul><li>1 个 <code>VertexSE3Expmap</code> 类型的顶点（表示相机位姿）。</li><li>N 个 <code>VertexPointXYZ</code> 类型的顶点（表示 N 个三维点）。</li><li>1 个 <code>CameraParameters</code> 类型的参数（存储相机内参 K）。</li><li>N 条 <code>EdgeProjectXYZ2UV</code> 类型的二元边（每条边连接位姿顶点和一个点顶点，代表一个重投影误差约束，并关联相机参数）。<br>然后，让 g2o 优化这个图，调整所有顶点的值（位姿和点坐标），使得所有边的重投影误差平方和（考虑信息矩阵）最小。</li></ul><h3 id="3-g2o-实现步骤"><a href="#3-g2o-实现步骤" class="headerlink" title="3. g2o 实现步骤"></a>3. g2o 实现步骤</h3><p>根据 BA 的图优化思路，代码中执行了以下操作：</p><p><strong>3.1 定义&#x2F;选择顶点类型</strong></p><ul><li><strong>相机位姿顶点:</strong><ul><li>g2o 提供了预定义的 <code>g2o::VertexSE3Expmap</code>。</li><li>它内部使用 <code>SE3Quat</code> (包含 Eigen 的四元数和平移向量) 存储位姿估计值。</li><li>关键在于它的 <code>oplusImpl</code> 使用 <strong>李代数 se(3)</strong> 进行增量更新（通过指数映射），这对于表示旋转非常自然且避免了万向锁等问题。维度是 6。</li></ul></li><li><strong>三维点顶点:</strong><ul><li>g2o 提供了预定义的 <code>g2o::VertexPointXYZ</code>。</li><li>它内部使用 <code>Eigen::Vector3d</code> 存储点的 (x, y, z) 坐标。维度是 3。</li><li>它的 <code>oplusImpl</code> 是简单的向量加法。</li></ul></li></ul><p><strong>3.2 定义&#x2F;选择边类型</strong></p><ul><li><strong>重投影误差边:</strong><ul><li>g2o 提供了预定义的 <code>g2o::EdgeProjectXYZ2UV</code>。</li><li>它是一个二元边，模板参数为 <code>&lt;2, Eigen::Vector2d, g2o::VertexPointXYZ, g2o::VertexSE3Expmap&gt;</code>，表示：<ul><li>误差维度 <code>D=2</code> (误差是二维像素向量 $(u_{err}, v_{err})$)。</li><li>测量值类型 <code>E=Eigen::Vector2d</code> (存储观测到的像素坐标 $(u, v)$)。</li><li>连接的第一个顶点类型是 <code>VertexPointXYZ</code> (索引 0)。</li><li>连接的第二个顶点类型是 <code>VertexSE3Expmap</code> (索引 1)。</li></ul></li><li><strong>这个类内部已经实现了 <code>computeError()</code> 和 <code>linearizeOplus()</code>：</strong><ul><li><code>computeError()</code>: 获取位姿和点的当前估计值，获取相机参数，执行”世界坐标 -&gt; 相机坐标 -&gt; 像素坐标”的投影变换，计算预测像素坐标，然后用 <code>_measurement</code> (观测像素坐标) 减去预测坐标，得到 <code>_error</code>。</li><li><code>linearizeOplus()</code>: 计算 <code>_error</code> (2维) 相对于 <code>VertexPointXYZ</code> (3维) 的雅可比矩阵 (2x3) 和相对于 <code>VertexSE3Expmap</code> (6维李代数) 的雅可比矩阵 (2x6)。这是 BA 的核心数学推导，g2o 已经帮你做好了。</li></ul></li></ul></li></ul><p><strong>3.3 定义参数</strong></p><ul><li><strong>相机内参:</strong><ul><li>使用 <code>g2o::CameraParameters</code> 类。</li><li>需要用相机的焦距 $f_x$ (假设 $f_y&#x3D;f_x$) 和主点 $(c_x, c_y)$ 来构造它。</li><li>它需要设置一个 ID，并使用 <code>optimizer.addParameter()</code> 添加到优化器中。</li></ul></li></ul><p><strong>3.4 配置优化器</strong></p><ul><li><strong>目的:</strong> 设置求解策略。</li><li><strong>实现:</strong><ul><li><strong>块求解器:</strong> <code>BlockSolver&lt; BlockSolverTraits&lt;6, 3&gt; &gt;</code>。这里的 <code>&lt;6, 3&gt;</code> 通常与 BA 中涉及的主要变量维度（位姿 6D，点 3D）相关，尤其是在使用 Schur 消元时。</li><li><strong>线性求解器:</strong> <code>LinearSolverCSparse</code>。BA 问题通常规模较大但具有稀疏性（一个点只会被少数几个位姿看到），稀疏求解器是必要的。</li><li><strong>优化算法:</strong> <code>OptimizationAlgorithmLevenberg</code> (LM 算法) 是 BA 的常用选择，因为它结合了高斯牛顿法和梯度下降法的优点，比较鲁棒。</li><li><strong>创建 <code>SparseOptimizer</code></strong> 并设置算法和 <code>verbose</code> 模式。</li></ul></li></ul><p><strong>3.5 构建图</strong></p><ul><li><strong>目的:</strong> 将具体的顶点、边和参数加入优化器。</li><li><strong>实现:</strong><ul><li><strong>添加位姿顶点:</strong><ol><li>创建 <code>VertexSE3Expmap</code> 对象。</li><li>从输入的初始 <code>R</code> 和 <code>t</code> 创建 <code>g2o::SE3Quat</code> 对象，并用 <code>setEstimate()</code> 设置初始位姿。</li><li>设置 ID (例如 0)。</li><li>添加到优化器 <code>optimizer.addVertex()</code>。</li></ol></li><li><strong>添加三维点顶点:</strong><ol><li>遍历输入的 <code>points_3d</code>。</li><li>为每个点创建一个 <code>VertexPointXYZ</code> 对象。</li><li>用 <code>setEstimate()</code> 设置其初始坐标。</li><li>设置<strong>唯一</strong>的 ID (例如从 1 开始递增)。</li><li><strong><code>point-&gt;setMarginalized(true);</code></strong>: <strong>非常重要！</strong> 这告诉 g2o 在求解线性方程 $Hx &#x3D; -b$ 时，可以将这些点顶点对应的变量<strong>边缘化 (Marginalize Out)</strong>。这利用了 BA 问题的特殊结构（点只与少数位姿相关），通过 <strong>Schur 消元 (Schur Complement)</strong> 技巧，可以大大减小求解的线性系统的规模（只需求解与位姿相关的部分），从而显著提高效率。</li><li>添加到优化器 <code>optimizer.addVertex()</code>。</li></ol></li><li><strong>添加相机参数:</strong><ol><li>从内参矩阵 <code>K</code> 提取 $f_x, c_x, c_y$。</li><li>创建 <code>CameraParameters</code> 对象。</li><li>设置 ID (例如 0)。</li><li>添加到优化器 <code>optimizer.addParameter()</code>。</li></ol></li><li><strong>添加边:</strong><ol><li>遍历输入的 <code>points_2d</code> (需要与 <code>points_3d</code> 一一对应)。</li><li>为每个观测创建一个 <code>EdgeProjectXYZ2UV</code> 对象。</li><li>设置<strong>唯一</strong>的 ID (例如从 1 开始递增，与点 ID 对应)。</li><li><strong>连接顶点:</strong><ul><li><code>edge-&gt;setVertex(0, ...)</code> 连接到对应的<strong>点顶点</strong>。注意代码中使用了 <code>optimizer.vertex(index)</code> 通过 ID 获取顶点指针，并用 <code>dynamic_cast</code> 转换类型。</li><li><code>edge-&gt;setVertex(1, pose)</code> 连接到<strong>位姿顶点</strong>。</li></ul></li><li><strong>设置测量值:</strong> <code>edge-&gt;setMeasurement(Eigen::Vector2d(p.x, p.y))</code>，传入观测到的像素坐标。</li><li><strong>关联参数:</strong> <code>edge-&gt;setParameterId(0, 0)</code>。第一个 0 表示这是第 0 个参数集（CameraParameters），第二个 0 是该参数在优化器中的 ID。</li><li><strong>设置信息矩阵:</strong> <code>edge-&gt;setInformation(Eigen::Matrix2d::Identity())</code>。这里简单地使用了单位矩阵，表示假设所有像素观测的噪声是各向同性的，且方差为 1。在实际应用中，可以根据像素噪声的估计来设置更精确的信息矩阵（例如，$\frac{1}{\sigma^2} \mathbf{I}$，其中 $\sigma$ 是像素噪声标准差）。</li><li>添加到优化器 <code>optimizer.addEdge()</code>。</li></ol></li></ul></li></ul><p><strong>3.6 执行优化</strong></p><ul><li>调用 <code>optimizer.initializeOptimization()</code>。</li><li>调用 <code>optimizer.optimize(num_iterations)</code>。</li></ul><p><strong>3.7 获取结果</strong></p><ul><li>优化完成后，位姿顶点 <code>pose</code> 内部的 <code>_estimate</code> 已经被更新。</li><li>通过 <code>pose-&gt;estimate()</code> 获取优化后的 <code>g2o::SE3Quat</code>，可以将其转换回旋转矩阵 <code>R</code> 和平移向量 <code>t</code> (代码中直接输出了 <code>Isometry3d</code> 形式的变换矩阵)。</li><li>如果需要，也可以遍历所有点顶点，获取优化后的三维点坐标。</li></ul><h3 id="4-准备工作"><a href="#4-准备工作" class="headerlink" title="4. 准备工作"></a>4. 准备工作</h3><ul><li><strong>包含头文件:</strong> g2o 核心库、顶点类型 (<code>VertexSE3Expmap</code>, <code>VertexPointXYZ</code>)、边类型 (<code>EdgeProjectXYZ2UV</code>)、参数类型 (<code>CameraParameters</code>)、求解器、算法、Eigen 等。</li><li><strong>准备输入数据:</strong><ul><li><code>std::vector&lt;cv::Point3f&gt; points_3d</code>: 三维点坐标。</li><li><code>std::vector&lt;cv::Point2f&gt; points_2d</code>: 对应的二维观测点坐标。</li><li><code>cv::Mat K</code>: 相机内参矩阵。</li><li><code>cv::Mat R</code>, <code>cv::Mat t</code>: 相机位姿的初始估计。</li></ul></li><li><strong>数据类型转换:</strong> 需要将 OpenCV 的 <code>cv::Mat</code> (R, t) 和 <code>cv::Point</code> 转换为 g2o&#x2F;Eigen 使用的 <code>Eigen::Matrix3d</code>, <code>Eigen::Vector3d</code>, <code>Eigen::Vector2d</code> 等。</li></ul><h3 id="5-完整示例代码-带注释"><a href="#5-完整示例代码-带注释" class="headerlink" title="5. 完整示例代码 (带注释)"></a>5. 完整示例代码 (带注释)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen 核心库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Geometry&gt;</span> <span class="comment">// 用于 Isometry3d 等</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 核心库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/sparse_optimizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_binary_edge.h&gt;</span> <span class="comment">// 二元边基类</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 线性求解器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/solvers/csparse/linear_solver_csparse.h&gt;</span> <span class="comment">// CSparse 稀疏求解器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 类型定义 (常用的顶点和边)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/types/sba/types_sba.h&gt;</span> <span class="comment">// 包含 VertexSE3Expmap, VertexPointXYZ, EdgeProjectXYZ2UV, CameraParameters 等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/types/slam3d/se3quat.h&gt;</span> <span class="comment">// SE3Quat 定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenCV (用于数据结构 Point3f, Point2f, Mat)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> g2o;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用 g2o 进行 Bundle Adjustment (优化单个相机位姿和多个 3D 点)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param points_3d 输入的三维点坐标 (世界坐标系)</span></span><br><span class="line"><span class="comment"> * @param points_2d 对应的二维像素观测坐标</span></span><br><span class="line"><span class="comment"> * @param K         相机内参矩阵 (3x3)</span></span><br><span class="line"><span class="comment"> * @param R         相机旋转矩阵的初始估计 (3x3)</span></span><br><span class="line"><span class="comment"> * @param t         相机平移向量的初始估计 (3x1)</span></span><br><span class="line"><span class="comment"> * @note            函数会直接修改输入的 R 和 t 为优化后的结果 (虽然本示例代码没有显式传回，而是打印)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bundleAdjustment</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point3f&gt; points_3d,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> std::vector&lt;cv::Point2f&gt; points_2d,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> cv::Mat &amp;K, cv::Mat &amp;R, cv::Mat &amp;t)</span> </span>&#123; <span class="comment">// R, t 是引用，理论上可以修改后传出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 1. 配置 g2o 优化器 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Configuring g2o...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 定义块求解器类型: BlockSolver&lt; BlockSolverTraits&lt;PoseDim, LandmarkDim&gt; &gt;</span></span><br><span class="line">    <span class="comment">// PoseDim=6 (SE3), LandmarkDim=3 (XYZ)</span></span><br><span class="line">    <span class="keyword">typedef</span> BlockSolver&lt;BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">3</span>&gt;&gt; BlockSolverType;</span><br><span class="line">    <span class="comment">// 定义线性求解器类型: 使用 CSparse 处理稀疏矩阵</span></span><br><span class="line">    <span class="keyword">typedef</span> LinearSolverCSparse&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType;</span><br><span class="line">    <span class="comment">// 创建线性求解器</span></span><br><span class="line">    <span class="keyword">auto</span> linearSolver = std::<span class="built_in">make_unique</span>&lt;LinearSolverType&gt;();</span><br><span class="line">    <span class="comment">// 创建块求解器</span></span><br><span class="line">    <span class="keyword">auto</span> blockSolver = std::<span class="built_in">make_unique</span>&lt;BlockSolverType&gt;(std::<span class="built_in">move</span>(linearSolver));</span><br><span class="line">    <span class="comment">// 创建优化算法: Levenberg-Marquardt</span></span><br><span class="line">    OptimizationAlgorithmLevenberg *algorithm = <span class="keyword">new</span> <span class="built_in">OptimizationAlgorithmLevenberg</span>(std::<span class="built_in">move</span>(blockSolver));</span><br><span class="line">    <span class="comment">// 创建稀疏优化器 (图模型)</span></span><br><span class="line">    SparseOptimizer optimizer;</span><br><span class="line">    <span class="comment">// 设置优化算法</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(algorithm);</span><br><span class="line">    <span class="comment">// 启用详细输出</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 2. 添加顶点 ---</span></span><br><span class="line">    <span class="comment">// a. 添加相机位姿顶点 (VertexSE3Expmap)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding pose vertex...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    VertexSE3Expmap *pose_vertex = <span class="keyword">new</span> <span class="built_in">VertexSE3Expmap</span>();</span><br><span class="line">    pose_vertex-&gt;<span class="built_in">setId</span>(<span class="number">0</span>); <span class="comment">// 顶点 ID 设为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输入的 R, t (cv::Mat) 转换为 g2o::SE3Quat 用于设置初始估计</span></span><br><span class="line">    Eigen::Matrix3d R_mat;</span><br><span class="line">    R_mat &lt;&lt; R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">             R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">             R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, <span class="number">1</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">t_vec</span><span class="params">(t.at&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), t.at&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), t.at&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    pose_vertex-&gt;<span class="built_in">setEstimate</span>(<span class="built_in">SE3Quat</span>(R_mat, t_vec)); <span class="comment">// 设置初始位姿估计</span></span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(pose_vertex); <span class="comment">// 添加到优化器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. 添加三维点顶点 (VertexPointXYZ)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding &quot;</span> &lt;&lt; points_3d.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; point vertices...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> point_index = <span class="number">1</span>; <span class="comment">// 点顶点的 ID 从 1 开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> cv::Point3f p : points_3d) &#123;</span><br><span class="line">        VertexPointXYZ *point_vertex = <span class="keyword">new</span> <span class="built_in">VertexPointXYZ</span>();</span><br><span class="line">        point_vertex-&gt;<span class="built_in">setId</span>(point_index++); <span class="comment">// 设置唯一 ID</span></span><br><span class="line">        point_vertex-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(p.x, p.y, p.z)); <span class="comment">// 设置初始坐标估计</span></span><br><span class="line">        <span class="comment">// **关键：边缘化点**。告诉优化器在求解时使用 Schur 消元，提高效率</span></span><br><span class="line">        point_vertex-&gt;<span class="built_in">setMarginalized</span>(<span class="literal">true</span>);</span><br><span class="line">        optimizer.<span class="built_in">addVertex</span>(point_vertex); <span class="comment">// 添加到优化器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 3. 添加相机参数 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding camera parameters...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 从内参矩阵 K 提取焦距 fx 和主点 cx, cy</span></span><br><span class="line">    <span class="type">double</span> fx = K.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">double</span> cx = K.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">double</span> cy = K.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 创建 CameraParameters 对象 (假设 fy=fx, baseline=0)</span></span><br><span class="line">    CameraParameters *camera = <span class="keyword">new</span> <span class="built_in">CameraParameters</span>(fx, Eigen::<span class="built_in">Vector2d</span>(cx, cy), <span class="number">0</span>);</span><br><span class="line">    camera-&gt;<span class="built_in">setId</span>(<span class="number">0</span>); <span class="comment">// 参数 ID 设为 0</span></span><br><span class="line">    optimizer.<span class="built_in">addParameter</span>(camera); <span class="comment">// 添加到优化器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 4. 添加边 (重投影误差) ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding &quot;</span> &lt;&lt; points_2d.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; edges...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> edge_index = <span class="number">1</span>; <span class="comment">// 边的 ID 也从 1 开始 (可以与点 ID 对应)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> cv::Point2f p : points_2d) &#123;</span><br><span class="line">        EdgeProjectXYZ2UV *edge = <span class="keyword">new</span> <span class="built_in">EdgeProjectXYZ2UV</span>();</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(edge_index); <span class="comment">// 设置唯一 ID</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// **连接顶点:**</span></span><br><span class="line">        <span class="comment">// 边需要连接两个顶点：点顶点 (索引 0) 和位姿顶点 (索引 1)</span></span><br><span class="line">        <span class="comment">// 通过 ID 在优化器中查找对应的点顶点指针</span></span><br><span class="line">        Vertex *point_v = optimizer.<span class="built_in">vertex</span>(edge_index); <span class="comment">// 假设边的 ID 与其对应的点顶点 ID 相同</span></span><br><span class="line">        <span class="keyword">if</span> (!point_v) &#123;</span><br><span class="line">             cerr &lt;&lt; <span class="string">&quot;Error: Point vertex with ID &quot;</span> &lt;&lt; edge_index &lt;&lt; <span class="string">&quot; not found!&quot;</span> &lt;&lt; endl;</span><br><span class="line">             <span class="keyword">continue</span>; <span class="comment">// 或者进行错误处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 dynamic_cast 进行类型安全的转换</span></span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, <span class="built_in">dynamic_cast</span>&lt;VertexPointXYZ *&gt;(point_v));</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, pose_vertex); <span class="comment">// 连接到位姿顶点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// **设置测量值:** 观测到的像素坐标 (u, v)</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(Eigen::<span class="built_in">Vector2d</span>(p.x, p.y));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **关联相机参数:**</span></span><br><span class="line">        <span class="comment">// 第一个 0: 表示这是第 0 组参数 (CameraParameters)</span></span><br><span class="line">        <span class="comment">// 第二个 0: 表示这组参数在优化器中的 ID 是 0</span></span><br><span class="line">        edge-&gt;<span class="built_in">setParameterId</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **设置信息矩阵:** 协方差矩阵的逆，表示测量的不确定性</span></span><br><span class="line">        <span class="comment">// 这里用单位矩阵，表示假设像素噪声是各向同性且方差为 1</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix2d::<span class="built_in">Identity</span>());</span><br><span class="line"></span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge); <span class="comment">// 添加到优化器</span></span><br><span class="line">        edge_index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 5. 执行优化 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Starting optimization...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">// 初始化</span></span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">10</span>);            <span class="comment">// 执行优化，这里只迭代 10 次作为示例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 6. 获取/输出结果 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Optimization finished.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 从位姿顶点获取优化后的估计值 (SE3Quat 类型)</span></span><br><span class="line">    SE3Quat optimized_pose = pose_vertex-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">    <span class="comment">// 将优化后的位姿转换为 Eigen::Isometry3d (方便表示为 4x4 变换矩阵)</span></span><br><span class="line">    <span class="function">Eigen::Isometry3d <span class="title">optimized_T</span><span class="params">(optimized_pose)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Optimized Transformation Matrix (T_world_camera): &quot;</span> &lt;&lt; endl &lt;&lt; optimized_T.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要，可以将 optimized_T 分解回 R 和 t 并更新输入的 cv::Mat</span></span><br><span class="line">    <span class="comment">// Eigen::Matrix3d optimized_R = optimized_T.rotation();</span></span><br><span class="line">    <span class="comment">// Eigen::Vector3d optimized_t = optimized_T.translation();</span></span><br><span class="line">    <span class="comment">// ... (代码将 Eigen 矩阵/向量写回 cv::Mat R, t) ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：本示例没有显式清理 new 出来的顶点、边、参数和算法对象。</span></span><br><span class="line">    <span class="comment">// 在实际应用中，如果优化器析构时没有自动管理这些资源，可能需要手动 delete。</span></span><br><span class="line">    <span class="comment">// 但通常 g2o 的 SparseOptimizer 会接管所有权。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 示例调用 (需要补充完整) ---</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">    // 1. 准备 points_3d, points_2d, K, R_initial, t_initial 数据</span></span><br><span class="line"><span class="comment">    std::vector&lt;cv::Point3f&gt; points_3d = &#123; ... &#125;;</span></span><br><span class="line"><span class="comment">    std::vector&lt;cv::Point2f&gt; points_2d = &#123; ... &#125;;</span></span><br><span class="line"><span class="comment">    cv::Mat K = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; fx, 0, cx, 0, fy, cy, 0, 0, 1);</span></span><br><span class="line"><span class="comment">    cv::Mat R_initial = ...; // 初始旋转</span></span><br><span class="line"><span class="comment">    cv::Mat t_initial = ...; // 初始平移</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 2. 调用 BA 函数</span></span><br><span class="line"><span class="comment">    bundleAdjustment(points_3d, points_2d, K, R_initial, t_initial);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 3. (可选) 使用优化后的 R_initial, t_initial</span></span><br><span class="line"><span class="comment">    // 注意：上面的函数示例仅打印结果，未修改 R_initial, t_initial</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—g2o库—曲线拟合</title>
      <link href="/2025/04/28/c8/"/>
      <url>/2025/04/28/c8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>我们有一系列二维数据点 $(x_i, y_i)$，我们相信这些数据点是由一个指数模型生成的，具体形式为：</p><p>$$y &#x3D; \exp(ax^2 + bx + c)$$</p><p>然而，我们的观测值 $y_i$ 包含噪声。我们的目标是：根据这些带有噪声的观测数据 $(x_i, y_i)$，<strong>估计出最可能生成这些数据的模型参数 $(a, b, c)$ 的值</strong>。</p><p>这本质上是一个优化问题：寻找一组参数 $(a, b, c)$，使得模型预测值 $\exp(ax_i^2 + bx_i + c)$ 与实际观测值 $y_i$ 之间的总误差最小（通常是最小化误差的平方和）。</p><h3 id="2-思考：如何用图优化解决？"><a href="#2-思考：如何用图优化解决？" class="headerlink" title="2. 思考：如何用图优化解决？"></a>2. 思考：如何用图优化解决？</h3><p>我们要将这个问题”翻译”成 g2o 的语言——图。一个图由 <strong>顶点 (Vertices)</strong> 和 <strong>边 (Edges)</strong> 组成。</p><ul><li><p><strong>顶点 (Vertex) 代表什么？</strong></p><ul><li>顶点代表了我们要优化的 <strong>未知变量</strong>。</li><li>在这个问题中，未知变量就是曲线的参数 $(a, b, c)$。这三个参数需要一起被估计，它们共同构成了一个状态。</li><li><strong>因此，我们将 $(a, b, c)$ 定义为一个 g2o 顶点。</strong></li></ul></li><li><p><strong>边 (Edge) 代表什么？</strong></p><ul><li>边代表了变量之间的 <strong>约束</strong> 或者 <strong>测量带来的误差项</strong>。</li><li>我们拥有的信息是 $N$ 个数据点 $(x_i, y_i)$。每一个数据点都提供了一个约束：对于给定的 $x_i$，由当前估计的 $(a, b, c)$ 计算出的预测值 $\exp(ax_i^2 + bx_i + c)$ 应该接近观测值 $y_i$。</li><li><strong>因此，每一个数据点 $(x_i, y_i)$ 都对应图中的一条边。</strong> 这条边衡量了模型预测值与实际测量值之间的误差（残差）。</li></ul></li><li><p><strong>顶点和边如何连接？</strong></p><ul><li>计算第 $i$ 个数据点的误差 $e_i &#x3D; y_i - \exp(ax_i^2 + bx_i + c)$ 时，我们只需要用到参数 $(a, b, c)$ （也就是那个唯一的顶点）和对应的 $x_i$ 值。</li><li>这意味着每条边 <strong>只连接到我们定义的那个参数顶点上</strong>。</li><li><strong>因此，这些边都是一元边 (Unary Edge)。</strong></li></ul></li></ul><p><strong>总结思路：</strong> 我们将创建一个包含 <strong>一个顶点</strong> (代表参数 a, b, c) 和 <strong>N 条一元边</strong> (每条边代表一个数据点 (x, y) 带来的约束&#x2F;误差) 的图。然后，让 g2o 优化这个图，调整顶点的值 (a, b, c)，使得所有边的误差平方和（考虑信息矩阵加权）最小。</p><h3 id="3-g2o-实现步骤"><a href="#3-g2o-实现步骤" class="headerlink" title="3. g2o 实现步骤"></a>3. g2o 实现步骤</h3><p>根据上面的思考，我们需要在 g2o 中完成以下步骤：</p><p><strong>3.1 定义顶点 (<code>CurveFittingVertex</code>)</strong></p><ul><li><strong>目的:</strong> 表示待优化的参数 $(a, b, c)$。</li><li><strong>实现:</strong><ul><li>继承 <code>g2o::BaseVertex&lt;D, T&gt;</code>。</li><li><code>D</code> (维度): 参数有 a, b, c 三个，所以维度是 <strong>3</strong>。</li><li><code>T</code> (类型): 用 Eigen 的三维向量 <code>Eigen::Vector3d</code> 来存储 $(a, b, c)$。</li><li>所以继承 <code>g2o::BaseVertex&lt;3, Eigen::Vector3d&gt;</code>。</li><li><strong>重写 <code>setToOriginImpl()</code>:</strong> 设置顶点的初始估计值。通常设为 (0, 0, 0)。</li><li><strong>重写 <code>oplusImpl()</code>:</strong> 定义如何将优化算法计算出的增量 <code>update</code> (一个包含 $\Delta a, \Delta b, \Delta c$ 的 3 维向量) 应用到当前估计值 <code>_estimate</code> 上。对于 $(a, b, c)$ 这种简单的向量空间变量，直接做向量加法 <code>_estimate += update</code> 即可。</li><li><code>read</code>&#x2F;<code>write</code> 函数在此例中可以留空。</li></ul></li></ul><p><strong>3.2 定义边 (<code>CurveFittingEdge</code>)</strong></p><ul><li><strong>目的:</strong> 表示每个数据点 $(x_i, y_i)$ 带来的约束，并计算其误差。</li><li><strong>实现:</strong><ul><li>继承 <code>g2o::BaseUnaryEdge&lt;D, E, VertexType&gt;</code> (因为只连接一个顶点)。</li><li><code>D</code> (误差维度): 误差 $e_i &#x3D; y_i - \exp(\dots)$ 是一个标量，所以维度是 <strong>1</strong>。</li><li><code>E</code> (测量值类型): 测量值 $y_i$ 是一个 <code>double</code> 类型。</li><li><code>VertexType</code>: 这条边连接的顶点类型是 <code>CurveFittingVertex</code>。</li><li>所以继承 <code>g2o::BaseUnaryEdge&lt;1, double, CurveFittingVertex&gt;</code>。</li><li><strong>构造函数:</strong> 计算误差时需要用到 $x_i$，但 $x_i$ 不是待优化变量，也不是全局参数。它只与这条特定的边（这个特定的数据点）相关。因此，在创建边对象时，需要将对应的 $x_i$ 传入并存储在边对象的成员变量 (如 <code>_x</code>) 中。</li><li><strong>重写 <code>computeError()</code>:</strong> 这是 <strong>边的核心</strong>。在此函数中：<ol><li>获取所连接的顶点 (<code>_vertices[0]</code>)。</li><li>获取顶点当前的估计值 $(a, b, c) &#x3D; \text{vertex}-&gt;\text{estimate}()$。</li><li>使用存储的 <code>_x</code> 和当前的 $(a, b, c)$ 计算预测值 $y_{pred} &#x3D; \exp(a\textit{x}^2 + b\textit{x} + c)$。</li><li>计算误差 $e &#x3D; \text{_measurement} - y_{pred}$，并将结果赋给 <code>_error(0,0)</code>。（<code>_measurement</code> 存储的是观测值 $y_i$，通过 <code>setMeasurement()</code> 设置）。</li></ol></li><li><strong><code>linearizeOplus()</code> (雅可比计算):</strong> 这个例子中 <strong>没有重写</strong> 这个函数。这意味着 g2o 会默认使用 <strong>自动求导</strong> 来计算误差 $e$ 对参数 $a, b, c$ 的偏导数 $(\frac{\partial e}{\partial a}, \frac{\partial e}{\partial b}, \frac{\partial e}{\partial c})$。对于简单问题，自动求导很方便；对于性能要求高的复杂问题，通常需要手动计算并重写此函数。</li><li><code>read</code>&#x2F;<code>write</code> 函数在此例中可以留空。</li></ul></li></ul><p><strong>3.3 配置优化器</strong></p><ul><li><strong>目的:</strong> 告诉 g2o 如何求解这个优化问题。</li><li><strong>实现:</strong><ul><li><strong>选择求解器类型:</strong><ul><li><code>BlockSolver</code>: 定义了优化变量（顶点）和误差（边）的维度。这里是 <code>BlockSolverTraits&lt;3, 1&gt;</code> (顶点维度 3, 边维度 1)。</li><li><code>LinearSolver</code>: 定义了如何求解线性方程组 $Hx &#x3D; -b$。对于规模不大的问题，可以用 <code>LinearSolverDense</code>；对于规模较大、稀疏性较好的问题（如 SLAM），常用 <code>LinearSolverCSparse</code> 或 <code>LinearSolverCholmod</code>。本例用了 <code>LinearSolverCSparse</code>。</li></ul></li><li><strong>选择优化算法:</strong><ul><li>常用的有 <code>OptimizationAlgorithmLevenberg</code> (LM 算法，鲁棒性好)、<code>OptimizationAlgorithmGaussNewton</code> (高斯牛顿法)、<code>OptimizationAlgorithmDogleg</code>。本例用了 LM 算法。</li></ul></li><li><strong>创建 <code>SparseOptimizer</code> 对象:</strong> 这是整个图优化的管理器。</li><li><strong>设置:</strong> 将选择的优化算法设置给 <code>SparseOptimizer</code>，可以设置 <code>setVerbose(true)</code> 来打印优化过程信息。</li></ul></li></ul><p><strong>3.4 构建图</strong></p><ul><li><strong>目的:</strong> 将具体的顶点和边添加到优化器中。</li><li><strong>实现:</strong><ul><li><strong>添加顶点:</strong><ol><li>创建 <code>CurveFittingVertex</code> 对象。</li><li>设置其初始估计值 (<code>setEstimate</code>)，例如 <code>(0, 0, 0)</code>。</li><li>设置其唯一 ID (<code>setId</code>)。</li><li>调用 <code>optimizer.addVertex()</code> 将其添加到图中。</li></ol></li><li><strong>添加边:</strong><ol><li>遍历所有数据点 $(x_i, y_i)$。</li><li>为每个数据点创建一个 <code>CurveFittingEdge</code> 对象，传入 $x_i$。</li><li>设置其唯一 ID (<code>setId</code>)。</li><li><strong>连接到顶点:</strong> 调用 <code>edge-&gt;setVertex(0, vertex_pointer)</code>，将边的第 0 个接口连接到之前创建的顶点。</li><li><strong>设置测量值:</strong> 调用 <code>edge-&gt;setMeasurement(y_i)</code>。</li><li><strong>设置信息矩阵:</strong> 调用 <code>edge-&gt;setInformation(...)</code>。信息矩阵是测量噪声协方差矩阵的逆，代表了这条边的权重。如果假设噪声是高斯分布，标准差为 $\sigma$，那么对于一维误差，信息矩阵就是 $1&#x2F;\sigma^2$。这告诉优化器：噪声越小（$\sigma$ 越小，信息矩阵越大），这个测量值就越可信，优化时应该更努力地满足这个约束。</li><li>调用 <code>optimizer.addEdge()</code> 将边添加到图中。</li></ol></li></ul></li></ul><p><strong>3.5 执行优化</strong></p><ul><li><strong>目的:</strong> 启动 g2o 的优化过程。</li><li><strong>实现:</strong><ul><li>调用 <code>optimizer.initializeOptimization()</code> 进行初始化。</li><li>调用 <code>optimizer.optimize(max_iterations)</code> 开始迭代优化，指定最大迭代次数。</li></ul></li></ul><p><strong>3.6 获取结果</strong></p><ul><li><strong>目的:</strong> 从优化后的图中提取最终的参数估计值。</li><li><strong>实现:</strong><ul><li>优化完成后，顶点对象内部的 <code>_estimate</code> 成员变量已经被更新为最优值。</li><li>直接调用 <code>vertex-&gt;estimate()</code> 即可获取优化后的 $(a, b, c)$。</li></ul></li></ul><h3 id="4-准备工作"><a href="#4-准备工作" class="headerlink" title="4. 准备工作"></a>4. 准备工作</h3><p>在编写 g2o 代码之前，需要：</p><ul><li><strong>包含头文件:</strong> 包含 g2o 核心库、求解器、算法以及 Eigen 库等必要的头文件。</li><li><strong>准备数据:</strong> 生成或加载用于拟合的数据点 <code>x_data</code> 和 <code>y_data</code>。例子中是程序内部生成的带高斯噪声的数据。</li><li><strong>定义参数:</strong> 确定噪声标准差 <code>w_sigma</code> (用于生成数据和设置信息矩阵)，数据点数量 <code>N</code> 等。</li></ul><h3 id="5-完整示例代码"><a href="#5-完整示例代码" class="headerlink" title="5. 完整示例代码"></a>5. 完整示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen 核心部分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 核心库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_unary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/block_solver.h&gt;</span> <span class="comment">// 块求解器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/sparse_optimizer.h&gt;</span> <span class="comment">// 优化器主类</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 优化算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 线性求解器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span> <span class="comment">// 稠密求解器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/solvers/csparse/linear_solver_csparse.h&gt;</span> <span class="comment">// CSparse 稀疏求解器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenCV (仅用于随机数生成)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> g2o;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 1. 定义顶点：表示待优化参数 (a, b, c) ---</span></span><br><span class="line"><span class="comment">// 模板参数：优化变量维度 D=3, 数据类型 T=Eigen::Vector3d</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurveFittingVertex</span> : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW <span class="comment">// Eigen 内存对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CurveFittingVertex</span>() &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置函数：设置初始估计值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>; <span class="comment">// 初始猜测 a=0, b=0, c=0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增量更新函数：如何应用优化增量</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *update)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _estimate += Eigen::<span class="built_in">Vector3d</span>(update); <span class="comment">// 直接向量加法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写函数 (本例中可以忽略)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 2. 定义边：表示每个数据点的约束和误差 ---</span></span><br><span class="line"><span class="comment">// 模板参数：误差维度 D=1, 测量值类型 E=double, 连接的顶点类型 CurveFittingVertex</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurveFittingEdge</span> : <span class="keyword">public</span> BaseUnaryEdge&lt;<span class="number">1</span>, <span class="type">double</span>, CurveFittingVertex&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数：传入该数据点对应的 x 值</span></span><br><span class="line">    <span class="built_in">CurveFittingEdge</span>(<span class="type">double</span> x) : <span class="built_in">BaseUnaryEdge</span>(), _x(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算误差函数：核心部分</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">computeError</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取连接的顶点 (强制类型转换)</span></span><br><span class="line">        <span class="type">const</span> CurveFittingVertex *v = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> CurveFittingVertex *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 获取顶点当前的估计值 (a, b, c)</span></span><br><span class="line">        <span class="type">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        <span class="comment">// 计算模型预测值 y_pred = exp(a*x^2 + b*x + c)</span></span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> prediction = std::<span class="built_in">exp</span>(<span class="built_in">abc</span>(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + <span class="built_in">abc</span>(<span class="number">1</span>, <span class="number">0</span>) * _x + <span class="built_in">abc</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 计算误差 error = measurement - prediction</span></span><br><span class="line">        <span class="comment">// _measurement 是基类成员，存储观测值 y_i</span></span><br><span class="line">        <span class="comment">// _error 是基类成员 (1x1 矩阵)，存储计算结果</span></span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - prediction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性化函数 (雅可比计算)</span></span><br><span class="line">    <span class="comment">// 本例中未实现，g2o 将使用自动求导</span></span><br><span class="line">    <span class="comment">// virtual void linearizeOplus() override &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写函数 (本例中可以忽略)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> _x; <span class="comment">// 存储该边对应的数据点的 x 值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// --- 数据准备 ---</span></span><br><span class="line">    <span class="type">double</span> real_a = <span class="number">1.0</span>, real_b = <span class="number">2.0</span>, real_c = <span class="number">1.0</span>; <span class="comment">// 真实参数</span></span><br><span class="line">    <span class="type">int</span> N = <span class="number">100</span>;                                     <span class="comment">// 数据点数量</span></span><br><span class="line">    <span class="type">double</span> w_sigma = <span class="number">1.0</span>;                            <span class="comment">// 噪声标准差</span></span><br><span class="line">    cv::RNG rng;                                     <span class="comment">// OpenCV 随机数生成器</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; x_data, y_data; <span class="comment">// 存储数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Generating data...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(real_a * x * x + real_b * x + real_c) + rng.<span class="built_in">gaussian</span>(w_sigma));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- g2o 配置 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Configuring g2o...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 1. 定义块求解器类型 BlockSolver&lt; BlockSolverTraits&lt;顶点维度, 边维度&gt; &gt;</span></span><br><span class="line">    <span class="keyword">typedef</span> BlockSolver&lt;BlockSolverTraits&lt;<span class="number">3</span>, <span class="number">1</span>&gt;&gt; BlockSolverType;</span><br><span class="line">    <span class="comment">// 2. 定义线性求解器类型</span></span><br><span class="line">    <span class="keyword">typedef</span> LinearSolverCSparse&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType;</span><br><span class="line">    <span class="comment">// 3. 创建线性求解器 (使用智能指针管理)</span></span><br><span class="line">    <span class="keyword">auto</span> linearSolver = std::<span class="built_in">make_unique</span>&lt;LinearSolverType&gt;();</span><br><span class="line">    <span class="comment">// 4. 创建块求解器 (使用智能指针管理)</span></span><br><span class="line">    <span class="keyword">auto</span> blockSolver = std::<span class="built_in">make_unique</span>&lt;BlockSolverType&gt;(std::<span class="built_in">move</span>(linearSolver));</span><br><span class="line">    <span class="comment">// 5. 创建优化算法 (Levenberg-Marquardt)</span></span><br><span class="line">    OptimizationAlgorithmLevenberg *algorithm = <span class="keyword">new</span> <span class="built_in">OptimizationAlgorithmLevenberg</span>(std::<span class="built_in">move</span>(blockSolver));</span><br><span class="line">    <span class="comment">// 6. 创建稀疏优化器 (图模型)</span></span><br><span class="line">    SparseOptimizer optimizer;</span><br><span class="line">    <span class="comment">// 7. 设置优化算法</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(algorithm);</span><br><span class="line">    <span class="comment">// 8. 启用详细输出</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 构建图 ---</span></span><br><span class="line">    <span class="comment">// 1. 添加顶点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding vertex...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    CurveFittingVertex *vertex = <span class="keyword">new</span> <span class="built_in">CurveFittingVertex</span>();</span><br><span class="line">    vertex-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 设置初始值</span></span><br><span class="line">    vertex-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);                             <span class="comment">// 设置 ID</span></span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(vertex);                  <span class="comment">// 添加到图中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加边</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding &quot;</span> &lt;&lt; N &lt;&lt; <span class="string">&quot; edges...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        CurveFittingEdge *edge = <span class="keyword">new</span> <span class="built_in">CurveFittingEdge</span>(x_data[i]); <span class="comment">// 创建边，传入 x_i</span></span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(i);                                          <span class="comment">// 设置 ID</span></span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, vertex);                              <span class="comment">// 连接到顶点</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(y_data[i]);                         <span class="comment">// 设置测量值 y_i</span></span><br><span class="line">        <span class="comment">// 设置信息矩阵 (1x1)，值为 1 / sigma^2</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="type">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>() * <span class="number">1</span> / (w_sigma * w_sigma));</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);                                 <span class="comment">// 添加到图中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 执行优化 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Starting optimization...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">// 初始化</span></span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">100</span>);            <span class="comment">// 执行优化，最多 100 次迭代</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 输出结果 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Optimization finished.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Eigen::Vector3d estimated_abc = vertex-&gt;<span class="built_in">estimate</span>(); <span class="comment">// 获取优化后的顶点估计值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Estimated model parameters (a, b, c): &quot;</span> &lt;&lt; estimated_abc.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Real model parameters (a, b, c):      &quot;</span> &lt;&lt; real_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; real_b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; real_c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 (OptimizationAlgorithmLevenberg* algorithm 是 new 出来的，理论上应 delete，</span></span><br><span class="line">    <span class="comment">// 但 setAlgorithm 后 optimizer 会接管，通常不需要手动 delete)</span></span><br><span class="line">    <span class="comment">// delete algorithm; // 可能导致重复释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—Ceres库</title>
      <link href="/2025/04/27/c7/"/>
      <url>/2025/04/27/c7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>略</p><h2 id="2-问题定义"><a href="#2-问题定义" class="headerlink" title="2. 问题定义"></a>2. 问题定义</h2><p>以 $y &#x3D; \exp \left( {a{x}^{2} + {bx} + c}\right)$ 为例</p><p>我们现在拥有一系列的观测值</p><table><thead><tr><th align="center">x</th><th align="center">$x_1$</th><th align="center">$x_2$</th><th align="center">…</th><th align="center">$x_n$</th></tr></thead><tbody><tr><td align="center">y</td><td align="center">$y_1$</td><td align="center">$y_2$</td><td align="center">…</td><td align="center">$y_n$</td></tr></tbody></table><p>目标是用函数 $y &#x3D; \exp(ax^2 + bx + c)$ 拟合这些数据点，确定参数 $a$、$b$ 和 $c$ 的最佳值</p><p>在迭代的某一步，假设我们有参数的当前估计值 $a_k$、$b_k$ 和 $c_k$。</p><p>对于每个数据点 $x_i$，我们可以计算模型预测值 ：$\hat{y}_i$</p><p>$\hat{y}_i &#x3D; \exp(a_k x_i^2 + b_k x_i + c_k)$</p><p>那么<strong>残差</strong>就是实际观测值与预测值的差</p><p>$r_i &#x3D; y_i - \hat{y}_i &#x3D; y_i - \exp(a_k x_i^2 + b_k x_i + c_k)$</p><p>我们不希望正负残差相互抵消，所以计算残差的平方，然后求和得到<strong>代价函数</strong>：</p><p>$J(a, b, c) &#x3D; \sum_{i&#x3D;1}^{n} r_i^2 &#x3D; \sum_{i&#x3D;1}^{n} [y_i - \exp(a x_i^2 + b x_i + c)]^2$</p><p>最小二乘法的目标是找到参数 $a$、$b$ 和 $c$ 的值，使得代价函数 $J(a, b, c)$ 最小。即：</p><p>$\min_{a, b, c} J(a, b, c) &#x3D; \min_{a, b, c} \sum_{i&#x3D;1}^{n} [y_i - \exp(a x_i^2 + b x_i + c)]^2$</p><h2 id="3-三种求解方式"><a href="#3-三种求解方式" class="headerlink" title="3. 三种求解方式"></a>3. 三种求解方式</h2><h3 id="3-1-方法一：解析求导"><a href="#3-1-方法一：解析求导" class="headerlink" title="3.1 方法一：解析求导"></a>3.1 方法一：解析求导</h3><p>这种方法需要我们手动计算雅可比矩阵，并将其提供给 Ceres。</p><h3 id="3-1-1-计算雅可比矩阵"><a href="#3-1-1-计算雅可比矩阵" class="headerlink" title="3.1.1 计算雅可比矩阵"></a>3.1.1 计算雅可比矩阵</h3><p>我们有残差 $r(a, b, c) &#x3D; y - \exp(ax^2 + bx + c)$<br>令 $E &#x3D; \exp(ax^2 + bx + c)$<br>使用链式法则求偏导：</p><ul><li>$\frac{\partial r}{\partial a} &#x3D; - \frac{\partial E}{\partial a} &#x3D; - E \cdot \frac{\partial (ax^2 + bx + c)}{\partial a} &#x3D; - E \cdot x^2$</li><li>$\frac{\partial r}{\partial b} &#x3D; - \frac{\partial E}{\partial b} &#x3D; - E \cdot \frac{\partial (ax^2 + bx + c)}{\partial b} &#x3D; - E \cdot x$</li><li>$\frac{\partial r}{\partial c} &#x3D; - \frac{\partial E}{\partial c} &#x3D; - E \cdot \frac{\partial (ax^2 + bx + c)}{\partial c} &#x3D; - E \cdot 1$</li></ul><h3 id="3-1-2-实现-Ceres-Cost-Function"><a href="#3-1-2-实现-Ceres-Cost-Function" class="headerlink" title="3.1.2 实现 Ceres Cost Function"></a>3.1.2 实现 Ceres Cost Function</h3><p>在Ceres Solver中实现解析求导，我们需要继承的是<code>ceres::SizedCostFunction</code>类。</p><p><code>SizedCostFunction</code>是一个模板类，参数格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceres::SizedCostFunction&lt;残差数量, 参数块<span class="number">1</span>大小, 参数块<span class="number">2</span>大小, ...&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于这个问题（拟合模型 y &#x3D; exp(ax² + bx + c)）：</p><ul><li><strong>残差数量</strong> &#x3D; 1（每个观测点产生1个残差值）</li><li><strong>参数块大小</strong> &#x3D; 3（我们优化的参数是a, b, c）</li></ul><p>所以我们需要继承的类是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceres::SizedCostFunction&lt;<span class="number">1</span>, <span class="number">3</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义我们的CostFunction类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析求导的Cost Function</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExponentialResidualAnalytic</span> : <span class="keyword">public</span> ceres::SizedCostFunction&lt;<span class="number">1</span>, <span class="number">3</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ExponentialResidualAnalytic</span>(<span class="type">double</span> x, <span class="type">double</span> y)</span><br><span class="line">        : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须重写的Evaluate函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Evaluate</span><span class="params">(<span class="type">double</span> <span class="type">const</span>* <span class="type">const</span>* parameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">double</span>* residuals,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">double</span>** jacobians)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储数据点的成员变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x_;  <span class="comment">// x坐标</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> y_;  <span class="comment">// y坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现Evaluate函数</p><p>这是最重要的一步，它包含两部分：</p><ol><li>计算残差值（必须）</li><li>计算雅可比矩阵（可选，但解析求导的关键）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ExponentialResidualAnalytic::Evaluate</span><span class="params">(<span class="type">double</span> <span class="type">const</span>* <span class="type">const</span>* parameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">double</span>* residuals,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">double</span>** jacobians)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取参数值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> a = parameters[<span class="number">0</span>][<span class="number">0</span>];  <span class="comment">// 第一个参数块的第一个元素</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> b = parameters[<span class="number">0</span>][<span class="number">1</span>];  <span class="comment">// 第一个参数块的第二个元素</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> c = parameters[<span class="number">0</span>][<span class="number">2</span>];  <span class="comment">// 第一个参数块的第三个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 计算残差 r = y - exp(ax² + bx + c)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> exponent = a * x_ * x_ + b * x_ + c;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> prediction = std::<span class="built_in">exp</span>(exponent);</span><br><span class="line">    residuals[<span class="number">0</span>] = y_ - prediction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 如果需要计算雅可比矩阵（这是一种优化策略，有时候迭代过程中不需要计算就会传入null）</span></span><br><span class="line">    <span class="keyword">if</span> (jacobians != <span class="literal">nullptr</span> &amp;&amp; jacobians[<span class="number">0</span>] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 我们要计算残差对参数a, b, c的偏导数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预先计算的exp项（提高效率）</span></span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> exp_term = std::<span class="built_in">exp</span>(exponent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dr/da = -exp(ax² + bx + c) * x²</span></span><br><span class="line">        jacobians[<span class="number">0</span>][<span class="number">0</span>] = -exp_term * x_ * x_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dr/db = -exp(ax² + bx + c) * x</span></span><br><span class="line">        jacobians[<span class="number">0</span>][<span class="number">1</span>] = -exp_term * x_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dr/dc = -exp(ax² + bx + c)</span></span><br><span class="line">        jacobians[<span class="number">0</span>][<span class="number">2</span>] = -exp_term;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回计算成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-1-3-Evaluate函数参数详解"><a href="#3-1-3-Evaluate函数参数详解" class="headerlink" title="3.1.3 Evaluate函数参数详解"></a>3.1.3 Evaluate函数参数详解</h3><p><strong>1. <code>double const* const* parameters</code></strong></p><ul><li>这是一个指向指针数组的指针</li><li><code>parameters[i]</code>访问第i个参数块（我们只有一个参数块，所以使用<code>parameters[0]</code>）</li><li><code>parameters[0][j]</code>访问第一个参数块的第j个元素</li></ul><p><strong>2. <code>double* residuals</code></strong></p><ul><li>用于存储计算的残差值</li><li><code>residuals[i]</code>写入第i个残差值（我们只有一个残差，所以使用<code>residuals[0]</code>）</li></ul><p><strong>3. <code>double** jacobians</code></strong></p><ul><li>用于存储计算的雅可比矩阵</li><li>如果为<code>nullptr</code>，表示优化器不需要计算雅可比矩阵</li><li><code>jacobians[i]</code>指向与第i个参数块相关的雅可比矩阵</li><li><code>jacobians[0][j]</code>存储残差对第一个参数块中第j个参数的偏导数</li></ul><h3 id="3-2-方法二：自动求导-Automatic-Differentiation"><a href="#3-2-方法二：自动求导-Automatic-Differentiation" class="headerlink" title="3.2 方法二：自动求导 (Automatic Differentiation)"></a>3.2 方法二：自动求导 (Automatic Differentiation)</h3><p>这是 Ceres 推荐的方法之一，因为它结合了易用性和效率。我们只需要定义一个计算残差的模板化 “Functor”，Ceres 会自动计算导数。</p><h3 id="3-2-1-Functor-结构基本形式"><a href="#3-2-1-Functor-结构基本形式" class="headerlink" title="3.2.1 Functor 结构基本形式"></a>3.2.1 Functor 结构基本形式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ExponentialResidualAutoDiff</span> &#123;</span><br><span class="line">    <span class="comment">// 构造函数：保存每个残差项所需的输入数据</span></span><br><span class="line">    <span class="built_in">ExponentialResidualAutoDiff</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板化的 operator()：这是自动求导的关键</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* <span class="type">const</span> parameters, T* residual)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从参数数组中提取参数</span></span><br><span class="line">        <span class="comment">// 执行计算</span></span><br><span class="line">        <span class="comment">// 设置残差</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储每个数据点的信息</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x_;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-2-关键点详解"><a href="#3-2-2-关键点详解" class="headerlink" title="3.2.2 关键点详解"></a>3.2.2 关键点详解</h3><h3 id="模板化-operator"><a href="#模板化-operator" class="headerlink" title="模板化 operator()"></a>模板化 operator()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* <span class="type">const</span> parameters, T* residual)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>这是自动求导的核心。这里的类型 <code>T</code> 是关键，Ceres 会：</p><ul><li>使用 <code>T = double</code> 调用此函数来计算残差值</li><li>使用 <code>T = ceres::Jet&lt;double, N&gt;</code> 调用此函数来计算导数</li></ul><p><code>ceres::Jet</code> 类型是 Ceres 的特殊类型，它存储了值和对应的导数信息。当函数使用 <code>Jet</code> 类型执行计算时，它自动跟踪导数。</p><h3 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h3><ul><li><code>const T* const parameters</code>：包含优化参数的数组</li><li><code>T* residual</code>：输出残差的数组</li><li>返回 <code>bool</code>：表示计算是否成功</li></ul><h3 id="3-2-3-详细示例：分步解析"><a href="#3-2-3-详细示例：分步解析" class="headerlink" title="3.2.3 详细示例：分步解析"></a>3.2.3 详细示例：分步解析</h3><p>对于模型 $y &#x3D; \exp(ax^2 + bx + c)$，以下是详细的自动求导 Functor 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ExponentialResidualAutoDiff</span> &#123;</span><br><span class="line">    <span class="comment">// 构造函数：存储每个数据点的 x 和 y 值</span></span><br><span class="line">    <span class="built_in">ExponentialResidualAutoDiff</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* <span class="type">const</span> parameters, T* residual)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 步骤 1: 从参数数组中提取 a, b, c</span></span><br><span class="line">        <span class="type">const</span> T a = parameters[<span class="number">0</span>];</span><br><span class="line">        <span class="type">const</span> T b = parameters[<span class="number">1</span>];</span><br><span class="line">        <span class="type">const</span> T c = parameters[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 2: 将常量 x_ 和 y_ 转换为类型 T</span></span><br><span class="line">        <span class="comment">// 这是必要的，因为所有计算都需要在 T 类型的环境中进行</span></span><br><span class="line">        <span class="type">const</span> T x = <span class="built_in">T</span>(x_);</span><br><span class="line">        <span class="type">const</span> T y = <span class="built_in">T</span>(y_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 3: 计算模型预测值</span></span><br><span class="line">        <span class="comment">// 注意：所有数学运算都使用 T 类型的变量</span></span><br><span class="line">        T exponent = a * x * x + b * x + c;</span><br><span class="line">        T prediction = <span class="built_in">exp</span>(exponent);  <span class="comment">// 使用与 T 兼容的 exp 函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 4: 计算残差 (observed - predicted)</span></span><br><span class="line">        residual[<span class="number">0</span>] = y - prediction;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 数据点的 x 和 y 值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x_;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-方法三：数值求导-Numeric-Differentiation"><a href="#3-3-方法三：数值求导-Numeric-Differentiation" class="headerlink" title="3.3 方法三：数值求导 (Numeric Differentiation)"></a>3.3 方法三：数值求导 (Numeric Differentiation)</h3><p>这种方法最容易实现，因为我们只需要提供计算残差的函数。Ceres 会通过微小地改变参数值并观察残差的变化来近似计算雅可比矩阵。但它通常比自动或解析求导慢，并且可能不太精确。</p><h3 id="3-3-1-实现-Functor-与自动求导类似，但非模板化"><a href="#3-3-1-实现-Functor-与自动求导类似，但非模板化" class="headerlink" title="3.3.1 实现 Functor (与自动求导类似，但非模板化)"></a>3.3.1 实现 Functor (与自动求导类似，但非模板化)</h3><p>创建一个结构体（或类），重载 <code>operator()</code>，但这次只使用 <code>double</code> 类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值求导的 Functor</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ExponentialResidualNumeric</span> &#123;</span><br><span class="line">    <span class="built_in">ExponentialResidualNumeric</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：这里 operator() 不是模板化的</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">double</span>* <span class="type">const</span> parameters, <span class="type">double</span>* residual)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> a = parameters[<span class="number">0</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> b = parameters[<span class="number">1</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> c = parameters[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> x = x_;</span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> y = y_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算预测值 prediction = exp(ax^2 + bx + c)</span></span><br><span class="line">        <span class="type">double</span> exponent_term = a * x * x + b * x + c;</span><br><span class="line">        <span class="type">double</span> prediction = std::<span class="built_in">exp</span>(exponent_term);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算残差 residual = y - prediction</span></span><br><span class="line">        residual[<span class="number">0</span>] = y - prediction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x_; <span class="comment">// 观测数据 x</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> y_; <span class="comment">// 观测数据 y</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-后续步骤"><a href="#4-后续步骤" class="headerlink" title="4. 后续步骤"></a>4. 后续步骤</h2><p>流程：</p><ol><li><p><strong>定义残差函数</strong>：使用解析求导、自动求导或数值求导</p></li><li><p><strong>创建和配置 Problem</strong>：</p><p> 在 Ceres 中，<code>Problem</code> 是整个优化问题的容器，它包含了所有残差块和参数块。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceres::Problem problem;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 上面这行代码创建了一个空的 Problem 对象。接下来，我们需要向它添加残差块（即我们前面定义的成本函数）。</p><ul><li>添加残差块</li></ul><p> 对于每个数据点 $(x_i, y_i)$，我们需要添加一个残差块。这是通过 <code>AddResidualBlock</code> 方法完成的：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; x_data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    ceres::CostFunction* cost_function =</span><br><span class="line">        <span class="keyword">new</span> ceres::<span class="built_in">AutoDiffCostFunction</span>&lt;ExponentialResidualAutoDiff, <span class="number">1</span>, <span class="number">3</span>&gt;(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">ExponentialResidualAutoDiff</span>(x_data[i], y_data[i])</span><br><span class="line">        );</span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(cost_function,</span><br><span class="line">                             <span class="literal">nullptr</span>, <span class="comment">// 使用默认的平方损失函数</span></span><br><span class="line">                             parameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 这段代码的详细解释：</p><ol><li><strong>创建成本函数</strong>：<ul><li>对于自动求导，我们使用 <code>AutoDiffCostFunction&lt;&gt;</code> 类</li><li>模板参数 <code>ExponentialResidualAutoDiff</code> 是我们的函数对象类型</li><li><code>1</code> 表示残差的维度（每个观测产生一个标量残差）</li><li><code>3</code> 表示参数块的大小（我们的参数是 a, b, c 三个值）</li><li>构造函数参数是我们的函数对象实例，它保存了特定的 $x_i$ 和 $y_i$ 值</li></ul></li><li><strong>添加残差块</strong>：<ul><li><p><code>AddResidualBlock</code> 将成本函数添加到问题中</p></li><li><p>第一个参数是成本函数指针</p></li><li><p>第二个参数是损失函数指针（<code>nullptr</code> 表示使用默认的平方损失函数）</p><p>  损失函数用于减轻离群点（outliers）的影响。当为 <code>nullptr</code> 时，Ceres 使用默认的平方损失函数，即直接对残差平方求和。</p><p>  如果需要使用鲁棒损失函数，比如 Huber 损失，可以这样写：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceres::LossFunction* loss_function = <span class="keyword">new</span> ceres::<span class="built_in">HuberLoss</span>(<span class="number">1.0</span>);</span><br><span class="line">problem.<span class="built_in">AddResidualBlock</span>(cost_function, loss_function, parameters);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>第三个参数是指向我们要优化的参数数组的指针</p></li></ul></li></ol><ul><li><p>设置参数约束（如有需要）</p><p>  除了添加残差块外，还可以对参数设置一些约束：</p><ol><li><p><strong>固定某些参数</strong>（使它们在优化过程中不变）：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">problem.<span class="built_in">SetParameterBlockConstant</span>(parameters + <span class="number">2</span>); <span class="comment">// 固定第三个参数 c</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>设置参数的上下界</strong>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">problem.<span class="built_in">SetParameterLowerBound</span>(parameters, <span class="number">0</span>, <span class="number">0.0</span>); <span class="comment">// 设置 a &gt;= 0</span></span><br><span class="line">problem.<span class="built_in">SetParameterUpperBound</span>(parameters, <span class="number">1</span>, <span class="number">0.0</span>); <span class="comment">// 设置 b &lt;= 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p><strong>配置求解器选项</strong></p><p> 求解器负责实际运行优化算法。我们通过 <code>Solver::Options</code> 对象来配置求解器：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ceres::Solver::Options options;</span><br><span class="line">options.linear_solver_type = ceres::DENSE_QR;</span><br><span class="line">options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">options.max_num_iterations = <span class="number">50</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 详细解释：</p><ol><li><strong><code>linear_solver_type</code></strong>：<ul><li>在每次迭代中，非线性最小二乘问题会被线性化，产生一个线性子问题</li><li>这个选项决定如何求解这个线性子问题</li><li><code>DENSE_QR</code> 适合小规模问题（参数和残差数量都不太多）</li><li>对于大规模问题，可以考虑 <code>SPARSE_NORMAL_CHOLESKY</code> 或 <code>ITERATIVE_SCHUR</code> 等</li></ul></li><li><strong><code>minimizer_progress_to_stdout</code></strong>：<ul><li>设为 <code>true</code> 时会在优化过程中打印进度信息</li><li>非常有用，可以看到成本函数的下降情况和收敛过程</li></ul></li><li><strong><code>max_num_iterations</code></strong>：<ul><li>最大迭代次数</li><li>防止算法在难以收敛的情况下无限循环</li></ul></li></ol><p> 其他常用选项包括：</p><ul><li><strong><code>function_tolerance</code></strong>：当成本函数相对变化小于此值时停止</li><li><strong><code>gradient_tolerance</code></strong>：当梯度范数小于此值时停止</li><li><strong><code>parameter_tolerance</code></strong>：当参数相对变化小于此值时停止</li><li><strong><code>num_threads</code></strong>：使用的线程数量（并行化）</li></ul></li><li><p><strong>运行求解器</strong></p><p> 设置好 Problem 和 Options 后，调用 <code>Solve</code> 函数执行优化：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceres::Solver::Summary summary;</span><br><span class="line">ceres::Solve(options, &amp;problem, &amp;summary);</span><br></pre></td></tr></table></figure><p> 这会执行优化算法并将结果存储在 <code>summary</code> 对象中。优化过程完成后，最优参数值会被直接写入到我们提供给 Problem 的 <code>parameters</code> 数组中。</p></li><li><p><strong>分析结果</strong></p><p> 优化完成后，通常需要：</p><ol><li><p><strong>检查优化状态</strong>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p> 这会打印一个简短报告，包括终止状态、迭代次数、求解时间等</p></li><li><p><strong>查看最终参数值</strong>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; parameters[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; a_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; parameters[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; b_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; parameters[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; c_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>计算最终代价</strong>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> final_cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; x_data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">double</span> residual = y_data[i] - std::<span class="built_in">exp</span>(parameters[<span class="number">0</span>] * x_data[i] * x_data[i] +</span><br><span class="line">                                        parameters[<span class="number">1</span>] * x_data[i] + parameters[<span class="number">2</span>]);</span><br><span class="line">    final_cost += residual * residual;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Final Total Cost: &quot;</span> &lt;&lt; final_cost &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="5-完整代码实现"><a href="#5-完整代码实现" class="headerlink" title="5. 完整代码实现"></a>5. 完整代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于生成模拟数据的真实参数</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> a_true = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> b_true = <span class="number">2.0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> c_true = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成带噪声的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate_data</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt;&amp; x_data, std::vector&lt;<span class="type">double</span>&gt;&amp; y_data, <span class="type">int</span> num_points = <span class="number">100</span>, <span class="type">double</span> noise_stddev = <span class="number">0.1</span>)</span> </span>&#123;</span><br><span class="line">    x_data.<span class="built_in">resize</span>(num_points);</span><br><span class="line">    y_data.<span class="built_in">resize</span>(num_points);</span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">generator</span><span class="params">(<span class="number">123</span>)</span></span>; <span class="comment">// Use a fixed seed for reproducibility</span></span><br><span class="line">    <span class="function">std::normal_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, noise_stddev)</span></span>; <span class="comment">// 高斯噪声</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Generated Data:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_points; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> x = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i) / (num_points / <span class="number">10.0</span>); <span class="comment">// x 从 0 到 9.9 or similar range</span></span><br><span class="line">        x_data[i] = x;</span><br><span class="line">        <span class="type">double</span> y_clean = std::<span class="built_in">exp</span>(a_true * x * x + b_true * x + c_true);</span><br><span class="line">        <span class="type">double</span> noise = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        y_data[i] = y_clean + noise;</span><br><span class="line">        <span class="comment">// Optional: Print generated data to verify</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y_clean: &quot; &lt;&lt; y_clean &lt;&lt; &quot;, y_observed: &quot; &lt;&lt; y_data[i] &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Data generation complete. &quot;</span> &lt;&lt; num_points &lt;&lt; <span class="string">&quot; points generated.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]); <span class="comment">// 初始化 glog</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 生成数据</span></span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; x_data;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; y_data;</span><br><span class="line">    <span class="built_in">generate_data</span>(x_data, y_data, <span class="number">100</span>, <span class="number">0.2</span>); <span class="comment">// 使用 100 个点，噪声标准差 0.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置初始参数估计值</span></span><br><span class="line">    <span class="type">double</span> initial_a = <span class="number">0.9</span>;</span><br><span class="line">    <span class="type">double</span> initial_b = <span class="number">1.1</span>;</span><br><span class="line">    <span class="type">double</span> initial_c = <span class="number">0.9</span>;</span><br><span class="line">    <span class="type">double</span> parameters[<span class="number">3</span>] = &#123;initial_a, initial_b, initial_c&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 构建 Ceres 问题 (Problem)</span></span><br><span class="line">    ceres::Problem problem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 选择一种求导方法并将残差块添加到 Problem ---</span></span><br><span class="line">    <span class="comment">// --- 一次只能取消注释一个方法块来测试 ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法一：使用解析求导</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;\nUsing Analytic Differentiation:\n&quot;;</span></span><br><span class="line"><span class="comment">    for (size_t i = 0; i &lt; x_data.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">        ceres::CostFunction* cost_function =</span></span><br><span class="line"><span class="comment">            new ExponentialResidualAnalytic(x_data[i], y_data[i]);</span></span><br><span class="line"><span class="comment">        problem.AddResidualBlock(cost_function,</span></span><br><span class="line"><span class="comment">                                 nullptr, // 使用默认的平方损失函数</span></span><br><span class="line"><span class="comment">                                 parameters);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法二：使用自动求导</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nUsing Automatic Differentiation:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; x_data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        ceres::CostFunction* cost_function =</span><br><span class="line">            <span class="keyword">new</span> ceres::<span class="built_in">AutoDiffCostFunction</span>&lt;ExponentialResidualAutoDiff, <span class="number">1</span>, <span class="number">3</span>&gt;(</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">ExponentialResidualAutoDiff</span>(x_data[i], y_data[i])</span><br><span class="line">            );</span><br><span class="line">        problem.<span class="built_in">AddResidualBlock</span>(cost_function,</span><br><span class="line">                                 <span class="literal">nullptr</span>, <span class="comment">// 使用默认的平方损失函数</span></span><br><span class="line">                                 parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法三：使用数值求导</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;\nUsing Numeric Differentiation:\n&quot;;</span></span><br><span class="line"><span class="comment">    for (size_t i = 0; i &lt; x_data.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">        ceres::CostFunction* cost_function =</span></span><br><span class="line"><span class="comment">            new ceres::NumericDiffCostFunction&lt;ExponentialResidualNumeric, ceres::CENTRAL, 1, 3&gt;(</span></span><br><span class="line"><span class="comment">                new ExponentialResidualNumeric(x_data[i], y_data[i])</span></span><br><span class="line"><span class="comment">            );</span></span><br><span class="line"><span class="comment">        problem.AddResidualBlock(cost_function,</span></span><br><span class="line"><span class="comment">                                 nullptr, // 使用默认的平方损失函数</span></span><br><span class="line"><span class="comment">                                 parameters);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 配置求解器 (Solver)</span></span><br><span class="line">    ceres::Solver::Options options;</span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR; <span class="comment">// 对于小型问题，DENSE_QR 通常足够</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;  <span class="comment">// 将优化过程输出到控制台</span></span><br><span class="line">    options.max_num_iterations = <span class="number">50</span>;             <span class="comment">// 最大迭代次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 运行求解器</span></span><br><span class="line">    ceres::Solver::Summary summary;</span><br><span class="line">    ceres::<span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSolver Summary:\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; summary.FullReport() &lt;&lt; &quot;\n&quot;; // 更详细的报告</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nEstimated parameters:\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; parameters[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; a_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; parameters[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; b_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; parameters[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; c_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最终的总代价 (Sum of Squared Errors)</span></span><br><span class="line">    <span class="type">double</span> final_cost = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; x_data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">         <span class="type">double</span> residual = y_data[i] - std::<span class="built_in">exp</span>(parameters[<span class="number">0</span>] * x_data[i] * x_data[i] + parameters[<span class="number">1</span>] * x_data[i] + parameters[<span class="number">2</span>]);</span><br><span class="line">         final_cost += residual * residual;</span><br><span class="line">     &#125;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Final Total Cost (Sum of Squared Errors): &quot;</span> &lt;&lt; final_cost &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-如何选择求导方法"><a href="#6-如何选择求导方法" class="headerlink" title="6. 如何选择求导方法"></a>6. 如何选择求导方法</h2><ul><li><strong>自动求导 (AutoDiff):</strong> 通常是<strong>首选</strong>。它易于实现（只需写 Functor），准确（不像数值求导有近似误差），并且通常比数值求导快。Ceres 对其进行了高度优化。</li><li><strong>解析求导 (Analytic):</strong> 如果你能正确无误地推导出雅可比矩阵并实现它，这通常是<strong>最快</strong>的方法。但是，手动求导和实现很容易出错，尤其对于复杂的模型。调试起来也比较困难。</li><li><strong>数值求导 (Numeric):</strong> <strong>最容易实现</strong>，因为你只需要提供计算残差的函数。但它通常是<strong>最慢</strong>的，并且其精度受限于步长选择（Ceres 会尝试选择合适的步长），可能在某些情况下导致收敛性问题。适合快速原型设计或当解析&#x2F;自动求导难以实现时。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—cmake的新旧方法</title>
      <link href="/2025/04/24/c5/"/>
      <url>/2025/04/24/c5/</url>
      
        <content type="html"><![CDATA[<h1 id="CMake新旧方法对比详解"><a href="#CMake新旧方法对比详解" class="headerlink" title="CMake新旧方法对比详解"></a>CMake新旧方法对比详解</h1><h2 id="一、include-directories-vs-target-include-directories"><a href="#一、include-directories-vs-target-include-directories" class="headerlink" title="一、include_directories() vs target_include_directories()"></a>一、include_directories() vs target_include_directories()</h2><p>这两者的核心区别在于<strong>作用域(Scope)</strong>：</p><h3 id="1-include-directories-AFTER-BEFORE-SYSTEM-dir1-dir2-…"><a href="#1-include-directories-AFTER-BEFORE-SYSTEM-dir1-dir2-…" class="headerlink" title="1. include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])"></a>1. include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])</h3><p><strong>作用域：目录级别</strong></p><ul><li><strong>作用:</strong> 将指定的目录添加到<strong>当前<code>CMakeLists.txt</code>文件以及所有在它之后处理的子目录</strong>的头文件搜索路径中</li><li><strong>影响:</strong> 在调用后定义的<strong>所有目标</strong>都会将这些目录添加到它们的include路径中</li><li><strong>特点:</strong> 类似于”全局”设置（在当前目录及子目录范围内）</li><li><strong>问题:</strong> 不够精确，可能导致目标获得不必要的包含路径</li></ul><h3 id="2-target-include-directories-SYSTEM-AFTER-BEFORE-items1…-items2…-…"><a href="#2-target-include-directories-SYSTEM-AFTER-BEFORE-items1…-items2…-…" class="headerlink" title="2. target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1…] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2…] …])"></a>2. target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1…] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2…] …])</h3><p><strong>作用域：目标级别</strong></p><ul><li><strong>作用:</strong> 将指定的目录添加到**特定目标<code>&lt;target&gt;</code>**的头文件搜索路径中</li><li><strong>影响:</strong> 只有指定的<code>&lt;target&gt;</code>会使用这些include路径</li><li><strong>关键修饰符:</strong><ul><li><code>PRIVATE</code>: 目录只用于编译<code>&lt;target&gt;</code>自身，不会传递给依赖者</li><li><code>PUBLIC</code>: 目录既用于编译<code>&lt;target&gt;</code>自身，也会传递给依赖<code>&lt;target&gt;</code>的其他目标</li><li><code>INTERFACE</code>: 目录不用于编译<code>&lt;target&gt;</code>自身，但会传递给依赖<code>&lt;target&gt;</code>的其他目标</li></ul></li><li><strong>优点:</strong> 非常精确和清晰，为每个目标精确指定所需的头文件路径</li></ul><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table><thead><tr><th>特性</th><th><code>include_directories()</code></th><th><code>target_include_directories()</code></th></tr></thead><tbody><tr><td><strong>作用域</strong></td><td>目录级别 (影响当前及子目录所有后续目标)</td><td>目标级别 (只影响指定目标)</td></tr><tr><td><strong>精确性</strong></td><td>低</td><td>高</td></tr><tr><td><strong>封装性</strong></td><td>差 (设置是”全局”的)</td><td>好 (设置附加到具体目标)</td></tr><tr><td><strong>现代推荐</strong></td><td><strong>否</strong> (除非有特定全局需求)</td><td><strong>是</strong> (现代CMake的核心用法)</td></tr><tr><td><strong>依赖传递</strong></td><td>不直接处理</td><td>通过<code>PUBLIC</code>&#x2F;<code>INTERFACE</code>关键字明确控制</td></tr></tbody></table><h2 id="二、CMake旧方式-vs-新方式-现代CMake"><a href="#二、CMake旧方式-vs-新方式-现代CMake" class="headerlink" title="二、CMake旧方式 vs 新方式(现代CMake)"></a>二、CMake旧方式 vs 新方式(现代CMake)</h2><p>核心区别在于从<strong>基于变量和全局&#x2F;目录设置</strong>转向<strong>基于目标及其属性</strong>。</p><h3 id="1-旧方式-Variable-Centric-Directory-Scoped-CMake-2-x时代"><a href="#1-旧方式-Variable-Centric-Directory-Scoped-CMake-2-x时代" class="headerlink" title="1. 旧方式 (Variable-Centric, Directory-Scoped - CMake 2.x时代)"></a>1. 旧方式 (Variable-Centric, Directory-Scoped - CMake 2.x时代)</h3><p><strong>核心思想:</strong> <code>find_package</code>等命令设置全局变量，手动使用这些变量配置目标</p><h4 id="典型流程"><a href="#典型流程" class="headerlink" title="典型流程:"></a>典型流程:</h4><ol><li><p><strong>查找和配置库</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(SomeLib REQUIRED)</span><br><span class="line"><span class="comment"># 执行FindSomeLib.cmake或旧式SomeLibConfig.cmake</span></span><br><span class="line"><span class="comment"># 设置变量：SomeLib_FOUND, SomeLib_INCLUDE_DIRS, SomeLib_LIBRARIES等</span></span><br></pre></td></tr></table></figure></li><li><p><strong>手动应用这些变量</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局设置，影响后续所有目标</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;SomeLib_INCLUDE_DIRS&#125;</span>) </span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;SomeLib_DEFINITIONS&#125;</span>)     </span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"><span class="comment"># 手动链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app <span class="variable">$&#123;SomeLib_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="特点与问题"><a href="#特点与问题" class="headerlink" title="特点与问题:"></a>特点与问题:</h4><ul><li><strong>全局状态:</strong> 变量和设置通常影响整个目录或项目，容易冲突</li><li><strong>手动管理:</strong> 需了解每个库设置的变量，手动应用到目标的各属性</li><li><strong>传递依赖困难:</strong> 如<code>my_app</code>依赖<code>my_lib</code>，而<code>my_lib</code>依赖<code>SomeLib</code>，则<code>my_app</code>的配置文件可能也需了解<code>SomeLib</code>，破坏封装性</li><li><strong>不够清晰:</strong> 链接指令通常只是变量引用，不明确表达依赖关系</li></ul><h3 id="2-新方式-Modern-CMake-Target-Centric-CMake-3-0-时代"><a href="#2-新方式-Modern-CMake-Target-Centric-CMake-3-0-时代" class="headerlink" title="2. 新方式 (Modern CMake &#x2F; Target-Centric - CMake 3.0+时代)"></a>2. 新方式 (Modern CMake &#x2F; Target-Centric - CMake 3.0+时代)</h3><p><strong>核心思想:</strong> 将构建所需的所有信息附加到目标上，使用导入目标(Imported Targets)</p><h4 id="典型流程-1"><a href="#典型流程-1" class="headerlink" title="典型流程:"></a>典型流程:</h4><ol><li><p><strong>查找和配置库</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(SomeLib REQUIRED)</span><br><span class="line"><span class="comment"># 执行现代SomeLibConfig.cmake</span></span><br><span class="line"><span class="comment"># 定义导入目标，如SomeLib::Core</span></span><br></pre></td></tr></table></figure></li><li><p><strong>直接链接导入目标</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只需链接目标，CMake自动处理其他所有事情</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE SomeLib::Core)</span><br></pre></td></tr></table></figure></li></ol><h4 id="特点与优势"><a href="#特点与优势" class="headerlink" title="特点与优势:"></a>特点与优势:</h4><ul><li><strong>目标即一切:</strong> 所有配置围绕目标进行，使用<code>target_*</code>系列命令</li><li><strong>封装性:</strong> 库的使用细节被封装在导入目标中，配置文件只需知道目标名称</li><li><strong>自动传递依赖:</strong> 链接导入目标时，该目标的公共依赖自动传递</li><li><strong>清晰明确:</strong> 链接指令直接表明依赖关系</li><li><strong>精确控制:</strong> 使用<code>PRIVATE</code>&#x2F;<code>PUBLIC</code>&#x2F;<code>INTERFACE</code>关键字精确控制依赖传递</li></ul><h3 id="对比总结-1"><a href="#对比总结-1" class="headerlink" title="对比总结"></a>对比总结</h3><table><thead><tr><th>方面</th><th>旧方式 (Variable-Centric)</th><th>新方式 (Target-Centric)</th></tr></thead><tbody><tr><td><strong>核心</strong></td><td>全局&#x2F;目录变量 (<code>_DIRS</code>, <code>_LIBS</code>)</td><td>目标及其属性 (<code>target_*</code>命令, 导入目标)</td></tr><tr><td><strong><code>find_package</code></strong></td><td>主要设置变量</td><td>主要定义导入目标 (<code>Namespace::Target</code>)</td></tr><tr><td><strong>配置方式</strong></td><td>手动应用变量到目标</td><td>链接导入目标，CMake自动处理细节</td></tr><tr><td><strong>包含路径</strong></td><td><code>include_directories()</code> (全局)</td><td><code>target_include_directories()</code> (目标级)</td></tr><tr><td><strong>链接</strong></td><td><code>target_link_libraries(... $&#123;..._LIBS&#125;)</code></td><td><code>target_link_libraries(... Namespace::Target)</code></td></tr><tr><td><strong>依赖传递</strong></td><td>手动处理，易出错</td><td>自动处理 (通过<code>PUBLIC</code>&#x2F;<code>INTERFACE</code>)</td></tr><tr><td><strong>封装性</strong></td><td>差</td><td>好</td></tr><tr><td><strong>推荐度</strong></td><td>不推荐</td><td><strong>强烈推荐</strong></td></tr></tbody></table><h2 id="三、实践建议"><a href="#三、实践建议" class="headerlink" title="三、实践建议"></a>三、实践建议</h2><ol><li><p><strong>始终优先使用现代CMake方法</strong></p><ul><li>使用<code>target_*</code>系列命令而非全局设置</li><li>链接导入目标而非变量列表</li></ul></li><li><p><strong>合理使用作用域关键字</strong></p><ul><li><code>PRIVATE</code>: 仅在目标内部使用，不传递给依赖者</li><li><code>PUBLIC</code>: 在目标内部使用且传递给依赖者</li><li><code>INTERFACE</code>: 不在目标内部使用，仅传递给依赖者</li></ul></li><li><p><strong>创建自己的库时</strong></p><ul><li>导出明确的目标而非变量</li><li>正确设置<code>PUBLIC</code>和<code>INTERFACE</code>属性以确保依赖正确传递</li></ul></li><li><p><strong>处理旧式库时</strong></p><ul><li>可以创建接口库封装旧式变量，使其符合现代CMake风格</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(SomeOldLib::SomeOldLib INTERFACE IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(SomeOldLib::SomeOldLib PROPERTIES</span><br><span class="line">  INTERFACE_INCLUDE_DIRECTORIES <span class="string">&quot;$&#123;SomeOldLib_INCLUDE_DIRS&#125;&quot;</span></span><br><span class="line">  INTERFACE_LINK_LIBRARIES <span class="string">&quot;$&#123;SomeOldLib_LIBRARIES&#125;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—find原理—以ceres为例子的实操</title>
      <link href="/2025/04/24/c6/"/>
      <url>/2025/04/24/c6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-更新-locate-数据库（必做！）"><a href="#1-更新-locate-数据库（必做！）" class="headerlink" title="1. 更新 locate 数据库（必做！）"></a>1. 更新 locate 数据库（必做！）</h2><ul><li><strong>操作:</strong> 打开终端，运行 <code>sudo updatedb</code></li><li><strong>原因:</strong> 确保 locate 的数据库包含你刚刚安装的新库的文件信息，否则后续步骤可能找不到任何内容</li></ul><h2 id="2-初步定位：查找核心配置文件-Config-cmake"><a href="#2-初步定位：查找核心配置文件-Config-cmake" class="headerlink" title="2. 初步定位：查找核心配置文件 (Config.cmake)"></a>2. 初步定位：查找核心配置文件 (Config.cmake)</h2><ul><li><strong>操作:</strong> 运行以下命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;ceres&#x27;</span></span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/home/xfy/3d/ceres/ceres-solver/build/third_party/abseil-cpp/abslConfig.cmake</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/cmake/CeresConfig.cmake.in</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/cmake/CreateCeresConfig.cmake</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/third_party/abseil-cpp/CMake/abslConfig.cmake.in</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/third_party/googletest/googletest/cmake/Config.cmake.in</span><br><span class="line">/usr/lib/cmake/Ceres/CeresConfig.cmake</span><br><span class="line">/usr/local/lib/cmake/Ceres/CeresConfig.cmake</span><br></pre></td></tr></table></figure><p>可以看到最后两行就是要找的，一个是系统级安装目录，一个是用户安装目录的。</p><h2 id="3-确定-find-package-名称"><a href="#3-确定-find-package-名称" class="headerlink" title="3. 确定 find_package 名称"></a>3. 确定 find_package 名称</h2><p>由CeresConfig.cmake可以知道这里的名称大小写是Ceres，所以应该是<code>find_package(Ceres REQUIRED)</code></p><h2 id="4-如何使用"><a href="#4-如何使用" class="headerlink" title="4. 如何使用"></a>4. 如何使用</h2><p>这个文档的注释中没有像OpenCV那样写出如何使用，此时就需要自己来寻找。</p><p>首先查找*Config.cmake 文件中是否有创建目标的代码：</p><ul><li><code>add_library(库名 IMPORTED)</code></li><li><code>add_library(库名::组件名 IMPORTED)</code></li></ul><p>这里查找看到：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">TARGET</span> ceres)</span><br><span class="line">  <span class="comment"># For backwards compatibility, create a local &#x27;alias&#x27; target with the</span></span><br><span class="line">  <span class="comment"># non-namespace-qualified Ceres target name. Note that this is not a</span></span><br><span class="line">  <span class="comment"># true ALIAS library in CMake terms as they cannot point to imported targets.</span></span><br><span class="line">  <span class="keyword">add_library</span>(ceres INTERFACE IMPORTED)</span><br><span class="line">  <span class="keyword">set_target_properties</span>(ceres PROPERTIES INTERFACE_LINK_LIBRARIES Ceres::ceres)</span><br></pre></td></tr></table></figure><p>创建了目标<code>Ceres::ceres</code>。</p><p>既然创建了目标，那说明是cmake的新使用方法就行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(my_app Ceres::ceres)</span><br></pre></td></tr></table></figure><h3 id="通用方法判断库是否提供导入目标"><a href="#通用方法判断库是否提供导入目标" class="headerlink" title="通用方法判断库是否提供导入目标"></a>通用方法判断库是否提供导入目标</h3><p>从这个 Ceres 的例子中，我们可以总结出一些通用方法来判断任何库是否提供导入目标：</p><ol><li><strong>查看库的配置文件</strong>：<ul><li>寻找 <code>include($&#123;XXX_DIR&#125;/XXXTargets.cmake)</code> 这样的语句</li><li>寻找 <code>add_library(XXX::XXX IMPORTED)</code> 这样的语句</li><li>寻找 <code>set_target_properties(XXX::XXX ...)</code> 这样的语句</li></ul></li><li><strong>查看库变量的设置</strong>：<ul><li>如果看到 <code>set(XXX_LIBRARIES XXX::XXX)</code>，表明库提供了导入目标</li></ul></li></ol><p>如果是传统方式的话：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统方式 - 需要同时设置包含目录和链接库</span></span><br><span class="line"><span class="comment"># 例外，在ceres和opencv的cmake中都说明了不需要target_include_directories</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PRIVATE <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-补充小知识：findpackage的查找顺序"><a href="#5-补充小知识：findpackage的查找顺序" class="headerlink" title="5. 补充小知识：findpackage的查找顺序"></a>5. 补充小知识：findpackage的查找顺序</h2><ol><li><strong>首先检查 Ceres_DIR 变量</strong><ul><li>如果设置了 Ceres_DIR，CMake 会直接查找该目录下的 CeresConfig.cmake</li><li>如果找到了有效的配置文件，查找过程立即结束</li></ul></li><li><strong>然后才会搜索 CMAKE_PREFIX_PATH</strong></li><li><strong>接着是 CMAKE_FRAMEWORK_PATH 和 CMAKE_APPBUNDLE_PATH</strong>（主要用于 macOS）</li><li><strong>最后是标准系统安装位置</strong><ul><li>&#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;Ceres&#x2F;</li><li>&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;Ceres&#x2F;</li></ul></li></ol><h3 id="如果想要指定版本，有两种方式："><a href="#如果想要指定版本，有两种方式：" class="headerlink" title="如果想要指定版本，有两种方式："></a>如果想要指定版本，有两种方式：</h3><ol><li><p><strong>使用 CMAKE_PREFIX_PATH（推荐）</strong></p><p> 这是最通用、最干净的方式，尤其是当处理多个第三方库时：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令行设置</span></span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=/home/xfy/3d/ceres/ceres-solver/build ..</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 或在 CMakeLists.txt 中：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 find_package 之前设置</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_PREFIX_PATH <span class="string">&quot;/home/xfy/3d/ceres/ceres-solver/build&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Ceres REQUIRED)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>优点</strong>：</p><ul><li>可以一次性指定多个库的搜索路径</li><li>不需要为每个库单独设置变量</li><li>是 CMake 推荐的方式</li></ul></li><li><p><strong>使用特定库的 _DIR 变量</strong></p><p> 对于单个库，直接设置其专用变量也很有效：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令行方式</span></span><br><span class="line">cmake -DCeres_DIR=/home/xfy/3d/ceres/ceres-solver/build/lib/cmake/Ceres ..</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 或在 CMakeLists.txt 中：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(Ceres_DIR <span class="string">&quot;/home/xfy/3d/ceres/ceres-solver/build/lib/cmake/Ceres&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Ceres REQUIRED)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>注意</strong>：Ceres_DIR 应该指向包含 CeresConfig.cmake 的确切目录，而不仅仅是构建目录。其中Ceres就是<strong>find_package名称</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—find原理—以opencv为例子的实操</title>
      <link href="/2025/04/24/c4/"/>
      <url>/2025/04/24/c4/</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>更新 <code>locate</code> 数据库 (必做！)</strong></p><ul><li><strong>操作:</strong> 打开终端，运行 <code>sudo updatedb</code>。</li><li><strong>原因:</strong> 确保 <code>locate</code> 的数据库包含你刚刚安装的新库的文件信息。否则后续步骤可能什么也找不到。</li></ul></li><li><p><strong>初步定位：查找核心配置文件 (<code>Config.cmake</code>)</strong></p><ul><li><p><strong>操作:</strong> 运行以下命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;opencv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为</span></span><br><span class="line">~ ❯ locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;opencv&#x27;</span></span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/3rdparty/ade/ade-0.1.1f/sources/ade/cmake/adeConfig.cmake.in</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/CPackConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/CPackSourceConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/OpenCVConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/opencv_python_config.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/unix-install/OpenCVConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/cmake/OpenCVGenConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/cmake/OpenCVGenPkgconfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/cmake/templates/OpenCVConfig.cmake.in</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/samples/hal/c_hal/config.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/samples/hal/slow_hal/config.cmake</span><br><span class="line">/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVConfig.cmake</span><br><span class="line">/usr/local/opencv/4.5.5/lib/cmake/opencv4/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/3rdparty/ade/ade-0.1.1f/sources/ade/cmake/adeConfig.cmake.in</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/CPackConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/CPackSourceConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/opencv_python_config.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/unix-install/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/cmake/OpenCVGenConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/cmake/OpenCVGenPkgconfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/cmake/templates/OpenCVConfig.cmake.in</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/samples/hal/c_hal/config.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/samples/hal/slow_hal/config.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/usr/local/lib/cmake/opencv4/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/1f605c5b588ec93f0f1947a29092b374d5fd184eedbfea41eba42bc85f33b932/diff/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVConfig.cmake</span><br></pre></td></tr></table></figure><p>  可以看到有很多，但是我知道我是安装到&#x2F;usr&#x2F;local&#x2F;的所以看&#x2F;usr&#x2F;local&#x2F;opencv&#x2F;4.5.5&#x2F;lib&#x2F;cmake&#x2F;opencv4&#x2F;OpenCVConfig.cmake<br>  这一个</p></li></ul></li><li><p><strong>确定 <code>find_package</code> 名称</strong></p><p> 由OpenCVConfig.cmake可以知道这里的名称大小写是OpenCV，所以应该是find_package(OpenCV REQUIRED)</p><p> 这里可以指定模块，也可以不指定，没有太大影响的。之前文章的例子里指定了模块的写法是find_package(OpenCV REQUIRED COMPONENTS core imgcodecs highgui)</p></li><li><p><strong>然后通过gedit或者vim等等查看这个文件</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  The OpenCV CMake configuration file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#             ** File generated automatically, do not modify **</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Usage from an external project:</span></span><br><span class="line"><span class="comment">#    In your CMakeLists.txt, add these lines:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED)</span></span><br><span class="line"><span class="comment">#    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # Not needed for CMake &gt;= 2.8.11</span></span><br><span class="line"><span class="comment">#    target_link_libraries(MY_TARGET_NAME $&#123;OpenCV_LIBS&#125;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Or you can search for specific OpenCV modules:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core videoio)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    You can also mark OpenCV components as optional:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core OPTIONAL_COMPONENTS viz)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    If the module is found then OPENCV_&lt;MODULE&gt;_FOUND is set to TRUE.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    This file will define the following variables:</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIBS                     : The list of all imported targets for OpenCV modules.</span></span><br><span class="line"><span class="comment">#      - OpenCV_INCLUDE_DIRS             : The OpenCV include directories.</span></span><br><span class="line"><span class="comment">#      - OpenCV_COMPUTE_CAPABILITIES     : The version of compute capability.</span></span><br><span class="line"><span class="comment">#      - OpenCV_ANDROID_NATIVE_API_LEVEL : Minimum required level of Android API.</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION                  : The version of this OpenCV build: &quot;4.5.5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MAJOR            : Major version part of OpenCV_VERSION: &quot;4&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MINOR            : Minor version part of OpenCV_VERSION: &quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_PATCH            : Patch version part of OpenCV_VERSION: &quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_STATUS           : Development status of this build: &quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Advanced variables:</span></span><br><span class="line"><span class="comment">#      - OpenCV_SHARED                   : Use OpenCV as shared library</span></span><br><span class="line"><span class="comment">#      - OpenCV_INSTALL_PATH             : OpenCV location</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIB_COMPONENTS           : Present OpenCV modules list</span></span><br><span class="line"><span class="comment">#      - OpenCV_USE_MANGLED_PATHS        : Mangled OpenCV path flag</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Deprecated variables:</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_TWEAK            : Always &quot;0&quot;</span></span><br></pre></td></tr></table></figure><p> 翻译一下</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================================================</span></span><br><span class="line"><span class="comment">#  OpenCV CMake 配置文件</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#             ** 文件自动生成，请勿修改 **</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  从外部项目使用：</span></span><br><span class="line"><span class="comment">#    在你的 CMakeLists.txt 中，添加这些行：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED)</span></span><br><span class="line"><span class="comment">#    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # 对于 CMake &gt;= 2.8.11 已不再需要</span></span><br><span class="line"><span class="comment">#    target_link_libraries(MY_TARGET_NAME $&#123;OpenCV_LIBS&#125;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    或者你可以搜索特定的 OpenCV 模块：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core videoio)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    你也可以将 OpenCV 组件标记为可选：</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core OPTIONAL_COMPONENTS viz)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    如果找到了模块，那么 OPENCV_&lt;MODULE&gt;_FOUND 会被设置为 TRUE。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    该文件将定义以下变量：</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIBS                     : OpenCV 模块的所有导入目标 (imported targets) 的列表。</span></span><br><span class="line"><span class="comment">#      - OpenCV_INCLUDE_DIRS             : OpenCV 的包含目录。</span></span><br><span class="line"><span class="comment">#      - OpenCV_COMPUTE_CAPABILITIES     : 计算能力 (Compute Capability) 的版本。</span></span><br><span class="line"><span class="comment">#      - OpenCV_ANDROID_NATIVE_API_LEVEL : 最低要求的 Android API 级别。</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION                  : 此 OpenCV 构建的版本：&quot;4.5.5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MAJOR            : OpenCV_VERSION 的主版本号：&quot;4&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MINOR            : OpenCV_VERSION 的次版本号：&quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_PATCH            : OpenCV_VERSION 的修订版本号：&quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_STATUS           : 此构建的开发状态：&quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    高级变量：</span></span><br><span class="line"><span class="comment">#      - OpenCV_SHARED                   : 将 OpenCV 作为共享库使用</span></span><br><span class="line"><span class="comment">#      - OpenCV_INSTALL_PATH             : OpenCV 的位置</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIB_COMPONENTS           : 当前存在的 OpenCV 模块列表</span></span><br><span class="line"><span class="comment">#      - OpenCV_USE_MANGLED_PATHS        : Mangled OpenCV 路径标志</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    已弃用变量：</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_TWEAK            : 始终为 &quot;0&quot;</span></span><br></pre></td></tr></table></figure><p> 可以看到这里说明了执行findpackage之后给哪些变量赋予了哪些值，也写了用法</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  从外部项目使用：</span></span><br><span class="line"><span class="comment">#    在你的 CMakeLists.txt 中，添加这些行：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED)</span></span><br><span class="line"><span class="comment">#    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # 对于 CMake &gt;= 2.8.11 已不再需要</span></span><br><span class="line"><span class="comment">#    target_link_libraries(MY_TARGET_NAME $&#123;OpenCV_LIBS&#125;)</span></span><br></pre></td></tr></table></figure><p> 这段注释虽然目的是指导用户，但它本身混合了新旧两种风格的痕迹，我们需要仔细解读：</p><ol><li><strong>旧方式 (Variable-Based) 的体现：</strong><ul><li><p><strong>明确的指令:</strong> 注释中明确给出了以下使用步骤：</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MY_TARGET_NAME <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p>这是典型的旧式 CMake 用法。它依赖于 <code>find_package</code> 执行后设置的两个<strong>变量</strong>：</p><ul><li><code>$&#123;OpenCV_INCLUDE_DIRS&#125;</code>: 包含了需要添加到编译器搜索路径的头文件目录。你需要手动调用 <code>include_directories()</code> (或现代的 <code>target_include_directories()</code>) 来使用它。</li><li><code>$&#123;OpenCV_LIBS&#125;</code>: 包含了需要链接的库文件列表（可能是库文件的绝对路径，也可能在旧 CMake 中是链接器标志）。你需要手动将这个变量传递给 <code>target_link_libraries()</code>。</li></ul></li></ul></li><li><strong>新方式 (Target-Based) 的线索和提示：</strong><ul><li><p><strong>关键注释:</strong> <code>include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # Not needed for CMake &gt;= 2.8.11</code></p><ul><li>这是<strong>最强烈的暗示</strong>。它告诉你，对于较新版本的 CMake (2.8.11 及以后，实际上现代 CMake 实践通常指 3.x 系列)，手动添加 <code>OpenCV_INCLUDE_DIRS</code> 是<strong>不必要</strong>的。为什么？因为现代 CMake 的核心是<strong>目标 (Target)</strong>。当你链接到一个设计良好的<strong>导入目标 (Imported Target)</strong> 时，这个目标本身就封装了它所需的包含目录、链接库、编译定义等信息。CMake 会自动将这些信息传递给链接它的目标。</li></ul></li><li><p><strong>变量 <code>OpenCV_LIBS</code> 的描述:</strong> <code>OpenCV_LIBS : The list of all **imported targets** for OpenCV modules.</code></p><ul><li>这一点非常重要！虽然旧方式的使用示例中是 <code>target_link_libraries(... $&#123;OpenCV_LIBS&#125;)</code>，但这里对 <code>OpenCV_LIBS</code> 变量内容的描述明确指出了它包含的是 <strong>“imported targets”</strong>。这意味着 <code>$&#123;OpenCV_LIBS&#125;</code> 变量里存放的不再仅仅是库文件名或路径，而是 CMake 能理解的、代表了 OpenCV 各个模块的<strong>目标名称</strong>列表（例如 <code>OpenCV::core</code>, <code>OpenCV::imgproc</code> 等）。</li></ul></li><li><p>结合以上两点，可以推断出新方式的用法（尽管这段注释没有直接写出来）</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED COMPONENTS core imgproc highgui) <span class="comment"># 假设需要这三个</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MY_TARGET_NAME PRIVATE OpenCV::core OpenCV::imgproc OpenCV::highgui)</span><br><span class="line"></span><br><span class="line">这里<span class="keyword">find_package</span>可以不指定具体哪个模块而是用</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line">区别不大</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>推荐指定模块，不然就会把所有模块全都链接到项目上</span><br><span class="line"></span><br><span class="line">说是这样说，但是我指定模块运行失败，不知道是因为名字不对还是啥</span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)才成功的</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h3 id="总结：还是用文档里说的吧"><a href="#总结：还是用文档里说的吧" class="headerlink" title="总结：还是用文档里说的吧"></a>总结：还是用文档里说的吧</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  从外部项目使用：</span></span><br><span class="line"><span class="comment">#    在你的 CMakeLists.txt 中，添加这些行：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>) <span class="comment"># 对于 CMake &gt;= 2.8.11 已不再需要</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MY_TARGET_NAME <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line">其中<span class="keyword">include_directories</span>可有可无</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—find原理</title>
      <link href="/2025/04/24/c3/"/>
      <url>/2025/04/24/c3/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在CMake中找到并链接新安装的库"><a href="#如何在CMake中找到并链接新安装的库" class="headerlink" title="如何在CMake中找到并链接新安装的库"></a>如何在CMake中找到并链接新安装的库</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在安装新库后，找出在CMake中<code>find_package</code>所需的<strong>精确包名</strong>（包括大小写），并了解如何正确链接该库（优先使用现代CMake目标）。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1-更新locate数据库（必做！）"><a href="#1-更新locate数据库（必做！）" class="headerlink" title="1. 更新locate数据库（必做！）"></a>1. 更新<code>locate</code>数据库（必做！）</h3><ul><li><strong>操作:</strong> 打开终端，运行<code>sudo updatedb</code></li><li><strong>原因:</strong> 确保<code>locate</code>的数据库包含你刚刚安装的新库的文件信息</li><li><strong>注意:</strong> 如果跳过此步骤，后续步骤可能找不到任何结果</li></ul><h3 id="2-初步定位：查找核心配置文件（Config-cmake）"><a href="#2-初步定位：查找核心配置文件（Config-cmake）" class="headerlink" title="2. 初步定位：查找核心配置文件（Config.cmake）"></a>2. 初步定位：查找核心配置文件（<code>Config.cmake</code>）</h3><ul><li><strong>操作:</strong> 运行以下命令（替换<code>库名关键词</code>）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;库名关键词&#x27;</span></span><br></pre></td></tr></table></figure></li><li><strong>目的:</strong> 查找包含<code>config.cmake</code>（不区分大小写）且路径中包含指定库名关键词的文件</li><li><strong>分析结果:</strong> 注意文件路径，例如：<ul><li><code>/usr/lib/x86_64-linux-gnu/cmake/SomeLib/SomeLibConfig.cmake</code></li><li><code>/opt/my_libs/lib/cmake/somelib/somelib-config.cmake</code></li></ul></li></ul><h3 id="3-确定find-package名称"><a href="#3-确定find-package名称" class="headerlink" title="3. 确定find_package名称"></a>3. 确定<code>find_package</code>名称</h3><ul><li><strong>操作:</strong> 从上一步找到的配置文件路径中提取<strong>保留原始大小写的包名</strong></li><li><strong>提取方法:</strong> 包名通常位于<code>.../cmake/</code>目录之后，是<code>Config.cmake</code>文件或其所在目录的名称<ul><li>例如：<ul><li><code>/usr/lib/x86_64-linux-gnu/cmake/SomeLib/SomeLibConfig.cmake</code> → 包名为<code>SomeLib</code></li><li><code>/opt/my_libs/lib/cmake/somelib/somelib-config.cmake</code> → 包名为<code>somelib</code></li></ul></li></ul></li><li><strong>结果:</strong> 提取出的精确名称将用于<code>CMakeLists.txt</code>中的<code>find_package()</code></li></ul><h3 id="4-全面查找：找到所有相关的-cmake文件（可选但推荐）"><a href="#4-全面查找：找到所有相关的-cmake文件（可选但推荐）" class="headerlink" title="4. 全面查找：找到所有相关的.cmake文件（可选但推荐）"></a>4. 全面查找：找到所有相关的<code>.cmake</code>文件（可选但推荐）</h3><ul><li><strong>操作:</strong> 运行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;库名关键词&#x27;</span> | grep -i <span class="string">&#x27;\.cmake$&#x27;</span></span><br></pre></td></tr></table></figure></li><li><strong>目的:</strong> 找到所有路径包含库名关键词且以<code>.cmake</code>结尾的文件</li><li><strong>用途:</strong> 这有助于了解整个CMake配置的结构</li></ul><h3 id="5-深入检查：查看文件内容，确认链接方式"><a href="#5-深入检查：查看文件内容，确认链接方式" class="headerlink" title="5. 深入检查：查看文件内容，确认链接方式"></a>5. 深入检查：查看文件内容，确认链接方式</h3><ul><li><strong>操作:</strong><ul><li>用文本编辑器打开第2步找到的核心<code>Config.cmake</code>文件</li><li>检查是否通过<code>include()</code>命令包含了其他<code>.cmake</code>文件，如有则一并查看</li></ul></li><li><strong>检查要点:</strong><ul><li><strong>寻找导入目标:</strong> 搜索<code>add_library</code>关键字，寻找形如<code>add_library(Namespace::Target IMPORTED ...)</code>的行<ul><li>如找到，<strong>强烈建议</strong>使用现代CMake的链接方式：<code>target_link_libraries(... Namespace::Target)</code></li></ul></li><li><strong>寻找变量定义:</strong> 搜索<code>set(</code>命令，查找版本变量<code>$&#123;SomeLib_VERSION&#125;</code>或包含目录&#x2F;库变量<code>$&#123;SomeLib_INCLUDE_DIRS&#125;</code>, <code>$&#123;SomeLib_LIBRARIES&#125;</code></li><li><strong>查看依赖:</strong> 注意是否有<code>find_dependency(...)</code>命令，了解库是否自动处理依赖</li><li><strong>阅读注释:</strong> 好的配置文件通常包含使用说明</li></ul></li></ul><h3 id="6-在CMakeLists-txt中实践"><a href="#6-在CMakeLists-txt中实践" class="headerlink" title="6. 在CMakeLists.txt中实践"></a>6. 在<code>CMakeLists.txt</code>中实践</h3><ul><li><strong>操作:</strong><ul><li>使用第3步确定的<strong>精确包名</strong>调用<code>find_package</code>:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(SomeLib REQUIRED) <span class="comment"># 使用大小写正确的名字</span></span><br><span class="line"><span class="comment"># 或者，如果库支持组件：</span></span><br><span class="line"><span class="comment"># find_package(SomeLib REQUIRED COMPONENTS core gui)</span></span><br></pre></td></tr></table></figure></li><li><strong>优先使用导入目标</strong>（如果在第5步找到）:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(your_target PRIVATE SomeLib::core SomeLib::gui)</span><br></pre></td></tr></table></figure></li><li><strong>如果找不到导入目标</strong>（旧式库）:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(your_target PRIVATE <span class="variable">$&#123;SomeLib_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_target PRIVATE <span class="variable">$&#123;SomeLib_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ol><li>先用<code>locate</code>定位关键的<code>*Config.cmake</code>文件，确定<code>find_package</code>的官方名称</li><li>检查配置文件内容，确认链接方式：<ul><li>现代方式：使用导入目标(<code>Namespace::Target</code>)</li><li>传统方式：使用包含目录和库变量</li></ul></li><li>在实际项目中正确使用找到的库</li></ol><blockquote><p><strong>提示：</strong> 虽然<code>locate</code>是方便的本地检查工具，但<strong>库的官方文档</strong>仍然是了解其CMake用法的最权威来源。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—CMake</title>
      <link href="/2025/04/24/c2/"/>
      <url>/2025/04/24/c2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-最小可行的-CMakeLists-txt"><a href="#1-最小可行的-CMakeLists-txt" class="headerlink" title="1. 最小可行的 CMakeLists.txt"></a>1. <strong>最小可行的 CMakeLists.txt</strong></h2><p><strong>思考：</strong></p><p>我需要告诉 CMake 什么？</p><ul><li>它需要知道最低兼容的 CMake 版本是多少？（<code>cmake_minimum_required</code>）</li><li>我的项目叫什么名字？（<code>project</code>）</li><li>我想生成什么？（一个可执行文件？一个库？）（<code>add_executable</code> 或 <code>add_library</code>）</li><li>这个生成目标需要哪些源文件？（<code>add_executable</code> 或 <code>add_library</code> 的参数）</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 指定 CMake 最低版本要求</span></span><br><span class="line"><span class="comment">#    Ubuntu 22.04 自带的 CMake 版本通常较高 (如 3.22+)，但设置一个稍低的版本（如 3.16）可以增加兼容性。</span></span><br><span class="line"><span class="comment">#    这确保了我们使用的 CMake 命令和特性在该版本及以上可用。</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定义项目名称和语言</span></span><br><span class="line"><span class="comment">#    项目名称会用在一些默认变量和 IDE 中。</span></span><br><span class="line"><span class="comment">#    指定 CXX 表示这是一个 C++ 项目，CMake 会自动寻找并配置 C++ 编译器。</span></span><br><span class="line"><span class="keyword">project</span>(MyMinimalProject CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加一个可执行文件目标</span></span><br><span class="line"><span class="comment">#    第一个参数 &quot;my_app&quot; 是你想要生成的可执行文件的名字。</span></span><br><span class="line"><span class="comment">#    后续参数是构成这个可执行文件的源文件列表。这里只有一个 main.cpp。</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>cmake_minimum_required(VERSION 3.16)</code>：告诉 CMake 使用至少 3.16 版本的语法和功能。如果系统上的 CMake 版本低于此，它会报错。</li><li><code>project(MyMinimalProject CXX)</code>：定义项目名为 <code>MyMinimalProject</code>，并声明主要语言是 C++ (<code>CXX</code>)。这会让 CMake 检查 C++ 编译器是否可用。</li><li><code>add_executable(my_app main.cpp)</code>：指示 CMake 创建一个名为 <code>my_app</code> 的可执行文件，该文件由 <code>main.cpp</code> 编译而来。</li></ul><p><strong>构建步骤：</strong></p><ol><li>打开终端，进入 <code>my_minimal_project</code> 目录。</li><li>创建构建目录并进入：<code>mkdir build &amp;&amp; cd build</code> (推荐将构建产物与源码分开)</li><li>运行 CMake 配置：<code>cmake ..</code> ( <code>..</code> 指向包含 <code>CMakeLists.txt</code> 的上级目录)</li><li>编译项目：<code>make</code> (或者 <code>cmake --build .</code>)</li><li>运行可执行文件：<code>./my_app</code></li></ol><h2 id="2-更多源文件的处理"><a href="#2-更多源文件的处理" class="headerlink" title="2. 更多源文件的处理"></a>2. <strong>更多源文件的处理</strong></h2><p><strong>思考：</strong></p><ol><li><strong>如何告诉 <code>add_executable</code> 所有需要的 <code>.cpp</code> 文件？</strong><ul><li>直接在 <code>add_executable</code> 命令中列出所有 <code>.cpp</code> 文件？</li><li>用一个变量来存储源文件列表，然后传递给 <code>add_executable</code>？（更整洁）</li><li>让 CMake 自动查找目录下的 <code>.cpp</code> 文件？（<code>aux_source_directory</code> 或 <code>file(GLOB ...)</code>，<strong>不推荐</strong>用于源文件，因为新增&#x2F;删除文件时 CMake 可能不会自动检测到变化）</li></ul></li><li><strong>如果源文件分散在不同目录（如 <code>src/</code>），CMake 如何找到它们？</strong><ul><li>在文件名中包含相对路径（例如 <code>src/main.cpp</code>）。</li></ul></li><li><strong>如果头文件放在单独的目录（如 <code>include/</code>），编译器如何找到它们？</strong><ul><li>需要告诉 CMake 头文件的搜索路径。（<code>target_include_directories</code>）</li></ul></li></ol><p><strong>代码示例：</strong></p><p>假设项目结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_multi_file_project/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include/</span><br><span class="line">│   └── helper.h</span><br><span class="line">└── src/</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    └── helper.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>include/helper.h</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELPER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELPER_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELPER_H</span></span></span><br></pre></td></tr></table></figure><p><code>src/helper.cpp</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span> <span class="comment">// 注意这里可以直接 include，因为我们会告诉 CMake 头文件路径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Message from helper!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/main.cpp</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span> <span class="comment">// 包含我们自己的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_message</span>(); <span class="comment">// 调用来自 helper 的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(MyMultiFileProject CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 使用变量存储源文件列表 (推荐方式)</span></span><br><span class="line"><span class="comment">#    将所有需要编译的 .cpp 文件列在这里。使用相对路径。</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/helper.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加可执行文件目标，使用变量</span></span><br><span class="line"><span class="comment">#    将 $&#123;SOURCES&#125; 变量的内容展开作为源文件列表。</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_app <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 指定头文件搜索路径</span></span><br><span class="line"><span class="comment">#    告诉 CMake，当编译 my_app 这个目标时，</span></span><br><span class="line"><span class="comment">#    应该到 &quot;include&quot; 目录下查找头文件 (#include &quot;...&quot;).</span></span><br><span class="line"><span class="comment">#    PUBLIC 意味着如果其他目标链接到 my_app，它们也会自动获得这个 include 目录。</span></span><br><span class="line"><span class="comment">#    对于可执行文件，PRIVATE 通常也足够。</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>set(SOURCES ...)</code>：创建了一个名为 <code>SOURCES</code> 的 CMake 变量，存储了所有 <code>.cpp</code> 文件的列表。这比在 <code>add_executable</code> 中写一长串文件名更清晰，易于维护。</li><li><code>add_executable(my_app $&#123;SOURCES&#125;)</code>：使用 <code>$&#123;VAR_NAME&#125;</code> 语法来引用变量 <code>SOURCES</code>。</li><li><code>target_include_directories(my_app PUBLIC include)</code>：这是关键一步。它告诉编译器在编译 <code>my_app</code> 的源文件时，去 <code>include</code> 目录下查找 <code>#include</code> 的头文件。没有这一行，<code>#include &quot;helper.h&quot;</code> 会失败。<code>PUBLIC</code> 关键字表示这个包含目录不仅 <code>my_app</code> 自己用，如果将来有其他 CMake 目标链接到 <code>my_app</code>，它们也会继承这个包含目录（对于可执行文件，通常用 <code>PRIVATE</code> 即可，表示仅 <code>my_app</code> 内部使用）。</li></ul><h2 id="3-第三方库如何使用（以OpenCV为例）"><a href="#3-第三方库如何使用（以OpenCV为例）" class="headerlink" title="3.  第三方库如何使用（以OpenCV为例）"></a>3.  第三方库如何使用（以OpenCV为例）</h2><p><strong>思考：</strong></p><ol><li><strong>如何让 CMake 找到已安装的 OpenCV 库？</strong><ul><li>使用 <code>find_package</code> 命令。这是 CMake 查找外部库的标准方式。</li></ul></li><li><strong>我需要 OpenCV 的哪些部分（模块）？</strong><ul><li>OpenCV 是模块化的（如 <code>core</code>, <code>imgproc</code>, <code>highgui</code> 等）。明确指定需要的模块可以减少不必要的依赖和链接。</li><li><code>find_package</code> 允许通过 <code>COMPONENTS</code> 参数指定所需模块。</li></ul></li><li><strong><code>find_package</code> 找到库后，如何将它链接到我的目标（<code>my_app</code>）？</strong><ul><li>需要告诉 CMake 两件事：<ul><li>编译器在哪里找到 OpenCV 的头文件</li><li>链接器在哪里找到 OpenCV 的库文件并将它们链接到我的可执行文件</li></ul></li><li><strong>现代 CMake 方式（推荐）：</strong> 使用 <code>target_link_libraries</code> 配合 <code>find_package</code> 提供的 “Imported Target” (例如 <code>OpenCV::opencv_core</code>)。这种方式会自动处理头文件路径和库链接。</li><li><strong>旧式 CMake 方式（了解即可）：</strong> <code>find_package</code> 会设置一些变量（如 <code>OpenCV_INCLUDE_DIRS</code> 和 <code>OpenCV_LIBS</code>），然后手动使用 <code>target_include_directories</code> 和 <code>target_link_libraries</code>。</li></ul></li></ol><p><strong>代码示例：</strong></p><p>假设项目结构不变，我们修改 <code>main.cpp</code> 来使用 OpenCV。</p><p><code>src/main.cpp</code> (示例：读取并显示一张图片):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含 OpenCV 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;Image_Path&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_message</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图片</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(argv[<span class="number">1</span>], cv::IMREAD_COLOR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Could not read the image: &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图片</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Display window&quot;</span>, image);</span><br><span class="line">    <span class="type">int</span> k = cv::<span class="built_in">waitKey</span>(<span class="number">0</span>); <span class="comment">// 等待按键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(MyOpenCVProject CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/helper.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- OpenCV Integration ---</span></span><br><span class="line"><span class="comment"># 1. 查找 OpenCV 包</span></span><br><span class="line"><span class="comment">#    REQUIRED: 如果找不到 OpenCV，CMake 会报错停止。</span></span><br><span class="line"><span class="comment">#    COMPONENTS: 指定我们需要的模块。</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED COMPONENTS core imgcodecs highgui)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否成功找到 (可选，但推荐)</span></span><br><span class="line"><span class="keyword">if</span>(OpenCV_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Found OpenCV version: $&#123;OpenCV_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;OpenCV not found!&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># --- End OpenCV Integration ---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my_app <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Link OpenCV to the target ---</span></span><br><span class="line"><span class="comment"># 2. 将 OpenCV 链接到我们的可执行文件 (现代方式)</span></span><br><span class="line"><span class="comment">#    OpenCV 的 find_package 脚本会创建所谓的 &quot;Imported Targets&quot;。</span></span><br><span class="line"><span class="comment">#    通常格式是 `OpenCV::module_name` (例如 OpenCV::core, OpenCV::imgcodecs)。</span></span><br><span class="line"><span class="comment">#    链接这些 Imported Targets 会自动处理包含目录和库文件。</span></span><br><span class="line"><span class="comment">#    PRIVATE 表示链接的库仅 my_app 内部使用，不会传递给链接到 my_app 的其他目标。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐这样做，但我实际操作找不到</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE</span><br><span class="line">    OpenCV::core</span><br><span class="line">    OpenCV::imgcodecs</span><br><span class="line">    OpenCV::highgui</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 最后是通过这个成功运行的</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- End Link OpenCV ---</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>find_package(OpenCV REQUIRED COMPONENTS ...)</code>：指示 CMake 查找 OpenCV。<code>REQUIRED</code> 确保找不到时构建失败。<code>COMPONENTS</code> 列出了我们代码中实际用到的 OpenCV 模块 (<code>core</code> 对应 <code>cv::Mat</code>, <code>imgcodecs</code> 对应 <code>cv::imread</code>, <code>highgui</code> 对应 <code>cv::imshow</code>, <code>cv::waitKey</code>)。</li><li><code>message(STATUS ...)</code>：在 CMake 配置阶段打印信息，方便调试。</li><li><code>target_link_libraries(my_app PRIVATE OpenCV::core ...)</code>：这是最关键的一步。它将 <code>my_app</code> 链接到 <code>find_package</code> 找到的 OpenCV 模块。使用 <code>OpenCV::module_name</code> 这种 Imported Target 是现代 CMake 的推荐做法，它比旧方法更简洁、更健壮，CMake 会自动管理头文件路径 (<code>target_include_directories</code> 不需要再为 OpenCV 手动添加) 和库文件链接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—基础篇</title>
      <link href="/2025/04/24/c1/"/>
      <url>/2025/04/24/c1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-学习笔记—基础篇"><a href="#C-学习笔记—基础篇" class="headerlink" title="C++学习笔记—基础篇"></a>C++学习笔记—基础篇</h1><h2 id="1-安装最基础的编译环境"><a href="#1-安装最基础的编译环境" class="headerlink" title="1. 安装最基础的编译环境"></a>1. 安装最基础的编译环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install build-essential</span><br></pre></td></tr></table></figure><p>验证有没有装好，输出版本信息即装好了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ --version</span><br><span class="line">make --version</span><br></pre></td></tr></table></figure><h2 id="2-第一个程序"><a href="#2-第一个程序" class="headerlink" title="2. 第一个程序"></a>2. 第一个程序</h2><p>使用任意的编辑器编写一个hello.cpp然后编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure><ul><li><code>g++</code>: 调用 GNU C++ 编译器。</li><li><code>hello.cpp</code>: 你要编译的源文件。</li><li><code>o hello</code>: 这个选项告诉编译器，将生成的可执行文件命名为 <code>hello</code>。如果没有 <code>o</code> 选项，默认会生成一个名为 <code>a.out</code> 的文件。</li></ul><h2 id="3-使用-make-简化编译"><a href="#3-使用-make-简化编译" class="headerlink" title="3. 使用 make 简化编译"></a>3. <strong>使用 <code>make</code> 简化编译</strong></h2><p>如果项目比较复杂的话，只通过命令编译就会很长</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp math_utils.cpp -o my_calc -Wall -Wextra -std=c++11</span><br></pre></td></tr></table></figure><p><code>make</code> 通过 <code>Makefile</code> 文件来解决手动编译的许多问题</p><p>创建一个 <code>Makefile</code> 文件然后通过 <code>make</code> 命令就可以自动的编译（过程省略）但是 <code>Makefile</code> 文件不是很好写</p><h2 id="4-使用-CMake"><a href="#4-使用-CMake" class="headerlink" title="4. 使用 CMake"></a>4. <strong>使用 <code>CMake</code></strong></h2><p><code>CMake</code> 作为构建系统生成器，解决了 <code>make</code> 的许多局限性，尤其是在跨平台和管理复杂性方面。</p><ol><li><p><strong>创建 <code>CMakeLists.txt</code>:</strong> 在 <code>calculator</code> 目录下创建 <code>CMakeLists.txt</code> 文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称和语言</span></span><br><span class="line"><span class="keyword">project</span>(Calculator LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 C++ 标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (可选) 添加编译选项，会传递给编译器</span></span><br><span class="line"><span class="comment"># add_compile_options(-Wall -Wextra) # 或者更现代的方式如下：</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(my_calc INTERFACE -Wall -Wextra) <span class="comment"># 应用于 my_calc 及其使用者</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件目标</span></span><br><span class="line"><span class="comment"># CMake 会自动分析 main.cpp 和 math_utils.cpp 之间的依赖</span></span><br><span class="line"><span class="comment"># 以及它们对 math_utils.h 的依赖</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_calc main.cpp math_utils.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果头文件在 include 目录:</span></span><br><span class="line"><span class="comment"># target_include_directories(my_calc PRIVATE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>操作 (Out-of-Source Build):</strong></p><ul><li><p><strong>创建构建目录并进入:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure></li><li><p>**运行 CMake (配置阶段):**CMake 会读取 <code>../CMakeLists.txt</code>，检测你的编译器，并生成一个 <code>Makefile</code> (或其他本地构建系统文件) 在 <code>build</code> 目录中。它会自动处理 <code>main.cpp</code> 对 <code>math_utils.h</code> 的依赖。</p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure></li><li><p><strong>运行构建工具 (构建阶段):</strong><code>make</code> 会使用 CMake 生成的 <code>Makefile</code> 来编译项目。可执行文件 <code>my_calc</code> 会出现在 <code>build</code> 目录。</p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p><strong>运行:</strong></p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_calc</span><br></pre></td></tr></table></figure></li><li><p><strong>清理:</strong></p><ul><li>可以使用 <code>make clean</code> (由 CMake 生成的 <code>Makefile</code> 提供)。</li><li>或者更彻底地，删除整个 <code>build</code> 目录：<code>cd .. &amp;&amp; rm -rf build</code>。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git学习记录</title>
      <link href="/2025/04/22/git/"/>
      <url>/2025/04/22/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><hr><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>在官方网站安装: <a href="https://git-scm.com/">https://git-scm.com/</a></p><hr><h2 id="2-初始化配置"><a href="#2-初始化配置" class="headerlink" title="2. 初始化配置"></a>2. 初始化配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置全局用户名和邮箱</span></span><br><span class="line">git config --global user.name <span class="string">&quot;name&quot;</span></span><br><span class="line">git config --global user.email xxxx@gmail.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 凭证存储</span></span><br><span class="line"><span class="comment"># 第一次通过 HTTPS 方式 push 或 pull 时，Git 会要求输入用户名和密码</span></span><br><span class="line"><span class="comment"># （或 Personal Access Token）。操作成功后，&quot;store&quot; 会把凭证以明文格式写入文件</span></span><br><span class="line"><span class="comment"># 以后再访问同一个远程仓库时，Git 会自动读取凭证，不再重复询问</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置默认分支，现在推荐使用main</span></span><br><span class="line">git config --global init.defaultBranch main</span><br></pre></td></tr></table></figure><hr><h2 id="3-创建一个新仓库"><a href="#3-创建一个新仓库" class="headerlink" title="3. 创建一个新仓库"></a>3. 创建一个新仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 初始化本地仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 克隆远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;仓库URL&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="4-工作区域和文件状态"><a href="#4-工作区域和文件状态" class="headerlink" title="4. 工作区域和文件状态"></a>4. 工作区域和文件状态</h2><h3 id="Git中的三种工作区域"><a href="#Git中的三种工作区域" class="headerlink" title="Git中的三种工作区域"></a>Git中的三种工作区域</h3><ol><li><p><strong>工作区</strong>(.git所在目录)</p><ul><li>在资源管理器中看到的目录</li></ul></li><li><p><strong>暂存区</strong>(.git&#x2F;index)</p><ul><li>用于保存即将提交到Git仓库的修改内容</li></ul></li><li><p><strong>本地仓库</strong>(.git&#x2F;objects)</p><ul><li>Git存储代码和版本信息的主要位置</li></ul></li></ol><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423151837456.png" alt="工作区域"></p><h3 id="Git中的四种文件状态"><a href="#Git中的四种文件状态" class="headerlink" title="Git中的四种文件状态"></a>Git中的四种文件状态</h3><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423153227238.png" alt="文件状态"></p><hr><h2 id="5-添加和提交文件"><a href="#5-添加和提交文件" class="headerlink" title="5. 添加和提交文件"></a>5. 添加和提交文件</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h3><p>查看仓库的状态</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><code>git add</code></h3><p>将文件添加到暂存区</p><ul><li>可以使用通配符：<code>git add *.txt</code></li><li>也可以使用目录：<code>git add .</code></li></ul><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h3><p>提交到本地仓库</p><ul><li>只提交<strong>暂存区</strong>中的内容，不会提交<strong>工作区</strong>中的内容</li></ul><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h3><p>查看仓库提交历史记录</p><ul><li>使用 <code>--oneline</code> 参数查看简洁的提交记录</li></ul><h3 id="git-ls-files"><a href="#git-ls-files" class="headerlink" title="git ls-files"></a><code>git ls-files</code></h3><p>查看暂存区的内容</p><hr><h2 id="6-git-reset回退版本"><a href="#6-git-reset回退版本" class="headerlink" title="6. git reset回退版本"></a>6. git reset回退版本</h2><h3 id="Git-reset的三种模式"><a href="#Git-reset的三种模式" class="headerlink" title="Git reset的三种模式"></a>Git reset的三种模式</h3><ul><li><p><code>git reset --soft</code> </p><ul><li>回退到某个版本，保留工作区和暂存区的所有内容</li></ul></li><li><p><code>git reset --hard</code> </p><ul><li>回退到某个版本，丢弃工作区和暂存区的所有内容</li></ul></li><li><p><code>git reset --mixed</code> (默认参数)</p><ul><li>回退到某个版本，保留工作区的内容，丢弃暂存区的内容</li></ul></li></ul><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423155650856.png" alt="Git reset模式"></p><hr><h2 id="7-使用git-diff查看差异"><a href="#7-使用git-diff查看差异" class="headerlink" title="7. 使用git diff查看差异"></a>7. 使用git diff查看差异</h2><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a><code>git diff</code></h3><p>比较：<strong>工作区</strong> 🆚 <strong>暂存区</strong></p><h3 id="git-diff-HEAD"><a href="#git-diff-HEAD" class="headerlink" title="git diff HEAD"></a><code>git diff HEAD</code></h3><p>比较：<strong>工作区 + 暂存区</strong> 🆚 <strong>本地仓库</strong></p><h3 id="git-diff-cached-git-diff-staged"><a href="#git-diff-cached-git-diff-staged" class="headerlink" title="git diff --cached &#x2F; git diff --staged"></a><code>git diff --cached</code> &#x2F; <code>git diff --staged</code></h3><p>比较：<strong>暂存区</strong> 🆚 <strong>本地仓库</strong></p><h3 id="git-diff-1"><a href="#git-diff-1" class="headerlink" title="git diff &lt;commit_hash&gt; &lt;commit_hash&gt;"></a><code>git diff &lt;commit_hash&gt; &lt;commit_hash&gt;</code></h3><h3 id="git-diff-HEAD-HEAD"><a href="#git-diff-HEAD-HEAD" class="headerlink" title="git diff HEAD~ HEAD"></a><code>git diff HEAD~ HEAD</code></h3><p>比较两个**提交（commit）**之间的差异</p><h3 id="git-diff-2"><a href="#git-diff-2" class="headerlink" title="git diff &lt;branch_name&gt; &lt;branch_name&gt;"></a><code>git diff &lt;branch_name&gt; &lt;branch_name&gt;</code></h3><p>比较两个<strong>分支</strong>之间的差异</p><hr><h2 id="8-Git-删除文件命令"><a href="#8-Git-删除文件命令" class="headerlink" title="8. Git 删除文件命令"></a>8. Git 删除文件命令</h2><h3 id="rm-file-git-add-file"><a href="#rm-file-git-add-file" class="headerlink" title="rm file; git add file"></a><code>rm file; git add file</code></h3><ul><li>先从<strong>工作区</strong>删除文件</li><li>然后使用 <code>git add</code> 让 Git 追踪这次删除（即加入暂存区）</li></ul><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm &lt;file&gt;"></a><code>git rm &lt;file&gt;</code></h3><ul><li>同时从<strong>工作区</strong>和<strong>暂存区</strong>删除文件</li></ul><h3 id="git-rm-cached"><a href="#git-rm-cached" class="headerlink" title="git rm --cached &lt;file&gt;"></a><code>git rm --cached &lt;file&gt;</code></h3><ul><li><strong>只从暂存区删除</strong>文件，但保留工作区中的文件（文件依然存在本地）</li></ul><h3 id="git-rm-r"><a href="#git-rm-r" class="headerlink" title="git rm -r *"></a><code>git rm -r *</code></h3><ul><li><strong>递归删除</strong>当前目录及子目录下的所有文件和文件夹</li></ul><blockquote><p><strong>提示</strong>：删除文件后记得使用 <code>git commit</code> 提交更改！</p></blockquote><hr><h2 id="9-gitignore忽略文件"><a href="#9-gitignore忽略文件" class="headerlink" title="9. gitignore忽略文件"></a>9. gitignore忽略文件</h2><h3 id="常见忽略文件列表"><a href="#常见忽略文件列表" class="headerlink" title="常见忽略文件列表"></a>常见忽略文件列表</h3><ul><li>忽略日志文件和日志目录</li><li>忽略所有 <code>.class</code> 文件</li><li>忽略所有 <code>.o</code> 文件（编译生成的中间文件）</li><li>忽略所有 <code>.env</code> 文件（包含环境变量配置）</li><li>忽略所有 <code>.zip</code> 和 <code>.tar</code> 压缩包</li><li>忽略所有 <code>.pem</code> 文件（安全凭证）</li></ul><h3 id="一般应该忽略的文件类型"><a href="#一般应该忽略的文件类型" class="headerlink" title="一般应该忽略的文件类型"></a>一般应该忽略的文件类型</h3><ul><li><strong>系统或软件自动生成的文件</strong></li><li><strong>编译产生的中间文件和结果文件</strong></li><li><strong>运行时生成的日志、缓存、临时文件</strong></li><li><strong>涉及身份、密码、口令、秘钥等敏感信息的文件</strong></li></ul><h3 id="示例-gitignore-文件内容"><a href="#示例-gitignore-文件内容" class="headerlink" title="示例 .gitignore 文件内容"></a>示例 <code>.gitignore</code> 文件内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 日志文件</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># 编译输出</span><br><span class="line">*.class</span><br><span class="line">*.o</span><br><span class="line"></span><br><span class="line"># 环境变量</span><br><span class="line">.env</span><br><span class="line"></span><br><span class="line"># 压缩包</span><br><span class="line">*.zip</span><br><span class="line">*.tar</span><br><span class="line"></span><br><span class="line"># 安全证书等敏感信息</span><br><span class="line">*.pem</span><br></pre></td></tr></table></figure><hr><h2 id="10-SSH配置"><a href="#10-SSH配置" class="headerlink" title="10. SSH配置"></a>10. SSH配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 回到根目录</span></span><br><span class="line"><span class="built_in">cd</span> ~ 或者 <span class="built_in">cd</span> 直接回车</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入ssh文件夹</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 生成ssh密钥</span></span><br><span class="line">ssh-keygen -t rsa -b 4096</span><br><span class="line"><span class="comment"># -t代表协议为rsa</span></span><br><span class="line"><span class="comment"># -b代表生成大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 回车后提醒输入密钥名称</span></span><br><span class="line"><span class="comment"># 如果是第一次使用这个命令，直接回车就行了，使用默认的名称id_rsa</span></span><br><span class="line"><span class="comment"># 如果之前用过最好不要直接回车，会覆盖掉之前的密钥，且操作不可逆</span></span><br><span class="line"><span class="comment"># 输入一个新的名字例如test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 再回车后提醒输入密码，可以为空直接回车</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 可以看到本地生成了两个文件，一个密钥，一个密钥.pub</span></span><br><span class="line"><span class="comment"># 私钥文件谁都不要给，公钥打开复制到github</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 点开头像-设置-ssh和gpg密钥配置--new ssh key --然后起个名字将公钥粘贴进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 如果是第一次配置默认的名称，到此就结束了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 如果是自己命名的密钥</span></span><br><span class="line"><span class="comment"># 打开 ~/.ssh/config 文件，如果没有就创建，如果有就附加在后面</span></span><br><span class="line"><span class="comment"># 填入</span></span><br><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/test</span><br><span class="line"><span class="comment"># 意思是访问github时指定访问test密钥</span></span><br></pre></td></tr></table></figure><h3 id="SSH通过HTTPS端口连接GitHub-解决网络问题"><a href="#SSH通过HTTPS端口连接GitHub-解决网络问题" class="headerlink" title="SSH通过HTTPS端口连接GitHub (解决网络问题)"></a>SSH通过HTTPS端口连接GitHub (解决网络问题)</h3><p>当无法通过SSH默认端口访问GitHub时，可以通过HTTPS端口(443)绕过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑SSH配置文件</span></span><br><span class="line">nano ~/.ssh/config</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">vim ~/.ssh/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下配置</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName ssh.github.com</span><br><span class="line">    Port 443</span><br><span class="line">    User git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试连接</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># 成功会显示：Hi username! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在可以正常克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:Git-xfy/remote-repo.git</span><br></pre></td></tr></table></figure><p><strong>这种方法有效的原因</strong>:</p><ol><li>许多公司和网络环境会阻止SSH的标准端口(22)，但允许HTTPS端口(443)</li><li>这种方法仍使用SSH协议及其安全特性和密钥认证</li><li>通信通过通常允许的HTTPS端口传输，从而绕过防火墙限制</li></ol><hr><h2 id="11-关联本地仓库和远程仓库"><a href="#11-关联本地仓库和远程仓库" class="headerlink" title="11. 关联本地仓库和远程仓库"></a>11. 关联本地仓库和远程仓库</h2><h3 id="git-remote-add"><a href="#git-remote-add" class="headerlink" title="git remote add &lt;shortname&gt; &lt;url&gt;"></a><code>git remote add &lt;shortname&gt; &lt;url&gt;</code></h3><ul><li>shortname - 起一个短名字，一般都是origin</li><li>url - 要关联的远程仓库地址</li></ul><h3 id="git-remote-v"><a href="#git-remote-v" class="headerlink" title="git remote -v"></a><code>git remote -v</code></h3><p>查看当前仓库所对应的远程仓库的别名和地址</p><h3 id="git-branch-M-main"><a href="#git-branch-M-main" class="headerlink" title="git branch -M main"></a><code>git branch -M main</code></h3><p>将本地仓库当前分支命名为main</p><ul><li>GitHub默认的主分支名称是main，而本地分支有时候默认是master</li><li>如果已经设置过默认分支为main，则不需要此操作</li></ul><h3 id="git-push-u-origin-main"><a href="#git-push-u-origin-main" class="headerlink" title="git push -u origin main"></a><code>git push -u origin main</code></h3><p>把本地分支和远程分支的main关联起来</p><ul><li>全称是<code>git push -u origin main:main</code></li><li>将本地的main分支（冒号前）与远程main分支（冒号后）关联起来</li><li>名称一样可以省略一个</li></ul><h3 id="简化命令"><a href="#简化命令" class="headerlink" title="简化命令"></a>简化命令</h3><ul><li>关联后可以直接使用 <code>git push</code></li><li>未关联则需使用 <code>git push &lt;remote_name&gt; &lt;local_branch_name&gt;:&lt;remote_branch_name&gt;</code></li></ul><h3 id="拉取命令"><a href="#拉取命令" class="headerlink" title="拉取命令"></a>拉取命令</h3><ul><li>关联后：<code>git pull</code></li><li>未关联：<code>git pull &lt;remote_name&gt; &lt;local_branch_name&gt;:&lt;remote_branch_name&gt;</code></li><li>省略时默认拉取origin的main分支</li><li><code>git pull</code> 会自动合并，如有冲突需解决</li><li><code>git fetch</code> 是获取后不自动合并</li></ul><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423170207574.png" alt="拉取示意图"></p><hr><h2 id="12-分支的基本操作"><a href="#12-分支的基本操作" class="headerlink" title="12. 分支的基本操作"></a>12. 分支的基本操作</h2><h3 id="查看分支列表"><a href="#查看分支列表" class="headerlink" title="查看分支列表"></a>查看分支列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统方式</span></span><br><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐方式（Git 2.23+）</span></span><br><span class="line">git switch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><ul><li><strong>已合并的分支</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>未合并的分支</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：分支操作前，建议先查看当前分支状态：<code>git status</code>。合并前确保工作区干净，删除前确认无误。</p></blockquote><hr><h2 id="13-解决合并冲突"><a href="#13-解决合并冲突" class="headerlink" title="13. 解决合并冲突"></a>13. 解决合并冲突</h2><h3 id="冲突说明"><a href="#冲突说明" class="headerlink" title="冲突说明"></a>冲突说明</h3><ul><li><strong>若两个分支修改了同一个文件的不同位置</strong> → Git会自动合并 ✓</li><li><strong>若两个分支修改了同一个文件的相同位置</strong> → 发生冲突 ✗</li></ul><h3 id="解决冲突步骤"><a href="#解决冲突步骤" class="headerlink" title="解决冲突步骤"></a>解决冲突步骤</h3><ol><li><strong>手动修改冲突文件</strong>，处理冲突内容</li><li><strong>添加到暂存区</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><strong>提交更改</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;解决合并冲突&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="中止合并操作"><a href="#中止合并操作" class="headerlink" title="中止合并操作"></a>中止合并操作</h3><p>如果不想继续合并，可使用以下命令中止合并过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：合并冲突发生时，Git会标记冲突区域（如 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>），你需要手动选择保留哪一部分内容。</p></blockquote><hr><h2 id="14-回退和Rebase"><a href="#14-回退和Rebase" class="headerlink" title="14. 回退和Rebase"></a>14. 回退和Rebase</h2><h3 id="Git-Rebase（变基）"><a href="#Git-Rebase（变基）" class="headerlink" title="Git Rebase（变基）"></a>Git Rebase（变基）</h3><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>将当前分支的提交”转移”到目标分支的最新提交之后，<strong>重写提交历史</strong>。</p><h3 id="Rebase-vs-Merge-区别"><a href="#Rebase-vs-Merge-区别" class="headerlink" title="Rebase vs Merge 区别"></a>Rebase vs Merge 区别</h3><table><thead><tr><th>比较项</th><th><code>git merge</code></th><th><code>git rebase</code></th></tr></thead><tbody><tr><td>历史记录</td><td>保留分支历史，产生合并提交</td><td>重写提交历史，线性、干净</td></tr><tr><td>可读性</td><td>可能出现分叉，历史分支交错</td><td>历史更线性，便于回顾</td></tr><tr><td>是否生成新提交</td><td>会生成一个合并提交</td><td>不会生成合并提交，重用原提交</td></tr><tr><td>冲突处理</td><td>只处理一次冲突</td><td>每次变基提交可能都需手动解决冲突</td></tr></tbody></table><h3 id="什么时候用什么？"><a href="#什么时候用什么？" class="headerlink" title="什么时候用什么？"></a>什么时候用什么？</h3><ul><li><p><strong>使用 <code>merge</code></strong>：</p><ul><li>团队协作中保留分支历史</li><li>避免修改提交历史</li><li>合并已推送的公共分支</li></ul></li><li><p><strong>使用 <code>rebase</code></strong>：</p><ul><li>自己在本地整理提交历史</li><li>保持提交历史简洁、线性</li><li>合并前清理开发分支历史，提升可读性</li></ul></li></ul><blockquote><p><strong>小提示</strong>：</p><ul><li><code>rebase</code> 更适合<strong>个人分支开发阶段</strong></li><li><code>merge</code> 更适合<strong>团队协作与主分支合并</strong></li><li>注意：不要对已经推送到远程的公共分支使用 <code>rebase</code>，可能导致历史冲突！</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
