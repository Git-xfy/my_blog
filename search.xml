<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>orbslam2</title>
      <link href="/2025/04/30/orbslam2/"/>
      <url>/2025/04/30/orbslam2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Docker-容器创建"><a href="#一、Docker-容器创建" class="headerlink" title="一、Docker 容器创建"></a>一、Docker 容器创建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -dit \</span><br><span class="line">--gpus all \</span><br><span class="line">-e NVIDIA_DRIVER_CAPABILITIES=all \</span><br><span class="line">--name=orbslam2 \</span><br><span class="line">--privileged  \</span><br><span class="line">-v /dev:/dev \</span><br><span class="line">-v /home/xfy/docker_practice/orbslam2Base20.04:/home/docker \</span><br><span class="line">-v /tmp/.X11-unix:/tmp/.X11-unix  \</span><br><span class="line">-e DISPLAY=unix<span class="variable">$DISPLAY</span> \</span><br><span class="line">-w /home \</span><br><span class="line">--net=host \</span><br><span class="line">ubuntu:20.04</span><br></pre></td></tr></table></figure><h2 id="二、Ubuntu-源配置"><a href="#二、Ubuntu-源配置" class="headerlink" title="二、Ubuntu 源配置"></a>二、Ubuntu 源配置</h2><ol><li><p>安装 vim</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install vim</span><br></pre></td></tr></table></figure></li><li><p>备份原始源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.backup</span><br></pre></td></tr></table></figure></li><li><p>编辑源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># gg dG 移动到文件第一行并删除所有内容</span></span><br><span class="line"><span class="comment"># i进入编辑模式</span></span><br><span class="line"><span class="comment"># 编辑完esc退出到普通模式，：进入命令行模式输入wq保存并退出</span></span><br></pre></td></tr></table></figure></li><li><p>替换为阿里云源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"># deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、安装基础开发工具"><a href="#三、安装基础开发工具" class="headerlink" title="三、安装基础开发工具"></a>三、安装基础开发工具</h2><ol><li><p>安装 build-essential</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install build-essential</span><br></pre></td></tr></table></figure></li><li><p>安装新版本的 git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install -y software-properties-common</span><br><span class="line">add-apt-repository -y ppa:git-core/ppa</span><br><span class="line">apt update</span><br><span class="line">apt install -y git</span><br></pre></td></tr></table></figure></li><li><p>安装新版本的 cmake</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install -y apt-transport-https ca-certificates gnupg wget</span><br><span class="line">wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2&gt;/dev/null | gpg --dearmor - | <span class="built_in">tee</span> /etc/apt/trusted.gpg.d/kitware.gpg &gt;/dev/null</span><br><span class="line">apt-add-repository <span class="string">&quot;deb https://apt.kitware.com/ubuntu/ <span class="subst">$(lsb_release -cs)</span> main&quot;</span></span><br><span class="line">apt update</span><br><span class="line"><span class="comment"># apt install -y cmake  # 这会安装4.*版本的cmake</span></span><br><span class="line">apt install cmake=3.29.6-*</span><br></pre></td></tr></table></figure></li></ol><h2 id="四、安装-ORB-SLAM2-所需第三方库"><a href="#四、安装-ORB-SLAM2-所需第三方库" class="headerlink" title="四、安装 ORB-SLAM2 所需第三方库"></a>四、安装 ORB-SLAM2 所需第三方库</h2><h3 id="1-安装-Pangolin-0-6"><a href="#1-安装-Pangolin-0-6" class="headerlink" title="1. 安装 Pangolin 0.6"></a>1. 安装 Pangolin 0.6</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 https://github.com/stevenlovegrove/Pangolin/releases 下载安装包</span></span><br><span class="line">tar -xzf Pangolin-0.6.tar.gz</span><br><span class="line"><span class="comment"># 安装 Pangolin 依赖</span></span><br><span class="line">apt install libgl1-mesa-dev</span><br><span class="line">apt install libglew-dev</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="2-安装-Eigen-3-3-8"><a href="#2-安装-Eigen-3-3-8" class="headerlink" title="2. 安装 Eigen 3.3.8"></a>2. 安装 Eigen 3.3.8</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf eigen-3.3.8.tar.gz</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make install</span><br><span class="line"><span class="comment"># eigen不需要执行make</span></span><br></pre></td></tr></table></figure><h3 id="3-安装-Boost"><a href="#3-安装-Boost" class="headerlink" title="3. 安装 Boost"></a>3. 安装 Boost</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install libboost-all-dev</span><br></pre></td></tr></table></figure><h3 id="4-安装-libssl-dev"><a href="#4-安装-libssl-dev" class="headerlink" title="4. 安装 libssl-dev"></a>4. 安装 libssl-dev</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install libssl-dev</span><br></pre></td></tr></table></figure><h3 id="5-安装-OpenCV-4-6"><a href="#5-安装-OpenCV-4-6" class="headerlink" title="5. 安装 OpenCV 4.6"></a>5. 安装 OpenCV 4.6</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 OpenCV 依赖</span></span><br><span class="line">apt install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg-dev libtiff5-dev libswscale-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 OpenCV</span></span><br><span class="line">apt install unzip</span><br><span class="line">unzip opencv-4.6.0.zip  <span class="comment"># 假设压缩包名称</span></span><br><span class="line"><span class="built_in">cd</span> opencv-4.6.0</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j6</span><br></pre></td></tr></table></figure><h2 id="五、克隆并编译-ORB-SLAM2"><a href="#五、克隆并编译-ORB-SLAM2" class="headerlink" title="五、克隆并编译 ORB-SLAM2"></a>五、克隆并编译 ORB-SLAM2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆有详细注释的版本</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/electech6/ORB_SLAM2_detailed_comments.git</span><br></pre></td></tr></table></figure><h3 id="1-编译-DBoW2-ORB-SLAM2-自带-无需make-install"><a href="#1-编译-DBoW2-ORB-SLAM2-自带-无需make-install" class="headerlink" title="1. 编译 DBoW2 (ORB-SLAM2 自带)无需make install"></a>1. 编译 DBoW2 (ORB-SLAM2 自带)无需make install</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ORB_SLAM2_detailed_comments/Thirdparty/DBoW2</span><br><span class="line"><span class="comment"># 先修改 CMakeLists.txt 中的 OpenCV 依赖版本为 4</span></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="2-编译-g2o-ORB-SLAM2-自带-无需make-install"><a href="#2-编译-g2o-ORB-SLAM2-自带-无需make-install" class="headerlink" title="2. 编译 g2o (ORB-SLAM2 自带)无需make install"></a>2. 编译 g2o (ORB-SLAM2 自带)无需make install</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ORB_SLAM2_detailed_comments/Thirdparty/g2o</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h2 id="六、常见问题及解决方案"><a href="#六、常见问题及解决方案" class="headerlink" title="六、常见问题及解决方案"></a>六、常见问题及解决方案</h2><h3 id="问题1-opencv-cv-h-头文件缺失"><a href="#问题1-opencv-cv-h-头文件缺失" class="headerlink" title="问题1: opencv&#x2F;cv.h 头文件缺失"></a>问题1: opencv&#x2F;cv.h 头文件缺失</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: opencv/cv.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>: 修改 ORBextractor.h</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将</span></span><br><span class="line"><span class="comment">#include &lt;opencv/cv.h&gt;</span></span><br><span class="line"><span class="comment"># 换成</span></span><br><span class="line"><span class="comment">#include &lt;opencv2/imgproc/imgproc_c.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;opencv2/highgui/highgui_c.h&gt;</span></span><br></pre></td></tr></table></figure><h3 id="问题2-std-map-类型错误"><a href="#问题2-std-map-类型错误" class="headerlink" title="问题2: std::map 类型错误"></a>问题2: std::map 类型错误</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/c++/9/bits/stl_map.h:122:71: error: static assertion failed: std::map must have the same value_type as its allocator</span><br><span class="line">static_assert(is_same&lt;typename _Alloc::value_type, value_type&gt;::value,</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>: 修改 LoopClosing.h 第49行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将</span></span><br><span class="line">typedef map&lt;KeyFrame*,g2o::Sim3,std::less&lt;KeyFrame*&gt;,</span><br><span class="line">    Eigen::aligned_allocator&lt;std::pair&lt;const KeyFrame*, g2o::Sim3&gt; &gt; &gt; KeyFrameAndPose;</span><br><span class="line"><span class="comment"># 改成</span></span><br><span class="line">typedef map&lt;KeyFrame*,g2o::Sim3,std::less&lt;KeyFrame*&gt;,</span><br><span class="line">    Eigen::aligned_allocator&lt;std::pair&lt;KeyFrame* const, g2o::Sim3&gt; &gt; &gt; KeyFrameAndPose;</span><br></pre></td></tr></table></figure><h3 id="问题3-5-CV-LOAD-IMAGE-UNCHANGED-未定义"><a href="#问题3-5-CV-LOAD-IMAGE-UNCHANGED-未定义" class="headerlink" title="问题3-5: CV_LOAD_IMAGE_UNCHANGED 未定义"></a>问题3-5: CV_LOAD_IMAGE_UNCHANGED 未定义</h3><p><strong>解决方法</strong>: 在相关文件中替换 OpenCV 常量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有 CV_LOAD_IMAGE_UNCHANGED 替换为 cv::IMREAD_UNCHANGED</span></span><br><span class="line"><span class="comment"># 需要修改的文件包括：</span></span><br><span class="line"><span class="comment"># - tum.cc</span></span><br><span class="line"><span class="comment"># - stereo_kitti.cc</span></span><br><span class="line"><span class="comment"># - stereo_euroc.cc</span></span><br><span class="line"><span class="comment"># 以及其他类似文件</span></span><br></pre></td></tr></table></figure><h2 id="七、测试安装结果"><a href="#七、测试安装结果" class="headerlink" title="七、测试安装结果"></a>七、测试安装结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压词汇表</span></span><br><span class="line"><span class="built_in">cd</span> ORB_SLAM2_detailed_comments/Vocabulary</span><br><span class="line">tar -xzf ORBvoc.txt.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 TUM 数据集，从官网下载并使用 associate.py 生成 associate.txt 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行测试</span></span><br><span class="line">/home/orbslam/ORB_SLAM2_detailed_comments/Examples/RGB-D/rgbd_tum \</span><br><span class="line">/home/orbslam/ORB_SLAM2_detailed_comments/Vocabulary/ORBvoc.txt \</span><br><span class="line">/home/orbslam/ORB_SLAM2_detailed_comments/Examples/RGB-D/TUM3.yaml \</span><br><span class="line">/home/docker/rgbd_dataset_freiburg3_sitting_static \</span><br><span class="line">/home/docker/rgbd_dataset_freiburg3_sitting_static/associate.txt</span><br></pre></td></tr></table></figure><p>如果运行成功，说明 ORB-SLAM2 安装配置已完成。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令</title>
      <link href="/2025/04/30/docker2/"/>
      <url>/2025/04/30/docker2/</url>
      
        <content type="html"><![CDATA[<h3 id="镜像管理-Image-Management"><a href="#镜像管理-Image-Management" class="headerlink" title="镜像管理 (Image Management)"></a>镜像管理 (Image Management)</h3><ul><li><code>docker image ls</code> &#x2F; <code>docker images</code>: 查看镜像</li><li><code>docker search [image]</code>: 检索镜像<ul><li><code>eg. docker search nginx</code></li></ul></li><li><code>docker pull [image]</code>: 拉取镜像</li><li><code>docker push [image]</code>: 上传镜像<ul><li><code>eg. docker push geekhour/hello-docker:latest</code></li></ul></li><li><code>docker save [image] -o FILE</code> &#x2F; <code>docker save [image] &gt; FILE</code>: 保存镜像<ul><li><code>eg. docker save geekhour/hello-docker:latest &gt; hello-docker.tar</code></li></ul></li><li><code>docker load -i FILE</code>: 导入镜像<ul><li><code>eg. docker load -i hello-docker.tar</code></li></ul></li><li><code>docker history [image]</code>: 查看镜像历史</li><li><code>docker rmi [image]</code> &#x2F; <code>docker image rm [image]</code>: 删除镜像</li><li><code>docker image prune</code>: 删除不再使用的镜像</li><li><code>docker import [URL/FILE]</code>: 将文件系统导入为镜像</li><li><code>docker commit [container] [image]</code>: 从容器创建镜像</li></ul><h3 id="容器管理-Container-Management"><a href="#容器管理-Container-Management" class="headerlink" title="容器管理 (Container Management)"></a>容器管理 (Container Management)</h3><ul><li><code>docker create [image]</code>: 创建容器 (仅创建, 不运行)</li><li><code>docker run [image]</code>: 创建并运行容器</li><li><code>docker start [container]</code>: 启动容器</li><li><code>docker stop [container]</code>: 停止容器</li><li><code>docker restart [container]</code>: 重启容器</li><li><code>docker ps</code> &#x2F; <code>docker container ls</code>: 列出正在运行的容器</li><li><code>docker ps -a</code> &#x2F; <code>docker container ls -a</code>: 列出所有容器</li><li><code>docker exec -it [container] bash</code> &#x2F; <code>docker attach [container]</code>: 以交互模式进入容器</li><li><code>docker export [container] -o FILE</code> &#x2F; <code>docker export [container] &gt; FILE</code>: 导出容器</li><li><code>docker import FILE</code>: 导入容器快照</li><li><code>docker logs [container]</code>: 查看容器日志</li><li><code>docker rm [container]</code> &#x2F; <code>docker container rm [container]</code>: 删除容器</li><li><code>docker port [container]</code>: 查看容器端口映射</li><li><code>docker top [container]</code>: 显示容器内进程</li><li><code>docker cp [FILE] [container]:[PATH]</code>: 复制本地文件到容器内的指定路径</li><li><code>docker diff [container]</code>: 显示容器内的变化</li><li><code>docker stats [container]</code>: 显示容器资源使用情况</li></ul><h3 id="容器运行-Container-Run"><a href="#容器运行-Container-Run" class="headerlink" title="容器运行 (Container Run)"></a>容器运行 (Container Run)</h3><ul><li><strong>语法格式</strong>: <code>docker run [options] image [command] [arg...]</code></li><li><code>docker run --name [name] [image]</code>: 创建运行并命名容器</li><li><code>docker run -d [image]</code>: 创建一个容器并后台运行</li><li><code>docker run -p [hostPort]:[containerPort] [image]</code>: 创建一个容器并指定端口映射</li><li><code>docker run -P [image]</code>: 创建一个容器并指定端口映射 (随机分配)</li><li><code>docker run -e [key=value] [image]</code>: 创建一个容器并指定环境变量</li><li><code>docker run -w [PATH] [image]</code>: 创建一个容器并指定工作目录</li><li><code>docker run [image] [command]</code>: 创建一个容器并在容器中执行命令 (交互模式)</li><li><code>docker run -d -p [hostPort]:[containerPort] -e [key=value] -w [PATH] --name [name] [image]</code>: 创建一个容器, 并指定容器名称、后台运行、端口映射、环境变量和工作目录<ul><li><code>eg. docker run -it nginx:latest /bin/bash</code>: 使用镜像 nginx:latest 来启动一个容器, 并在容器内执行交互式 bash shell</li><li><code>eg. docker run -it -p 3316:3306 -v /data:/data -d mysql:latest</code>: 创建一个 mysql 容器, 后台模式启动, 主机 3316 端口映射到容器 3306 端口, 主机 &#x2F;data 目录映射到容器 &#x2F;data 目录</li></ul></li></ul><h3 id="网络管理-Network-Management"><a href="#网络管理-Network-Management" class="headerlink" title="网络管理 (Network Management)"></a>网络管理 (Network Management)</h3><ul><li><code>docker network ls</code>: 列出可用网络</li><li><code>docker network inspect [network]</code>: 查看网络详细信息</li><li><code>docker network create [network]</code>: 创建一个新的网络</li><li><code>docker network rm [network]</code>: 删除一个网络</li><li><code>docker network connect [network] [container]</code>: 将容器连接到网络</li><li><code>docker network disconnect [network] [container]</code>: 将容器从网络断开</li></ul><h3 id="数据卷管理-Volume-Management"><a href="#数据卷管理-Volume-Management" class="headerlink" title="数据卷管理 (Volume Management)"></a>数据卷管理 (Volume Management)</h3><ul><li><code>docker volume create [volume]</code>: 创建一个数据卷</li><li><code>docker volume ls</code>: 查看数据卷</li><li><code>docker volume inspect [volume]</code>: 查看数据卷详细信息</li><li><code>docker volume rm [volume]</code>: 删除数据卷</li><li><code>docker volume prune</code>: 删除所有未使用的数据卷</li></ul><h3 id="插件管理-Plugin-Management"><a href="#插件管理-Plugin-Management" class="headerlink" title="插件管理 (Plugin Management)"></a>插件管理 (Plugin Management)</h3><ul><li><code>docker plugin ls</code>: 列出插件</li><li><code>docker plugin install [plugin]</code>: 安装插件</li><li><code>docker plugin enable [plugin]</code>: 启用插件</li><li><code>docker plugin disable [plugin]</code>: 禁用插件</li><li><code>docker plugin rm [plugin]</code>: 卸载插件</li></ul><h3 id="日常操作-Daily-Operations"><a href="#日常操作-Daily-Operations" class="headerlink" title="日常操作 (Daily Operations)"></a>日常操作 (Daily Operations)</h3><ul><li><code>docker info</code>: 查看 docker 系统信息</li><li><code>docker version</code>: 查看 Docker 版本</li><li><code>docker --help</code>: 查看 Docker 帮助文档</li><li><code>docker [command] --help</code>: 查看 Docker 命令帮助</li><li><code>docker login/logout</code>: 登录&#x2F;退出 DockerHub</li></ul><h3 id="常用-Dockerfile-指令-Common-Dockerfile-Instructions"><a href="#常用-Dockerfile-指令-Common-Dockerfile-Instructions" class="headerlink" title="常用 Dockerfile 指令 (Common Dockerfile Instructions)"></a>常用 Dockerfile 指令 (Common Dockerfile Instructions)</h3><ul><li><strong><code>FROM [base_image]</code></strong>: 指定基础镜像, 必须为 Dockerfile 的第一条指令。</li><li><strong><code>ADD</code></strong>: 用于将文件复制到镜像中, 源可以是 URL 或者本地文件, 也可以是一个压缩文件 (自动解压)。</li><li><strong><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [源路径] [目标路径]</code></strong>: 用于将文件拷贝到镜像中, 源只能是本地文件。</li><li><strong><code>WORKDIR [PATH]</code></strong>: 用于指定工作目录, 可以使用多个 WORKDIR 指令, 如果使用相对路径, 则是相对于上一条 WORKDIR 指令所指定的目录。</li><li><strong><code>ENV &lt;key&gt; &lt;value&gt;</code> &#x2F; <code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></strong>: 用于设置环境变量。</li><li><strong><code>CMD &lt;命令&gt;</code> &#x2F; <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></strong>: 用于指定默认的容器主进程, 每个 Dockerfile 中只能有一条 CMD 指令, 如果有多条, 则只有最后一条会生效。</li><li><strong><code>VOLUME &lt;路径&gt;</code> &#x2F; <code>VOLUME [&quot;路径1&quot;, &quot;路径2&quot;...]</code></strong>: 用于定义匿名卷 (持久化目录)。</li></ul><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2025/04/29/docker/"/>
      <url>/2025/04/29/docker/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>1. 拉取镜像 (docker pull)</strong></p><ul><li><strong>作用:</strong> 从镜像仓库 (默认是 Docker Hub) 下载镜像到你的本地机器。</li><li><strong>语法:</strong> <code>docker pull &lt;仓库名&gt;/&lt;镜像名&gt;:&lt;标签&gt;</code><ul><li><code>&lt;仓库名&gt;</code>: 可选，如果是 Docker Hub 上的官方镜像或知名镜像，通常可以省略。如果是个人或其他组织的镜像，需要指定，例如 <code>osrf/ros</code>。</li><li><code>&lt;镜像名&gt;</code>: 必须，例如 <code>ubuntu</code>, <code>ros</code>。</li><li><code>&lt;标签&gt;</code>: 可选，用于指定镜像的版本。如果不指定，默认拉取 <code>latest</code> 标签。<strong>强烈建议总是指定明确的标签</strong>，以保证环境的可复现性。例如 <code>ubuntu:22.04</code>, <code>ros:noetic-ros-base</code>。</li></ul></li><li><strong>示例:</strong><ul><li><p>拉取官方的 Ubuntu 22.04 镜像：你会看到 Docker 开始下载镜像的各个层 (layer)。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:22.04</span><br></pre></td></tr></table></figure></li><li><p>拉取 ROS Noetic 的基础镜像 (来自 Open Source Robotics Foundation)：(这个镜像会大一些，因为它包含了 ROS Noetic 的核心组件)</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ros:noetic-ros-base</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>2. 查看本地镜像 (docker images)</strong></p><ul><li><p><strong>作用:</strong> 列出你本地已经下载的所有镜像。</p></li><li><p><strong>语法:</strong> <code>docker images</code></p></li><li><p><strong>示例:</strong> 你会看到类似以下的输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG               IMAGE ID       CREATED        SIZE</span><br><span class="line">ubuntu              22.04             xxxxxxxxxxxx   xx weeks ago   77.8MB</span><br><span class="line">ros                 noetic-ros-base   yyyyyyyyyyyy   xx weeks ago   1.07GB</span><br><span class="line">hello-world         latest            zzzzzzzzzzzz   xx months ago  13.3kB</span><br></pre></td></tr></table></figure><ul><li><code>REPOSITORY</code>: 镜像所在的仓库名。</li><li><code>TAG</code>: 镜像的标签 (版本)。</li><li><code>IMAGE ID</code>: 镜像的唯一标识符。</li><li><code>CREATED</code>: 镜像创建的时间。</li><li><code>SIZE</code>: 镜像的大小。</li></ul></li></ul><p><strong>3. 运行容器 (docker run)</strong></p><ul><li><p><strong>作用:</strong> 使用指定的镜像创建一个新的容器并运行它。这是 Docker 最核心的命令之一。</p></li><li><p><strong>语法:</strong> <code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p></li><li><p><strong>常用选项 (OPTIONS):</strong></p><p>  以下这些选项非常关键：</p><ol><li><p><strong><code>-it</code> (交互式 TTY)</strong></p><ul><li><p><code>-i</code> (<code>--interactive</code>): 保持标准输入（STDIN）打开，即使没有附加连接。简单说，允许你向容器输入命令。</p></li><li><p><code>-t</code> (<code>--tty</code>): 分配一个伪终端（pseudo-TTY）。这会模拟一个真实的终端，让你可以像在普通 Linux Shell 里一样交互，比如使用 Tab 补全、看到命令提示符等。</p></li><li><p><strong>为什么重要？</strong> 你通常需要进入容器的 Shell 环境进行编译、运行节点、调试等操作，<code>-it</code> 几乎是必备组合。</p></li><li><p><strong>示例:</strong> 这个命令会启动一个基于 <code>ubuntu:20.04</code> 镜像的容器，并直接进入容器的 <code>bash</code> Shell。你可以像在普通的 Ubuntu 终端里一样操作。退出 Shell（输入 <code>exit</code> 或按 <code>Ctrl+D</code>）后，容器通常会停止。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:20.04 bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>--rm</code> (自动移除)</strong></p><ul><li><p>当容器退出时，自动删除容器文件系统。</p></li><li><p><strong>为什么重要？</strong> 每次 <code>docker run</code> 都会创建一个新的容器。如果你只是临时运行一个命令或者进入 Shell 调试，用完就扔，<code>--rm</code> 可以避免产生大量无用的、停止状态的容器，保持 Docker 环境整洁。对于调试和测试非常方便。</p></li><li><p><strong>示例:</strong> 当你退出这个 <code>bash</code> 后，这个容器会被彻底删除，<code>docker ps -a</code> 也看不到它了。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> ubuntu:20.04 bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>-d</code> (<code>--detach</code>) (后台运行)</strong></p><ul><li><p>让容器在后台运行，并打印出容器 ID。</p></li><li><p><strong>为什么重要？</strong> 有时候你希望容器作为一个服务在后台持续运行（比如运行一个 ROS Master 或者一个模拟器），而不是占用你的当前终端。</p></li><li><p><strong>注意:</strong> 如果使用 <code>-d</code>，通常容器需要运行一个长期在前台执行的进程（比如一个 web 服务、一个 <code>sleep infinity</code> 或者 ROS 节点），否则容器一启动执行完默认命令（如果该命令会结束）就会立刻退出。</p></li><li><p><strong>示例:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个后台运行的容器，里面无限睡眠 (常用于创建一个长期运行的基础容器)</span></span><br><span class="line">docker run -d --name my_background_ubuntu ubuntu:20.04 <span class="built_in">sleep</span> infinity</span><br><span class="line"><span class="comment"># 你可以使用 docker exec 进入这个后台运行的容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it my_background_ubuntu bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>--name &lt;container_name&gt;</code> (指定名称)</strong></p><ul><li><p>给容器指定一个易于记忆的名字。如果不指定，Docker 会随机生成一个（比如 <code>vigilant_mclean</code>）。</p></li><li><p><strong>为什么重要？</strong> 有了名字，你可以方便地通过名字来管理容器，比如 <code>docker stop my_slam_container</code>、<code>docker start my_slam_container</code>、<code>docker exec -it my_slam_container bash</code> 等。</p></li><li><p><strong>示例:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> --name slam_dev_session ubuntu:20.04 bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>-v</code> 或 <code>--volume</code> (挂载卷)</strong> &#x2F; <code>--mount</code> (更推荐的挂载方式)</p><ul><li><p>将宿主机（你的 Ubuntu 22.04）的目录或文件挂载到容器内部。这是<strong>实现代码&#x2F;数据共享和持久化的关键</strong>。</p></li><li><p><strong>为什么对 SLAM 重要？</strong></p><ul><li><strong>代码开发:</strong> 你可以在宿主机上用你喜欢的 IDE 编辑代码，然后在容器里编译和运行，代码是实时同步的。</li><li><strong>数据集:</strong> SLAM 数据集通常很大，你不需要把它们复制到镜像里，直接挂载宿主机上的数据集目录即可。</li><li><strong>结果保存:</strong> 容器运行产生的结果（地图、轨迹、日志）可以保存到挂载的宿主机目录，容器删除后结果依然存在。</li></ul></li><li><p><strong>语法 (<code>-v</code>)</strong>: <code>-v &lt;host_path&gt;:&lt;container_path&gt;[:options]</code></p></li><li><p><strong>语法 (<code>--mount</code>)</strong>: <code>--mount type=bind,source=&lt;host_path&gt;,target=&lt;container_path&gt;[,readonly]</code> (bind mount 是最常用的类型，效果类似 <code>-v</code>)</p></li><li><p><strong>示例 (使用 <code>-v</code>)</strong>:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将宿主机的 ~/slam_ws 目录挂载到容器内的 /root/slam_ws 目录</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> -v ~/slam_ws:/root/slam_ws ubuntu:20.04 bash</span><br><span class="line"><span class="comment"># 进入容器后，你在 /root/slam_ws 看到的就是宿主机 ~/slam_ws 的内容</span></span><br><span class="line"><span class="comment"># 在容器内修改 /root/slam_ws/some_file.txt，宿主机的 ~/slam_ws/some_file.txt 也会同步改变</span></span><br></pre></td></tr></table></figure></li><li><p><strong>示例 (使用 <code>--mount</code>)</strong>:<code>--mount</code> 语法更清晰，推荐使用。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=~/slam_ws,target=/root/slam_ws ubuntu:20.04 bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>-p</code> 或 <code>--publish</code> (端口映射)</strong></p><ul><li><p>将容器的端口映射到宿主机的端口。格式：<code>-p &lt;host_port&gt;:&lt;container_port&gt;</code>。</p></li><li><p><strong>为什么对 SLAM 重要？</strong> 如果你在容器里运行了需要网络访问的服务（比如 RViz 的 Web 版本、或者某些算法的监控界面），需要将容器端口暴露给宿主机或其他机器。</p></li><li><p><strong>示例:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设容器内 8080 端口运行了一个 web 服务</span></span><br><span class="line">docker run -d -p 8888:8080 my_web_service_image</span><br><span class="line"><span class="comment"># 现在你可以通过访问宿主机的 8888 端口 (http://localhost:8888) 来访问容器内的 8080 服务</span></span><br></pre></td></tr></table></figure></li><li><p><strong>对于 ROS:</strong> 很多时候直接使用 <code>--net=host</code> (见下一点) 更方便，避免复杂的端口映射。</p></li></ul></li><li><p><strong><code>--net</code> 或 <code>--network</code> (网络模式)</strong></p><ul><li><p>配置容器的网络连接方式。常用模式：</p><ul><li><code>bridge</code> (默认): 容器有自己独立的网络栈，通过 Docker 网桥连接宿主机。需要端口映射 (<code>p</code>) 才能从外部访问容器服务。</li><li><code>host</code>: 容器共享宿主机的网络栈。容器直接使用宿主机的 IP 地址和端口，无需端口映射。性能最好，但隔离性差。</li><li><code>none</code>: 容器没有网络连接。</li></ul></li><li><p><strong>为什么 <code>host</code> 对 SLAM&#x2F;ROS 重要？</strong> ROS 节点间通信、RViz 连接 ROS Master、与连接到宿主机的传感器（如网络摄像头）通信等，使用 <code>--net=host</code> 可以极大简化网络配置，让容器内的 ROS 环境像直接在宿主机运行一样方便。</p></li><li><p><strong>示例:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 host 网络模式运行容器</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --net=host ubuntu:20.04 bash</span><br><span class="line"><span class="comment"># 在容器内运行 ifconfig，你会看到宿主机的网络接口</span></span><br><span class="line"><span class="comment"># 在容器内运行的 ROS 节点可以直接与宿主机或其他局域网内的 ROS 节点通信</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>-e</code> 或 <code>--env</code> (环境变量)</strong></p><ul><li><p>设置容器内的环境变量。格式：<code>-e KEY=VALUE</code>。</p></li><li><p><strong>为什么对 SLAM 重要？</strong></p><ul><li><strong>ROS 配置:</strong> 设置 <code>ROS_MASTER_URI</code>, <code>ROS_IP</code>, <code>ROS_HOSTNAME</code> 等。</li><li><strong>显示转发 (X11 Forwarding):</strong> 让容器内的 GUI 程序（如 RViz, Gazebo, rqt_plot）能显示在宿主机的屏幕上。通常需要设置 <code>DISPLAY</code> 环境变量。</li></ul></li><li><p>**示例 (X11 Forwarding):**<em>注意:</em> X11 Forwarding 配置有时比较棘手，可能因系统而异。<code>-net=host</code> 通常能简化这个问题。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在宿主机先执行 xhost +local:docker (允许本地 docker 容器连接 X server)</span></span><br><span class="line">xhost +<span class="built_in">local</span>:docker</span><br><span class="line"><span class="comment"># 运行容器时传递 DISPLAY 环境变量，并挂载 X11 socket</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> \</span><br><span class="line">       -e DISPLAY=<span class="variable">$DISPLAY</span> \</span><br><span class="line">       -v /tmp/.X11-unix:/tmp/.X11-unix \</span><br><span class="line">       --net=host \</span><br><span class="line">       ubuntu:20.04 bash</span><br><span class="line"><span class="comment"># 在容器内安装并运行一个简单的 GUI 程序试试，比如 xeyes (apt update &amp;&amp; apt install -y x11-apps &amp;&amp; xeyes)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>--device</code> (挂载设备)</strong></p><ul><li><p>将宿主机的设备文件挂载到容器内。</p></li><li><p><strong>为什么对 SLAM 重要？</strong> SLAM 严重依赖传感器！你需要让容器访问连接到宿主机的摄像头、IMU、LiDAR 等设备。</p></li><li><p>**示例:**<em>注意:</em> 确保运行 Docker 的用户在宿主机上对这些设备文件有读写权限（通常需要将用户添加到 <code>video</code>, <code>dialout</code> 等用户组）。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载第一个 USB 摄像头 (/dev/video0)</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --device=/dev/video0 ubuntu:20.04 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载串口设备 (例如 IMU)</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --device=/dev/ttyUSB0 ubuntu:20.04 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载多个设备</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --device=/dev/video0 --device=/dev/ttyUSB0 ubuntu:20.04 bash</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>--gpus</code> (GPU 支持)</strong></p><ul><li>允许容器访问宿主机的 NVIDIA GPU。这对需要 CUDA 加速的 SLAM 算法（如基于深度学习的特征提取、GPU 加速的优化）至关重要。</li><li><strong>前提:</strong> 宿主机需要安装 NVIDIA 驱动和 <code>nvidia-docker2</code> (或称为 NVIDIA Container Toolkit)。</li><li><strong>示例:</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许容器访问所有可用的 GPU</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --gpus all nvidia/cuda:11.4.0-base-ubuntu20.04 nvidia-smi</span><br><span class="line"><span class="comment"># 上例使用了 NVIDIA 官方提供的包含 CUDA 的基础镜像，并运行 nvidia-smi 检查 GPU 是否可用</span></span><br><span class="line"><span class="comment"># 你也可以在你自己的 ubuntu:20.04 镜像基础上，在容器内安装 CUDA Toolkit，然后用 --gpus all 启动</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --gpus all ubuntu:20.04 bash</span><br><span class="line"><span class="comment"># (进入容器后需要自行安装 CUDA 和相关驱动)</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><strong>4. 查看容器 (docker ps)</strong></p><ul><li><strong>作用:</strong> 列出正在运行的容器。</li><li><strong>语法:</strong> <code>docker ps</code></li><li><strong>查看所有容器 (包括已停止的):</strong><ul><li><strong>语法:</strong> <code>docker ps -a</code></li></ul></li></ul><p><strong>5. 进入正在运行的容器 (docker exec)</strong></p><ul><li><strong>作用:</strong> 在一个已经在后台运行的容器内部执行命令。</li><li><strong>语法:</strong> <code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></li><li><strong>常用选项:</strong><ul><li><code>-i</code>, <code>-t</code>: 与 <code>docker run</code> 中的含义相同，通常一起使用 (<code>-it</code>) 来获取交互式 Shell。</li></ul></li><li><strong>示例:</strong><ul><li><p>进入我们之前后台运行的 <code>my-nginx</code> 容器，并启动一个 bash shell:执行后你将进入 <code>my-nginx</code> 容器的 Shell。输入 <code>exit</code> 退出该 Shell，但容器本身仍在后台运行。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it my-nginx bash</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>6. 管理容器 (停止、启动、删除)</strong></p><ul><li><strong>停止容器:</strong><ul><li><strong>语法:</strong> <code>docker stop &lt;容器ID或名称&gt;</code></li><li><strong>示例:</strong> <code>docker stop my-nginx</code></li></ul></li><li><strong>启动已停止的容器:</strong><ul><li><strong>语法:</strong> <code>docker start &lt;容器ID或名称&gt;</code></li><li><strong>示例:</strong> <code>docker start my-nginx</code> (容器会继续在后台运行)</li></ul></li><li><strong>删除容器:</strong><ul><li><strong>注意:</strong> 只能删除已停止的容器。</li><li><strong>语法:</strong> <code>docker rm &lt;容器ID或名称&gt;</code></li><li><strong>示例:</strong> (先停止) <code>docker stop my-nginx</code> (再删除) <code>docker rm my-nginx</code></li><li><strong>强制删除运行中的容器 (不推荐，除非你知道后果):</strong> <code>docker rm -f &lt;容器ID或名称&gt;</code></li></ul></li><li><strong>清理所有已停止的容器:</strong><ul><li><strong>语法:</strong> <code>docker container prune</code> (会提示确认)</li></ul></li></ul><p><strong>7. 删除镜像 (docker rmi)</strong></p><ul><li><strong>作用:</strong> 删除本地的一个或多个镜像。</li><li><strong>注意:</strong> 如果有容器 (即使是已停止的) 正在使用该镜像，需要先删除这些容器才能删除镜像。</li><li><strong>语法:</strong> <code>docker rmi &lt;镜像ID或仓库名:标签&gt;</code></li><li><strong>示例:</strong><ul><li>删除 <code>hello-world</code> 镜像: <code>docker rmi hello-world:latest</code></li><li>删除 <code>ubuntu:22.04</code> 镜像 (如果之前没有基于它创建并保留的容器): <code>docker rmi ubuntu:22.04</code></li></ul></li><li><strong>清理悬空镜像 (dangling images):</strong> 这些是没有标签且没有被任何容器使用的镜像层，通常是构建过程中产生的中间层或旧版本。<ul><li><strong>语法:</strong> <code>docker image prune</code></li></ul></li></ul><h2 id="我自己的实例"><a href="#我自己的实例" class="headerlink" title="我自己的实例"></a>我自己的实例</h2><h3 id="1-需要用gpu的话先配置gpu"><a href="#1-需要用gpu的话先配置gpu" class="headerlink" title="1. 需要用gpu的话先配置gpu"></a>1. 需要用gpu的话先配置gpu</h3><p><a href="https://blog.csdn.net/GritYearner/article/details/133679403">https://blog.csdn.net/GritYearner/article/details/133679403</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | <span class="built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \</span><br><span class="line">  &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">    sed <span class="string">&#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27;</span> | \</span><br><span class="line">    <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list \</span><br><span class="line">  &amp;&amp; \</span><br><span class="line">    <span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y nvidia-docker2</span><br><span class="line"><span class="built_in">sudo</span> nvidia-ctk runtime configure --runtime=docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line">测试</span><br><span class="line"><span class="built_in">sudo</span> docker run --<span class="built_in">rm</span> --gpus all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-利用鱼香ros的镜像启动一个容器"><a href="#2-利用鱼香ros的镜像启动一个容器" class="headerlink" title="2. 利用鱼香ros的镜像启动一个容器"></a>2. 利用鱼香ros的镜像启动一个容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -dit \</span><br><span class="line">--gpus all \</span><br><span class="line">-e NVIDIA_DRIVER_CAPABILITIES=all \</span><br><span class="line">--name=[your_container_name] \</span><br><span class="line">--privileged  \</span><br><span class="line">-v /dev:/dev \</span><br><span class="line">-v /home/[your_username]:/home/[your_username] \</span><br><span class="line">-v /tmp/.X11-unix:/tmp/.X11-unix  \</span><br><span class="line">-e DISPLAY=unix<span class="variable">$DISPLAY</span> \</span><br><span class="line">-w /home/[your_username] \</span><br><span class="line">--net=host \</span><br><span class="line">fishros2/ros:noetic-desktop-full </span><br></pre></td></tr></table></figure><p>这里注意不要直接使用鱼香的容器，他的默认的启动跟这个不太一样。启动时候的这些指令一旦运行，就不能再改了，最好是删除容器重新从镜像用正确指令生成一个容器，实在不想放弃这个容器的话就通过将这个容器生成为新的镜像，再从新镜像用正确指令生成容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器名 新镜像名:标签</span><br></pre></td></tr></table></figure><p>要使用图形界面需要在外面终端运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是鱼香ros默认运行的</span></span><br><span class="line">xhost +<span class="built_in">local</span>: &gt;&gt; /dev/null</span><br><span class="line"><span class="comment"># 这是gpt推荐的</span></span><br><span class="line">xhost +<span class="built_in">local</span>:docker</span><br></pre></td></tr></table></figure><h3 id="3-已经装好了ORB-SLAM3和ROS的镜像"><a href="#3-已经装好了ORB-SLAM3和ROS的镜像" class="headerlink" title="3. 已经装好了ORB-SLAM3和ROS的镜像"></a>3. 已经装好了ORB-SLAM3和ROS的镜像</h3><p>我通过之前的鱼香镜像生成容器配置好orbslam3自己做了一个镜像上传到了dockerhub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line">docker pull 用户名/仓库名:标签</span><br><span class="line"><span class="built_in">sudo</span> docker run -dit \</span><br><span class="line">--gpus all \</span><br><span class="line">-e NVIDIA_DRIVER_CAPABILITIES=all \</span><br><span class="line">--name=rosslam \</span><br><span class="line">--privileged  \</span><br><span class="line">-v /dev:/dev \</span><br><span class="line">-v /home/xfy/docker-ros:/home/rosslam/workspace \ //记得改这个挂载目录</span><br><span class="line">-v /tmp/.X11-unix:/tmp/.X11-unix  \</span><br><span class="line">-e DISPLAY=unix<span class="variable">$DISPLAY</span> \</span><br><span class="line">-w /home/rosslam \</span><br><span class="line">--net=host \</span><br><span class="line">xuefeiyang/fyslam:slam3WithRos</span><br></pre></td></tr></table></figure><ol><li><p><strong><code>sudo docker run</code></strong>:</p><ul><li><code>sudo</code>: 以超级用户（root）权限执行后面的命令。运行 Docker 命令，特别是涉及硬件访问（如 GPU、设备挂载 <code>/dev</code>）或修改网络设置（<code>--net=host</code>）时，通常需要 <code>sudo</code> 权限。</li><li><code>docker run</code>: 这是 Docker 的核心命令，用于根据指定的镜像创建一个新的容器并运行它。</li></ul></li><li><p><strong><code>-dit</code></strong>: 这是三个选项的缩写合并：</p><ul><li><code>-d</code> (<code>--detach</code>): 让容器在后台运行（Detached mode）。执行此命令后，你会立即返回到宿主机的终端提示符，而不是直接进入容器的 Shell。容器会在后台保持运行状态。这对于运行需要长时间提供服务的容器（如 ROS Master、模拟器）很有用。</li><li><code>-i</code> (<code>--interactive</code>): 保持标准输入（STDIN）对容器开放，即使没有连接到容器。这通常与 <code>-t</code> 一起使用，以便后续可以通过 <code>docker attach</code> 或 <code>docker exec</code> 进行交互。</li><li><code>-t</code> (<code>--tty</code>): 为容器分配一个伪终端（pseudo-TTY）。这使得你后续通过 <code>docker exec</code> 进入容器时，能获得一个类似真实终端的交互体验（例如，有命令提示符、支持 Tab 补全等）。</li><li><strong>组合效果</strong>: <code>-dit</code> 启动一个后台运行的容器，但保持其交互接口可用，方便你之后使用 <code>docker exec -it rosslam bash</code> 等命令进入容器内部进行操作。</li></ul></li><li><p><strong><code>--gpus all</code></strong>:</p><ul><li>允许这个容器访问宿主机上所有可用的 NVIDIA GPU。</li><li><strong>前提</strong>: 你的宿主机需要正确安装 NVIDIA 显卡驱动，并且安装了 NVIDIA Container Toolkit (nvidia-docker2)。</li><li><strong>用途</strong>: 对于需要 CUDA 进行加速的 SLAM 算法（例如，基于深度学习的特征提取、GPU 加速的后端优化、仿真渲染等）至关重要。</li></ul></li><li><p><strong><code>-e NVIDIA_DRIVER_CAPABILITIES=all</code></strong>:</p><ul><li><code>-e</code> (<code>--env</code>): 设置容器内部的环境变量。</li><li><code>NVIDIA_DRIVER_CAPABILITIES=all</code>: 这个特定的环境变量告诉 NVIDIA 驱动程序，允许容器使用驱动程序的所有功能（如图形、计算、工具、视频编解码等）。通常与 <code>--gpus</code> 选项配合使用，以确保容器内应用能充分利用 GPU 能力。</li></ul></li><li><p><strong><code>--name=rosslam</code></strong>:</p><ul><li>给这个新创建的容器指定一个名字，叫做 “rosslam”。</li><li><strong>好处</strong>: 你可以使用这个名字来方便地管理容器，例如 <code>docker stop rosslam</code>、<code>docker start rosslam</code>、<code>docker logs rosslam</code>、<code>docker exec -it rosslam bash</code> 等，而不需要记住 Docker 自动生成的长 ID。</li></ul></li><li><p><strong><code>--privileged</code></strong>:</p><ul><li>赋予这个容器扩展的权限。这基本上禁用了容器和宿主机之间的大部分安全隔离机制。</li><li><strong>效果</strong>: 容器几乎拥有与宿主机上 root 用户相同的权限，可以访问宿主机的所有设备（<code>/dev</code> 下的所有内容），修改内核参数等。</li><li><strong>使用场景</strong>: 通常是为了确保容器能够无障碍地访问各种硬件设备（摄像头、IMU、LiDAR 等），尤其是在 <code>-v /dev:/dev</code> 挂载了整个设备目录的情况下，确保权限足够。</li><li><strong>注意</strong>: 这是一个强大的选项，但<strong>有安全风险</strong>。如果可能，优先考虑使用更精细的 <code>--device</code> 选项来只挂载必要的设备，而不是使用 <code>--privileged</code>。但有时为了方便或解决特定权限问题会使用它。</li></ul></li><li><p><strong><code>-v /dev:/dev</code></strong>:</p><ul><li><code>-v</code> (<code>--volume</code>): 将宿主机的目录或文件挂载到容器内部。这里是挂载宿主机的 <code>/dev</code> 目录到容器的 <code>/dev</code> 目录。</li><li><strong>目的</strong>: 让容器可以直接访问宿主机上的所有硬件设备文件。这对于 SLAM 来说非常方便，因为你可以直接在容器内像在宿主机上一样使用 <code>/dev/video0</code>（摄像头）、<code>/dev/ttyUSB0</code>（串口设备如 IMU 或 LiDAR）等设备。</li><li><strong>与 <code>--privileged</code> 的关系</strong>: 这个挂载让容器 <em>看到</em> 设备文件，而 <code>--privileged</code> 通常用来确保容器 <em>有权限</em> 去操作这些设备文件。</li></ul></li><li><p><strong><code>-v /home/xfy/docker-ros:/home/rosslam/workspace</code></strong>:</p><ul><li>这是另一个卷挂载。</li><li><code>宿主机路径</code>: <code>/home/xfy/docker-ros</code> （<strong>这是你宿主机上的一个具体目录，其他人使用时需要修改成他们自己的路径！</strong>）</li><li><code>容器内路径</code>: <code>/home/rosslam/workspace</code></li><li><strong>目的</strong>: 这是实现代码和数据共享的关键。你在宿主机的 <code>/home/xfy/docker-ros</code> 目录下修改代码、存放数据，这些内容会实时同步到容器内的 <code>/home/rosslam/workspace</code> 目录，反之亦然。这样你可以在宿主机使用你喜欢的编辑器，而在容器内编译和运行。容器删除后，这个目录下的工作成果依然保存在宿主机上。</li></ul></li><li><p><strong><code>-v /tmp/.X11-unix:/tmp/.X11-unix</code></strong>:</p><ul><li>挂载宿主机的 X11 Unix Domain Socket 目录到容器内部对应的位置。</li><li><strong>目的</strong>: 这是实现 X11 转发（让容器内的 GUI 程序显示在宿主机屏幕上）的关键步骤之一。GUI 程序通过这个 Socket 与宿主机的 X Server 通信。</li></ul></li><li><p><strong><code>-e DISPLAY=unix$DISPLAY</code></strong>:</p><ul><li>设置容器内的 <code>DISPLAY</code> 环境变量。</li><li><code>$DISPLAY</code>: 这会取用你<strong>当前宿主机</strong>的 <code>DISPLAY</code> 环境变量的值（通常是 <code>:0</code> 或 <code>:1</code> 等）。</li><li><code>unix</code>: 有时会加上这个前缀，但很多时候直接 <code>-e DISPLAY=$DISPLAY</code> 也能工作。</li><li><strong>目的</strong>: 告诉容器内的 GUI 应用程序应该将图形界面发送到哪个显示服务器（即你的宿主机屏幕）。需要与上一步的 X11 Socket 挂载配合使用。</li><li><strong>前提</strong>: 在运行这个 <code>docker run</code> 命令之前，你可能需要在宿主机上执行 <code>xhost +local:docker</code> （或者更安全的特定容器授权命令）来允许来自 Docker 容器的 X11 连接。</li></ul></li><li><p><strong><code>-w /home/rosslam</code></strong>:</p><ul><li><code>-w</code> (<code>--workdir</code>): 指定容器启动后的默认工作目录。</li><li><strong>效果</strong>: 当你使用 <code>docker exec -it rosslam bash</code> 进入容器时，你的 Shell 会话将直接从容器内的 <code>/home/rosslam</code> 目录开始，而不是默认的根目录 <code>/</code>。这通常是为了方便，让你直接进入项目相关的主目录。</li></ul></li><li><p><strong><code>--net=host</code></strong>:</p><ul><li>让容器共享宿主机的网络命名空间（Network Namespace）。</li><li><strong>效果</strong>: 容器不会获得自己独立的 IP 地址，而是直接使用宿主机的网络接口和 IP 地址。容器内监听的端口会直接暴露在宿主机的对应端口上，无需使用 <code>-p</code> 进行端口映射。</li><li><strong>对 ROS&#x2F;SLAM 的好处</strong>: 极大地简化了网络配置。容器内的 ROS 节点可以像在宿主机上运行一样，轻松地被局域网内（包括宿主机）的其他 ROS 节点发现和通信（例如 RViz 连接容器内的 ROS Master）。也方便访问连接到宿主机的网络摄像头等设备。</li><li><strong>缺点</strong>: 降低了网络隔离性。</li></ul></li><li><p><strong><code>xuefeiyang/fyslam:slam3WithRos</code></strong>:</p><ul><li>这是用来创建容器的<strong>镜像</strong>（Image）。</li><li><code>xuefeiyang/fyslam</code>: 镜像的仓库名&#x2F;用户名和镜像名，这看起来是一个用户（xuefeiyang）构建并可能分享在 Docker Hub 或私有仓库的自定义镜像。</li><li><code>slam3WithRos</code>: 镜像的标签（Tag），通常表示镜像的版本或者配置。这个名字暗示了这个镜像里面很可能已经预装了 ROS (Robot Operating System) 和一些 SLAM 相关的库或工具。</li></ul></li></ol><p><strong>总结</strong></p><p>这个命令启动了一个名为 <code>rosslam</code> 的后台容器，该容器基于 <code>xuefeiyang/fyslam:slam3WithRos</code> 镜像。它被赋予了很高的权限 (<code>--privileged</code>)，可以直接访问宿主机的所有 GPU (<code>--gpus all</code>) 和所有设备 (<code>-v /dev:/dev</code>)，并且共享宿主机的网络 (<code>--net=host</code>)。它还设置了 GUI 转发 (<code>-v /tmp/.X11-unix</code>, <code>-e DISPLAY</code>)，并将宿主机的 <code>/home/xfy/docker-ros</code> 目录映射到容器的 <code>/home/rosslam/workspace</code> 以共享工作文件。容器启动后的默认工作目录是 <code>/home/rosslam</code>。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—g2o库—ICP</title>
      <link href="/2025/04/29/c10/"/>
      <url>/2025/04/29/c10/</url>
      
        <content type="html"><![CDATA[<p>这个例子解决的是一个常见的 3D 重建或配准问题：我们有两组对应的三维点云（或者说，已知点之间的匹配关系），并且已经有了一个初始的、可能不太精确的相对位姿估计（旋转 R 和平移 t），我们希望通过优化来获得一个更精确的相对位姿。</p><p><strong>与 Bundle Adjustment 的关键区别：</strong></p><ul><li>BA 通常处理的是 3D 点到 2D 图像点的投影关系。</li><li>这个例子处理的是 <strong>3D 点到 3D 点</strong> 的直接变换关系。</li><li>这个特定的例子<strong>只优化位姿</strong>，而<strong>不优化三维点的坐标</strong> (尽管也可以扩展为同时优化点坐标)。</li></ul><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>假设我们有两组三维点：</p><ul><li><code>pts1</code>: 第一组三维点的坐标（在坐标系 1 中）。</li><li><code>pts2</code>: 第二组三维点的坐标（在坐标系 2 中）。</li></ul><p>我们知道 <code>pts1[i]</code> 和 <code>pts2[i]</code> 是<strong>对应</strong>的点。我们还有一个从坐标系 2 变换到坐标系 1 的初始位姿估计 $T_{12} &#x3D; (R, t)$。</p><p>目标是：<strong>优化位姿 $T_{12}$</strong>，使得将 <code>pts2</code> 中的每个点 $\mathbf{p}_{2,i}$ 通过优化后的位姿 $T_{12}$ 变换到坐标系 1 后，得到的结果 $T_{12} \mathbf{p}_{2,i}$ 与其对应的点 $\mathbf{p}_{1,i}$ 之间的<strong>距离（误差）</strong> 的总和最小。</p><p>误差项可以定义为： $\mathbf{e}_i &#x3D; \mathbf{p}_{1,i} - T_{12} \mathbf{p}_{2,i}$</p><p>我们要最小化 $\sum_i ||\mathbf{e}_i||^2$。</p><h3 id="2-思考过程：如何用图优化解决？"><a href="#2-思考过程：如何用图优化解决？" class="headerlink" title="2. 思考过程：如何用图优化解决？"></a>2. 思考过程：如何用图优化解决？</h3><ul><li><p><strong>顶点 (Vertex) 代表什么？</strong></p><ul><li>未知变量是待优化的相对位姿 $T_{12}$。</li><li><strong>因此，我们将 $T_{12}$ 定义为一个 <code>g2o::VertexSE3Expmap</code> 顶点。</strong> 只需要一个顶点。</li></ul></li><li><p><strong>边 (Edge) 代表什么？</strong></p><ul><li>约束来自于每一对匹配点 $(\mathbf{p}_{1,i}, \mathbf{p}_{2,i})$。</li><li>每一对点都要求：变换后的点 $T_{12} \mathbf{p}_{2,i}$ 应该接近目标点 $\mathbf{p}_{1,i}$。</li><li><strong>因此，每一对匹配点 $(\mathbf{p}_{1,i}, \mathbf{p}_{2,i})$ 都对应图中的一条边。</strong> 这条边衡量了 $\mathbf{p}_{1,i}$ 和 $T_{12} \mathbf{p}_{2,i}$ 之间的三维向量误差。</li></ul></li><li><p><strong>顶点和边如何连接？</strong></p><ul><li>计算第 $i$ 对点的误差 $\mathbf{e}_i &#x3D; \mathbf{p}_{1,i} - T_{12} \mathbf{p}_{2,i}$ 时，我们只用到<strong>一个</strong>待优化的变量——位姿 $T_{12}$。点 $\mathbf{p}_{1,i}$ 和 $\mathbf{p}_{2,i}$ 的坐标在这个例子中是<strong>固定</strong>的。</li><li><strong>因此，每条边只连接到那个唯一的位姿顶点上，是 一元边 (Unary Edge)。</strong></li></ul></li><li><p><strong>点坐标如何处理？</strong></p><ul><li>$\mathbf{p}_{1,i}$：可以看作是这条边的 <strong>测量值 (Measurement)</strong>，即我们期望变换后的点应该到达的目标位置。</li><li>$\mathbf{p}_{2,i}$：它是计算误差时需要用到的<strong>固定数据</strong>，它不是测量值，也不是待优化变量。它需要与边实例关联起来。</li></ul></li></ul><p><strong>总结思路：</strong> 创建一个图，包含：</p><ul><li>1 个 <code>VertexSE3Expmap</code> 顶点 (表示待优化的位姿 $T_{12}$)。</li><li>N 条 <strong>自定义的一元边</strong> (每条边对应一对匹配点 $(\mathbf{p}_{1,i}, \mathbf{p}_{2,i})$)。<ul><li>每条边存储 $\mathbf{p}_{2,i}$ 作为固定数据。</li><li>每条边以 $\mathbf{p}_{1,i}$ 作为测量值。</li><li>每条边计算误差 $\mathbf{e}_i &#x3D; \mathbf{p}_{1,i} - T_{12} \mathbf{p}_{2,i}$。<br>让 g2o 优化这个图，调整位姿顶点的值，使得所有边的误差平方和（考虑信息矩阵）最小。</li></ul></li></ul><h3 id="3-g2o-实现步骤"><a href="#3-g2o-实现步骤" class="headerlink" title="3. g2o 实现步骤"></a>3. g2o 实现步骤</h3><p><strong>3.1 自定义边的类型 (<code>EdgeProjectXYZRGBDPoseOnly</code>)</strong></p><ul><li><strong>原因:</strong> g2o 没有预定义完全符合 $\mathbf{e}_i &#x3D; \mathbf{p}_{1,i} - T \mathbf{p}_{2,i}$ 这种形式误差的一元边。我们需要自己创建一个。</li><li><strong>实现:</strong><ul><li><strong>继承:</strong> <code>g2o::BaseUnaryEdge&lt;D, E, VertexType&gt;</code>。<ul><li><code>D</code> (误差维度): 误差是 3D 向量差，<code>D = 3</code>。</li><li><code>E</code> (测量值类型): 测量值是目标点 $\mathbf{p}_{1,i}$，类型为 <code>Eigen::Vector3d</code>。</li><li><code>VertexType</code>: 连接的顶点是位姿，类型为 <code>g2o::VertexSE3Expmap</code>。</li><li>所以继承 <code>g2o::BaseUnaryEdge&lt;3, Eigen::Vector3d, g2o::VertexSE3Expmap&gt;</code>。</li></ul></li><li><strong>构造函数:</strong> 需要传入并存储固定的点坐标 $\mathbf{p}_{2,i}$。代码中将其命名为 <code>_point</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EdgeProjectXYZRGBDPoseOnly</span>(<span class="type">const</span> Eigen::Vector3d&amp; point) : _point(point) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><strong>重写 <code>computeError()</code>:</strong><ol><li>获取位姿顶点 <code>pose = _vertices[0]</code>。</li><li>获取当前位姿估计 <code>T = pose-&gt;estimate()</code>。</li><li>使用当前位姿 T 变换存储的固定点 <code>_point</code> (即 $\mathbf{p}_{2,i}$): <code>transformed_point = T.map(_point)</code>。</li><li>计算误差：<code>_error = _measurement - transformed_point</code>。其中 <code>_measurement</code> 存储的是目标点 $\mathbf{p}_{1,i}$。</li></ol></li><li><strong>重写 <code>linearizeOplus()</code> (计算雅可比):</strong><ol><li>获取当前位姿 <code>T</code> 和变换后的点 <code>xyz_trans = T.map(_point)</code>。</li><li>计算误差 $\mathbf{e} &#x3D; \mathbf{p}_1 - T \mathbf{p}_2$ 对位姿顶点（在 se(3) 李代数上的 6D 扰动 $\delta \boldsymbol{\xi} &#x3D; (\delta \omega_x, \delta \omega_y, \delta \omega_z, \delta t_x, \delta t_y, \delta t_z)^T$）的雅可比矩阵 $\frac{\partial \mathbf{e}}{\partial \delta \boldsymbol{\xi}}$。</li><li>根据链式法则和 SE(3) 的性质，可以推导出（假设扰动是左乘的）：<br>$$\frac{\partial \mathbf{e}}{\partial \delta \boldsymbol{\xi}} &#x3D; - \frac{\partial (T \mathbf{p}_2)}{\partial \delta \boldsymbol{\xi}} &#x3D; - \begin{pmatrix} -[\mathbf{p}’]_\times &amp; \mathbf{I} \end{pmatrix} &#x3D; \begin{pmatrix} [\mathbf{p}’]_\times &amp; -\mathbf{I} \end{pmatrix}$$<br>其中 $\mathbf{p}’ &#x3D; T \mathbf{p}_2 &#x3D; \text{xyz_trans}$。</li><li>将这个 3x6 的雅可比矩阵赋值给 <code>_jacobianOplusXi</code> (因为是一元边，只有 Xi)。代码中直接给出了展开形式。</li></ol></li><li><code>read</code>&#x2F;<code>write</code> 函数在此例中留空。</li></ul></li></ul><p><strong>3.2 顶点类型</strong></p><ul><li>使用 g2o 预定义的 <code>g2o::VertexSE3Expmap</code> 来表示待优化的位姿。</li></ul><p><strong>3.3 配置优化器</strong></p><ul><li>与 BA 示例类似，配置 <code>BlockSolver</code> (这里用了 <code>BlockSolverTraits&lt;6, 3&gt;</code>)、<code>LinearSolverCSparse</code> 和 <code>OptimizationAlgorithmLevenberg</code>。</li><li>创建 <code>SparseOptimizer</code> 并设置算法和 <code>verbose</code>。</li></ul><p><strong>3.4 构建图</strong></p><ul><li><strong>添加顶点:</strong><ol><li>创建 <code>VertexSE3Expmap</code> 对象。</li><li>设置 ID (0)。</li><li>设置<strong>初始位姿估计</strong> (<code>setEstimate</code>)。注意：代码中给了单位阵和零向量作为初始值，但在实际应用中，应该传入通过其他方法（如 RANSAC+SVD 或 粗略 ICP）得到的初始 R 和 t。</li><li>添加到优化器。</li></ol></li><li><strong>添加边:</strong><ol><li>遍历所有匹配点对 (<code>pts1[i]</code>, <code>pts2[i]</code>)。</li><li>创建自定义的 <code>EdgeProjectXYZRGBDPoseOnly</code> 对象，<strong>将 <code>pts2[i]</code> (转换成 <code>Eigen::Vector3d</code>) 传入构造函数</strong>。</li><li>设置边的唯一 ID (从 1 开始)。</li><li><strong>连接到顶点:</strong> <code>edge-&gt;setVertex(0, pose)</code>，连接到唯一的位姿顶点。</li><li><strong>设置测量值:</strong> <code>edge-&gt;setMeasurement(...)</code>，传入目标点 <code>pts1[i]</code> (转换成 <code>Eigen::Vector3d</code>)。</li><li><strong>设置信息矩阵:</strong> <code>edge-&gt;setInformation(Eigen::Matrix3d::Identity() * 1e4)</code>。这里使用了单位矩阵乘以一个较大的数 <code>1e4</code>。这意味着我们对所有的点对匹配给予了<strong>很高的信任度（权重）</strong>，假设它们的误差都应该很小。在实际应用中，可以根据匹配质量或点的不确定性来设置不同的信息矩阵。</li><li>添加到优化器。</li></ol></li></ul><p><strong>3.5 执行优化</strong></p><ul><li>调用 <code>optimizer.initializeOptimization()</code>。</li><li>调用 <code>optimizer.optimize(num_iterations)</code> (代码中是 10 次)。</li></ul><p><strong>3.6 获取结果</strong></p><ul><li>从位姿顶点 <code>pose</code> 获取优化后的估计值 <code>pose-&gt;estimate()</code>。</li><li>将其转换为 <code>Eigen::Isometry3d</code> 并输出变换矩阵。</li></ul><h3 id="4-准备工作"><a href="#4-准备工作" class="headerlink" title="4. 准备工作"></a>4. 准备工作</h3><ul><li><strong>包含头文件:</strong> g2o 核心库、求解器、算法、<code>VertexSE3Expmap</code>、<code>BaseUnaryEdge</code>、Eigen 等。</li><li><strong>准备输入数据:</strong><ul><li><code>std::vector&lt;cv::Point3f&gt; pts1</code>: 目标点云坐标。</li><li><code>std::vector&lt;cv::Point3f&gt; pts2</code>: 源点云坐标（待变换的点）。<strong>注意 <code>pts1</code> 和 <code>pts2</code> 必须是严格对应的</strong>。</li><li><code>cv::Mat R</code>, <code>cv::Mat t</code>: 初始的位姿估计（尽管代码中 <code>bundleAdjustment</code> 函数内部没有使用传入的 R, t 来设置初始值，而是用了单位阵，但在实际调用时应该用它们来设置 <code>pose-&gt;setEstimate</code>）。</li></ul></li><li><strong>数据类型转换:</strong> 将 <code>cv::Point3f</code> 转换为 <code>Eigen::Vector3d</code>。</li></ul><h3 id="5-关键代码片段-带注释"><a href="#5-关键代码片段-带注释" class="headerlink" title="5. 关键代码片段 (带注释)"></a>5. 关键代码片段 (带注释)</h3><pre><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;// Eigen 核心库#include &lt;Eigen/Core&gt;#include &lt;Eigen/Geometry&gt;// g2o 核心库#include &lt;g2o/core/sparse_optimizer.h&gt;#include &lt;g2o/core/block_solver.h&gt;#include &lt;g2o/core/optimization_algorithm_levenberg.h&gt;#include &lt;g2o/core/base_vertex.h&gt;#include &lt;g2o/core/base_unary_edge.h&gt; // 一元边基类// g2o 线性求解器#include &lt;g2o/solvers/csparse/linear_solver_csparse.h&gt;// g2o 类型定义#include &lt;g2o/types/slam3d/vertex_se3_expmap.h&gt; // VertexSE3Expmap#include &lt;g2o/types/slam3d/se3quat.h&gt;          // SE3Quat// OpenCV (仅用于数据结构 Point3f, Mat)#include &lt;opencv2/core/core.hpp&gt;using namespace std;using namespace g2o;// --- 1. 自定义边：用于 3D-3D 点对的位姿优化 ---// 模板参数：误差维度 D=3, 测量值类型 E=Eigen::Vector3d, 连接顶点类型 VertexSE3Expmapclass EdgeProjectXYZRGBDPoseOnly : public BaseUnaryEdge&lt;3, Eigen::Vector3d, VertexSE3Expmap&gt; &#123;public:    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;    // 构造函数：传入需要被变换的点 p2 的坐标    EdgeProjectXYZRGBDPoseOnly(const Eigen::Vector3d &amp;point) : _point(point) &#123;&#125;    // 读写函数 (本例忽略)    virtual bool read(istream &amp;in) override &#123; return false; &#125;    virtual bool write(ostream &amp;out) const override &#123; return false; &#125;    // 计算误差函数： error = p1 - T * p2    virtual void computeError() override &#123;        // 获取连接的位姿顶点        const VertexSE3Expmap *pose = static_cast&lt;const VertexSE3Expmap *&gt;(_vertices[0]);        // 计算变换后的点 T * p2 (其中 p2 是存储在 _point 中的)        Eigen::Vector3d transformed_point = pose-&gt;estimate().map(_point);        // 计算误差 error = measurement - transformed_point (measurement 是 p1)        _error = _measurement - transformed_point;    &#125;    // 计算雅可比矩阵： d(error) / d(delta_xi) = [p&#39;]_x, -I    virtual void linearizeOplus() override &#123;        VertexSE3Expmap *pose = static_cast&lt;VertexSE3Expmap *&gt;(_vertices[0]);        SE3Quat T(pose-&gt;estimate());        // 计算变换后的点 p&#39; = T * p2        Eigen::Vector3d xyz_trans = T.map(_point);        double x = xyz_trans[0];        double y = xyz_trans[1];        double z = xyz_trans[2];        // 雅可比矩阵 _jacobianOplusXi (3x6)        // 对应扰动 delta_xi = (omega_x, omega_y, omega_z, v_x, v_y, v_z)        // J = [ [p&#39;]_x   -I ]        _jacobianOplusXi(0, 0) = 0;    // d(error_x)/d(omega_x)        _jacobianOplusXi(0, 1) = -z;   // d(error_x)/d(omega_y)        _jacobianOplusXi(0, 2) = y;    // d(error_x)/d(omega_z)        _jacobianOplusXi(0, 3) = -1;   // d(error_x)/d(v_x)        _jacobianOplusXi(0, 4) = 0;    // d(error_x)/d(v_y)        _jacobianOplusXi(0, 5) = 0;    // d(error_x)/d(v_z)        _jacobianOplusXi(1, 0) = z;    // d(error_y)/d(omega_x)        _jacobianOplusXi(1, 1) = 0;    // d(error_y)/d(omega_y)        _jacobianOplusXi(1, 2) = -x;   // d(error_y)/d(omega_z)        _jacobianOplusXi(1, 3) = 0;    // d(error_y)/d(v_x)        _jacobianOplusXi(1, 4) = -1;   // d(error_y)/d(v_y)        _jacobianOplusXi(1, 5) = 0;    // d(error_y)/d(v_z)        _jacobianOplusXi(2, 0) = -y;   // d(error_z)/d(omega_x)        _jacobianOplusXi(2, 1) = x;    // d(error_z)/d(omega_y)        _jacobianOplusXi(2, 2) = 0;    // d(error_z)/d(omega_z)        _jacobianOplusXi(2, 3) = 0;    // d(error_z)/d(v_x)        _jacobianOplusXi(2, 4) = 0;    // d(error_z)/d(v_y)        _jacobianOplusXi(2, 5) = -1;   // d(error_z)/d(v_z)    &#125;protected:    Eigen::Vector3d _point; // 存储需要被变换的点 p2 的坐标&#125;;// --- 2. BA 函数主体 (ICP 位姿精化) ---void bundleAdjustment(    const std::vector&lt;cv::Point3f&gt; &amp;pts1, // 目标点云 (坐标系 1)    const std::vector&lt;cv::Point3f&gt; &amp;pts2, // 源点云 (坐标系 2)    cv::Mat &amp;R, cv::Mat &amp;t) &#123;             // 初始/优化后的位姿 (R, t 从系统 2 到系统 1)    // --- 配置 g2o 优化器 (与之前类似) ---    typedef BlockSolver&lt;BlockSolverTraits&lt;6, 3&gt;&gt; BlockSolverType;    typedef LinearSolverCSparse&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType;    auto linearSolver = std::make_unique&lt;LinearSolverType&gt;();    auto blockSolver = std::make_unique&lt;BlockSolverType&gt;(std::move(linearSolver));    OptimizationAlgorithmLevenberg *algorithm = new OptimizationAlgorithmLevenberg(std::move(blockSolver));    SparseOptimizer optimizer;    optimizer.setAlgorithm(algorithm);    optimizer.setVerbose(true);    // --- 添加顶点 (只有一个位姿顶点) ---    VertexSE3Expmap *pose = new VertexSE3Expmap();    pose-&gt;setId(0);    // **注意:** 这里设置了单位阵初始值，实际应用中应使用传入的 R, t    // Eigen::Matrix3d R_mat; // ... 从 cv::Mat R 转换 ...    // Eigen::Vector3d t_vec; // ... 从 cv::Mat t 转换 ...    // pose-&gt;setEstimate(SE3Quat(R_mat, t_vec));    pose-&gt;setEstimate(SE3Quat(Eigen::Matrix3d::Identity(), Eigen::Vector3d(0, 0, 0))); // 示例中使用单位阵    optimizer.addVertex(pose);    // --- 添加边 (每个点对一条边) ---    int index = 1; // 边 ID 从 1 开始    for (size_t i = 0; i &lt; pts1.size(); i++) &#123;        // 创建自定义边，传入需要变换的点 pts2[i]        EdgeProjectXYZRGBDPoseOnly *edge = new EdgeProjectXYZRGBDPoseOnly(            Eigen::Vector3d(pts2[i].x, pts2[i].y, pts2[i].z));        edge-&gt;setId(index);        // 连接到唯一的位姿顶点 (ID=0)        edge-&gt;setVertex(0, pose); // dynamic_cast 在这里可能更安全，但如果确定类型可以省略        // 设置测量值 (目标点 pts1[i])        edge-&gt;setMeasurement(Eigen::Vector3d(pts1[i].x, pts1[i].y, pts1[i].z));        // 设置信息矩阵 (权重)        // 使用单位阵乘以较大的系数，表示对匹配点对的信任度高        edge-&gt;setInformation(Eigen::Matrix3d::Identity() * 1e4);        optimizer.addEdge(edge);        index++;    &#125;    // --- 执行优化 ---    cout &lt;&lt; &quot;Starting optimization...&quot; &lt;&lt; endl;    optimizer.initializeOptimization();    optimizer.optimize(10); // 执行 10 次迭代    // --- 输出结果 ---    cout &lt;&lt; &quot;Optimization finished.&quot; &lt;&lt; endl;    SE3Quat optimized_pose = pose-&gt;estimate();    cout &lt;&lt; &quot;Optimized Transformation Matrix (T_1_2): &quot; &lt;&lt; endl &lt;&lt; Eigen::Isometry3d(optimized_pose).matrix() &lt;&lt; endl;    // (可选) 将优化后的 pose 更新回输入的 R, t&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—g2o库—BA</title>
      <link href="/2025/04/28/c9/"/>
      <url>/2025/04/28/c9/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>我们有一个相机，它在某个未知的位置和姿态（合称<strong>位姿</strong>）下拍摄了一张照片。我们知道：</p><ol><li>一些三维空间点的坐标 (<code>points_3d</code>)。</li><li>这些三维点在相机拍摄的照片上对应的二维像素坐标 (<code>points_2d</code>)。</li><li>相机的内部参数（焦距、主点），通常表示为一个<strong>内参矩阵 K</strong>。</li><li>相机位姿的一个<strong>初始估计值</strong>（旋转矩阵 <code>R</code> 和平移向量 <code>t</code>）。</li></ol><p>由于三维点坐标的测量、二维点观测以及初始位姿估计都可能存在误差，直接将三维点通过初始位姿和内参投影到图像平面，得到的二维坐标通常不会精确地等于观测到的二维坐标。</p><p><strong>目标：</strong> 同时<strong>优化调整</strong>相机的<strong>位姿 (R, t)</strong> 和 <strong>三维点的空间坐标 (<code>points_3d</code>)</strong>，使得所有三维点在优化后的位姿下，根据相机内参投影到图像平面上的<strong>重投影坐标</strong>与<strong>观测到的二维坐标 (<code>points_2d</code>)</strong> 之间的<strong>误差（重投影误差）</strong> 的总和最小。</p><p>这本质上是一个大规模的非线性最小二乘优化问题。</p><h3 id="2-思考过程：如何用图优化解决？"><a href="#2-思考过程：如何用图优化解决？" class="headerlink" title="2. 思考过程：如何用图优化解决？"></a>2. 思考过程：如何用图优化解决？</h3><p>我们将 BA 问题转化为 g2o 的图模型：</p><ul><li><p><strong>顶点 (Vertex) 代表什么？</strong></p><ul><li>顶点代表需要优化的未知变量。</li><li>在这个问题中，未知变量有两类：<ol><li><strong>相机的位姿 (Pose):</strong> 它有 6 个自由度（3 个旋转，3 个平移）。我们将用一个顶点来表示它。</li><li><strong>每个三维空间点的坐标 (3D Point):</strong> 每个点有 3 个自由度（x, y, z）。我们将为<strong>每一个</strong>三维点创建一个对应的顶点。</li></ol></li><li><strong>因此，图中将包含 1 个位姿顶点和 N 个三维点顶点 (N 是点的数量)。</strong></li></ul></li><li><p><strong>边 (Edge) 代表什么？</strong></p><ul><li>边代表变量之间的约束或测量误差。</li><li>我们的约束来自于观测：每个三维点 $P_i$ 在图像上被观测为一个二维点 $p_i$。这个观测关系同时关联了三维点 $P_i$ 的坐标和相机的位姿。</li><li><strong>因此，每一个观测 $(P_i, p_i)$ 都对应图中的一条边。</strong> 这条边表达的是：根据当前估计的相机位姿和当前估计的三维点 $P_i$ 坐标，计算出的 $P_i$ 的重投影坐标 $p’_{i}$，与实际观测到的 $p_i$ 之间的误差 $e_i = p_i - p’_{i}$。</li></ul></li><li><p><strong>顶点和边如何连接？</strong></p><ul><li>计算第 $i$ 个观测的重投影误差 $e_i$ 时，我们需要用到：<ol><li>相机的位姿（位姿顶点）。</li><li>第 $i$ 个三维点的坐标（第 $i$ 个点顶点）。</li><li>相机的内参 $K$（这个不是变量，而是已知参数）。</li></ol></li><li>这意味着每条边都需要连接<strong>一个位姿顶点</strong>和<strong>一个对应的三维点顶点</strong>。</li><li><strong>因此，这些边都是二元边 (Binary Edge)。</strong></li></ul></li><li><p><strong>相机内参 K 如何处理？</strong></p><ul><li>在这个例子中，相机内参 $K$ 是<strong>已知且固定</strong>的，我们<strong>不优化它</strong>。</li><li>但是，在计算重投影误差（边的工作）时又必须用到它。</li><li>g2o 提供了一种<strong>参数 (Parameter)</strong> 机制来处理这种情况。我们可以将相机内参封装成一个 <code>g2o::CameraParameters</code> 对象，并将其添加到优化器中。边在计算误差时可以访问这些参数。</li></ul></li></ul><p><strong>总结思路：</strong> 我们将创建一个图，包含：</p><ul><li>1 个 <code>VertexSE3Expmap</code> 类型的顶点（表示相机位姿）。</li><li>N 个 <code>VertexPointXYZ</code> 类型的顶点（表示 N 个三维点）。</li><li>1 个 <code>CameraParameters</code> 类型的参数（存储相机内参 K）。</li><li>N 条 <code>EdgeProjectXYZ2UV</code> 类型的二元边（每条边连接位姿顶点和一个点顶点，代表一个重投影误差约束，并关联相机参数）。<br>然后，让 g2o 优化这个图，调整所有顶点的值（位姿和点坐标），使得所有边的重投影误差平方和（考虑信息矩阵）最小。</li></ul><h3 id="3-g2o-实现步骤"><a href="#3-g2o-实现步骤" class="headerlink" title="3. g2o 实现步骤"></a>3. g2o 实现步骤</h3><p>根据 BA 的图优化思路，代码中执行了以下操作：</p><p><strong>3.1 定义&#x2F;选择顶点类型</strong></p><ul><li><strong>相机位姿顶点:</strong><ul><li>g2o 提供了预定义的 <code>g2o::VertexSE3Expmap</code>。</li><li>它内部使用 <code>SE3Quat</code> (包含 Eigen 的四元数和平移向量) 存储位姿估计值。</li><li>关键在于它的 <code>oplusImpl</code> 使用 <strong>李代数 se(3)</strong> 进行增量更新（通过指数映射），这对于表示旋转非常自然且避免了万向锁等问题。维度是 6。</li></ul></li><li><strong>三维点顶点:</strong><ul><li>g2o 提供了预定义的 <code>g2o::VertexPointXYZ</code>。</li><li>它内部使用 <code>Eigen::Vector3d</code> 存储点的 (x, y, z) 坐标。维度是 3。</li><li>它的 <code>oplusImpl</code> 是简单的向量加法。</li></ul></li></ul><p><strong>3.2 定义&#x2F;选择边类型</strong></p><ul><li><strong>重投影误差边:</strong><ul><li>g2o 提供了预定义的 <code>g2o::EdgeProjectXYZ2UV</code>。</li><li>它是一个二元边，模板参数为 <code>&lt;2, Eigen::Vector2d, g2o::VertexPointXYZ, g2o::VertexSE3Expmap&gt;</code>，表示：<ul><li>误差维度 <code>D=2</code> (误差是二维像素向量 $(u_{err}, v_{err})$)。</li><li>测量值类型 <code>E=Eigen::Vector2d</code> (存储观测到的像素坐标 $(u, v)$)。</li><li>连接的第一个顶点类型是 <code>VertexPointXYZ</code> (索引 0)。</li><li>连接的第二个顶点类型是 <code>VertexSE3Expmap</code> (索引 1)。</li></ul></li><li><strong>这个类内部已经实现了 <code>computeError()</code> 和 <code>linearizeOplus()</code>：</strong><ul><li><code>computeError()</code>: 获取位姿和点的当前估计值，获取相机参数，执行”世界坐标 -&gt; 相机坐标 -&gt; 像素坐标”的投影变换，计算预测像素坐标，然后用 <code>_measurement</code> (观测像素坐标) 减去预测坐标，得到 <code>_error</code>。</li><li><code>linearizeOplus()</code>: 计算 <code>_error</code> (2维) 相对于 <code>VertexPointXYZ</code> (3维) 的雅可比矩阵 (2x3) 和相对于 <code>VertexSE3Expmap</code> (6维李代数) 的雅可比矩阵 (2x6)。这是 BA 的核心数学推导，g2o 已经帮你做好了。</li></ul></li></ul></li></ul><p><strong>3.3 定义参数</strong></p><ul><li><strong>相机内参:</strong><ul><li>使用 <code>g2o::CameraParameters</code> 类。</li><li>需要用相机的焦距 $f_x$ (假设 $f_y&#x3D;f_x$) 和主点 $(c_x, c_y)$ 来构造它。</li><li>它需要设置一个 ID，并使用 <code>optimizer.addParameter()</code> 添加到优化器中。</li></ul></li></ul><p><strong>3.4 配置优化器</strong></p><ul><li><strong>目的:</strong> 设置求解策略。</li><li><strong>实现:</strong><ul><li><strong>块求解器:</strong> <code>BlockSolver&lt; BlockSolverTraits&lt;6, 3&gt; &gt;</code>。这里的 <code>&lt;6, 3&gt;</code> 通常与 BA 中涉及的主要变量维度（位姿 6D，点 3D）相关，尤其是在使用 Schur 消元时。</li><li><strong>线性求解器:</strong> <code>LinearSolverCSparse</code>。BA 问题通常规模较大但具有稀疏性（一个点只会被少数几个位姿看到），稀疏求解器是必要的。</li><li><strong>优化算法:</strong> <code>OptimizationAlgorithmLevenberg</code> (LM 算法) 是 BA 的常用选择，因为它结合了高斯牛顿法和梯度下降法的优点，比较鲁棒。</li><li><strong>创建 <code>SparseOptimizer</code></strong> 并设置算法和 <code>verbose</code> 模式。</li></ul></li></ul><p><strong>3.5 构建图</strong></p><ul><li><strong>目的:</strong> 将具体的顶点、边和参数加入优化器。</li><li><strong>实现:</strong><ul><li><strong>添加位姿顶点:</strong><ol><li>创建 <code>VertexSE3Expmap</code> 对象。</li><li>从输入的初始 <code>R</code> 和 <code>t</code> 创建 <code>g2o::SE3Quat</code> 对象，并用 <code>setEstimate()</code> 设置初始位姿。</li><li>设置 ID (例如 0)。</li><li>添加到优化器 <code>optimizer.addVertex()</code>。</li></ol></li><li><strong>添加三维点顶点:</strong><ol><li>遍历输入的 <code>points_3d</code>。</li><li>为每个点创建一个 <code>VertexPointXYZ</code> 对象。</li><li>用 <code>setEstimate()</code> 设置其初始坐标。</li><li>设置<strong>唯一</strong>的 ID (例如从 1 开始递增)。</li><li><strong><code>point-&gt;setMarginalized(true);</code></strong>: <strong>非常重要！</strong> 这告诉 g2o 在求解线性方程 $Hx &#x3D; -b$ 时，可以将这些点顶点对应的变量<strong>边缘化 (Marginalize Out)</strong>。这利用了 BA 问题的特殊结构（点只与少数位姿相关），通过 <strong>Schur 消元 (Schur Complement)</strong> 技巧，可以大大减小求解的线性系统的规模（只需求解与位姿相关的部分），从而显著提高效率。</li><li>添加到优化器 <code>optimizer.addVertex()</code>。</li></ol></li><li><strong>添加相机参数:</strong><ol><li>从内参矩阵 <code>K</code> 提取 $f_x, c_x, c_y$。</li><li>创建 <code>CameraParameters</code> 对象。</li><li>设置 ID (例如 0)。</li><li>添加到优化器 <code>optimizer.addParameter()</code>。</li></ol></li><li><strong>添加边:</strong><ol><li>遍历输入的 <code>points_2d</code> (需要与 <code>points_3d</code> 一一对应)。</li><li>为每个观测创建一个 <code>EdgeProjectXYZ2UV</code> 对象。</li><li>设置<strong>唯一</strong>的 ID (例如从 1 开始递增，与点 ID 对应)。</li><li><strong>连接顶点:</strong><ul><li><code>edge-&gt;setVertex(0, ...)</code> 连接到对应的<strong>点顶点</strong>。注意代码中使用了 <code>optimizer.vertex(index)</code> 通过 ID 获取顶点指针，并用 <code>dynamic_cast</code> 转换类型。</li><li><code>edge-&gt;setVertex(1, pose)</code> 连接到<strong>位姿顶点</strong>。</li></ul></li><li><strong>设置测量值:</strong> <code>edge-&gt;setMeasurement(Eigen::Vector2d(p.x, p.y))</code>，传入观测到的像素坐标。</li><li><strong>关联参数:</strong> <code>edge-&gt;setParameterId(0, 0)</code>。第一个 0 表示这是第 0 个参数集（CameraParameters），第二个 0 是该参数在优化器中的 ID。</li><li><strong>设置信息矩阵:</strong> <code>edge-&gt;setInformation(Eigen::Matrix2d::Identity())</code>。这里简单地使用了单位矩阵，表示假设所有像素观测的噪声是各向同性的，且方差为 1。在实际应用中，可以根据像素噪声的估计来设置更精确的信息矩阵（例如，$\frac{1}{\sigma^2} \mathbf{I}$，其中 $\sigma$ 是像素噪声标准差）。</li><li>添加到优化器 <code>optimizer.addEdge()</code>。</li></ol></li></ul></li></ul><p><strong>3.6 执行优化</strong></p><ul><li>调用 <code>optimizer.initializeOptimization()</code>。</li><li>调用 <code>optimizer.optimize(num_iterations)</code>。</li></ul><p><strong>3.7 获取结果</strong></p><ul><li>优化完成后，位姿顶点 <code>pose</code> 内部的 <code>_estimate</code> 已经被更新。</li><li>通过 <code>pose-&gt;estimate()</code> 获取优化后的 <code>g2o::SE3Quat</code>，可以将其转换回旋转矩阵 <code>R</code> 和平移向量 <code>t</code> (代码中直接输出了 <code>Isometry3d</code> 形式的变换矩阵)。</li><li>如果需要，也可以遍历所有点顶点，获取优化后的三维点坐标。</li></ul><h3 id="4-准备工作"><a href="#4-准备工作" class="headerlink" title="4. 准备工作"></a>4. 准备工作</h3><ul><li><strong>包含头文件:</strong> g2o 核心库、顶点类型 (<code>VertexSE3Expmap</code>, <code>VertexPointXYZ</code>)、边类型 (<code>EdgeProjectXYZ2UV</code>)、参数类型 (<code>CameraParameters</code>)、求解器、算法、Eigen 等。</li><li><strong>准备输入数据:</strong><ul><li><code>std::vector&lt;cv::Point3f&gt; points_3d</code>: 三维点坐标。</li><li><code>std::vector&lt;cv::Point2f&gt; points_2d</code>: 对应的二维观测点坐标。</li><li><code>cv::Mat K</code>: 相机内参矩阵。</li><li><code>cv::Mat R</code>, <code>cv::Mat t</code>: 相机位姿的初始估计。</li></ul></li><li><strong>数据类型转换:</strong> 需要将 OpenCV 的 <code>cv::Mat</code> (R, t) 和 <code>cv::Point</code> 转换为 g2o&#x2F;Eigen 使用的 <code>Eigen::Matrix3d</code>, <code>Eigen::Vector3d</code>, <code>Eigen::Vector2d</code> 等。</li></ul><h3 id="5-完整示例代码-带注释"><a href="#5-完整示例代码-带注释" class="headerlink" title="5. 完整示例代码 (带注释)"></a>5. 完整示例代码 (带注释)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen 核心库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Geometry&gt;</span> <span class="comment">// 用于 Isometry3d 等</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 核心库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/sparse_optimizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_binary_edge.h&gt;</span> <span class="comment">// 二元边基类</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 线性求解器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/solvers/csparse/linear_solver_csparse.h&gt;</span> <span class="comment">// CSparse 稀疏求解器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 类型定义 (常用的顶点和边)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/types/sba/types_sba.h&gt;</span> <span class="comment">// 包含 VertexSE3Expmap, VertexPointXYZ, EdgeProjectXYZ2UV, CameraParameters 等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/types/slam3d/se3quat.h&gt;</span> <span class="comment">// SE3Quat 定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenCV (用于数据结构 Point3f, Point2f, Mat)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> g2o;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用 g2o 进行 Bundle Adjustment (优化单个相机位姿和多个 3D 点)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param points_3d 输入的三维点坐标 (世界坐标系)</span></span><br><span class="line"><span class="comment"> * @param points_2d 对应的二维像素观测坐标</span></span><br><span class="line"><span class="comment"> * @param K         相机内参矩阵 (3x3)</span></span><br><span class="line"><span class="comment"> * @param R         相机旋转矩阵的初始估计 (3x3)</span></span><br><span class="line"><span class="comment"> * @param t         相机平移向量的初始估计 (3x1)</span></span><br><span class="line"><span class="comment"> * @note            函数会直接修改输入的 R 和 t 为优化后的结果 (虽然本示例代码没有显式传回，而是打印)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bundleAdjustment</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point3f&gt; points_3d,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> std::vector&lt;cv::Point2f&gt; points_2d,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> cv::Mat &amp;K, cv::Mat &amp;R, cv::Mat &amp;t)</span> </span>&#123; <span class="comment">// R, t 是引用，理论上可以修改后传出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 1. 配置 g2o 优化器 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Configuring g2o...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 定义块求解器类型: BlockSolver&lt; BlockSolverTraits&lt;PoseDim, LandmarkDim&gt; &gt;</span></span><br><span class="line">    <span class="comment">// PoseDim=6 (SE3), LandmarkDim=3 (XYZ)</span></span><br><span class="line">    <span class="keyword">typedef</span> BlockSolver&lt;BlockSolverTraits&lt;<span class="number">6</span>, <span class="number">3</span>&gt;&gt; BlockSolverType;</span><br><span class="line">    <span class="comment">// 定义线性求解器类型: 使用 CSparse 处理稀疏矩阵</span></span><br><span class="line">    <span class="keyword">typedef</span> LinearSolverCSparse&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType;</span><br><span class="line">    <span class="comment">// 创建线性求解器</span></span><br><span class="line">    <span class="keyword">auto</span> linearSolver = std::<span class="built_in">make_unique</span>&lt;LinearSolverType&gt;();</span><br><span class="line">    <span class="comment">// 创建块求解器</span></span><br><span class="line">    <span class="keyword">auto</span> blockSolver = std::<span class="built_in">make_unique</span>&lt;BlockSolverType&gt;(std::<span class="built_in">move</span>(linearSolver));</span><br><span class="line">    <span class="comment">// 创建优化算法: Levenberg-Marquardt</span></span><br><span class="line">    OptimizationAlgorithmLevenberg *algorithm = <span class="keyword">new</span> <span class="built_in">OptimizationAlgorithmLevenberg</span>(std::<span class="built_in">move</span>(blockSolver));</span><br><span class="line">    <span class="comment">// 创建稀疏优化器 (图模型)</span></span><br><span class="line">    SparseOptimizer optimizer;</span><br><span class="line">    <span class="comment">// 设置优化算法</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(algorithm);</span><br><span class="line">    <span class="comment">// 启用详细输出</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 2. 添加顶点 ---</span></span><br><span class="line">    <span class="comment">// a. 添加相机位姿顶点 (VertexSE3Expmap)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding pose vertex...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    VertexSE3Expmap *pose_vertex = <span class="keyword">new</span> <span class="built_in">VertexSE3Expmap</span>();</span><br><span class="line">    pose_vertex-&gt;<span class="built_in">setId</span>(<span class="number">0</span>); <span class="comment">// 顶点 ID 设为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输入的 R, t (cv::Mat) 转换为 g2o::SE3Quat 用于设置初始估计</span></span><br><span class="line">    Eigen::Matrix3d R_mat;</span><br><span class="line">    R_mat &lt;&lt; R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">             R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">             R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, <span class="number">1</span>), R.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">t_vec</span><span class="params">(t.at&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>), t.at&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>), t.at&lt;<span class="type">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    pose_vertex-&gt;<span class="built_in">setEstimate</span>(<span class="built_in">SE3Quat</span>(R_mat, t_vec)); <span class="comment">// 设置初始位姿估计</span></span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(pose_vertex); <span class="comment">// 添加到优化器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. 添加三维点顶点 (VertexPointXYZ)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding &quot;</span> &lt;&lt; points_3d.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; point vertices...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> point_index = <span class="number">1</span>; <span class="comment">// 点顶点的 ID 从 1 开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> cv::Point3f p : points_3d) &#123;</span><br><span class="line">        VertexPointXYZ *point_vertex = <span class="keyword">new</span> <span class="built_in">VertexPointXYZ</span>();</span><br><span class="line">        point_vertex-&gt;<span class="built_in">setId</span>(point_index++); <span class="comment">// 设置唯一 ID</span></span><br><span class="line">        point_vertex-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(p.x, p.y, p.z)); <span class="comment">// 设置初始坐标估计</span></span><br><span class="line">        <span class="comment">// **关键：边缘化点**。告诉优化器在求解时使用 Schur 消元，提高效率</span></span><br><span class="line">        point_vertex-&gt;<span class="built_in">setMarginalized</span>(<span class="literal">true</span>);</span><br><span class="line">        optimizer.<span class="built_in">addVertex</span>(point_vertex); <span class="comment">// 添加到优化器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 3. 添加相机参数 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding camera parameters...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 从内参矩阵 K 提取焦距 fx 和主点 cx, cy</span></span><br><span class="line">    <span class="type">double</span> fx = K.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">double</span> cx = K.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">double</span> cy = K.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 创建 CameraParameters 对象 (假设 fy=fx, baseline=0)</span></span><br><span class="line">    CameraParameters *camera = <span class="keyword">new</span> <span class="built_in">CameraParameters</span>(fx, Eigen::<span class="built_in">Vector2d</span>(cx, cy), <span class="number">0</span>);</span><br><span class="line">    camera-&gt;<span class="built_in">setId</span>(<span class="number">0</span>); <span class="comment">// 参数 ID 设为 0</span></span><br><span class="line">    optimizer.<span class="built_in">addParameter</span>(camera); <span class="comment">// 添加到优化器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 4. 添加边 (重投影误差) ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding &quot;</span> &lt;&lt; points_2d.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; edges...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> edge_index = <span class="number">1</span>; <span class="comment">// 边的 ID 也从 1 开始 (可以与点 ID 对应)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> cv::Point2f p : points_2d) &#123;</span><br><span class="line">        EdgeProjectXYZ2UV *edge = <span class="keyword">new</span> <span class="built_in">EdgeProjectXYZ2UV</span>();</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(edge_index); <span class="comment">// 设置唯一 ID</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// **连接顶点:**</span></span><br><span class="line">        <span class="comment">// 边需要连接两个顶点：点顶点 (索引 0) 和位姿顶点 (索引 1)</span></span><br><span class="line">        <span class="comment">// 通过 ID 在优化器中查找对应的点顶点指针</span></span><br><span class="line">        Vertex *point_v = optimizer.<span class="built_in">vertex</span>(edge_index); <span class="comment">// 假设边的 ID 与其对应的点顶点 ID 相同</span></span><br><span class="line">        <span class="keyword">if</span> (!point_v) &#123;</span><br><span class="line">             cerr &lt;&lt; <span class="string">&quot;Error: Point vertex with ID &quot;</span> &lt;&lt; edge_index &lt;&lt; <span class="string">&quot; not found!&quot;</span> &lt;&lt; endl;</span><br><span class="line">             <span class="keyword">continue</span>; <span class="comment">// 或者进行错误处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 dynamic_cast 进行类型安全的转换</span></span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, <span class="built_in">dynamic_cast</span>&lt;VertexPointXYZ *&gt;(point_v));</span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>, pose_vertex); <span class="comment">// 连接到位姿顶点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// **设置测量值:** 观测到的像素坐标 (u, v)</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(Eigen::<span class="built_in">Vector2d</span>(p.x, p.y));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **关联相机参数:**</span></span><br><span class="line">        <span class="comment">// 第一个 0: 表示这是第 0 组参数 (CameraParameters)</span></span><br><span class="line">        <span class="comment">// 第二个 0: 表示这组参数在优化器中的 ID 是 0</span></span><br><span class="line">        edge-&gt;<span class="built_in">setParameterId</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **设置信息矩阵:** 协方差矩阵的逆，表示测量的不确定性</span></span><br><span class="line">        <span class="comment">// 这里用单位矩阵，表示假设像素噪声是各向同性且方差为 1</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix2d::<span class="built_in">Identity</span>());</span><br><span class="line"></span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge); <span class="comment">// 添加到优化器</span></span><br><span class="line">        edge_index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 5. 执行优化 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Starting optimization...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">// 初始化</span></span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">10</span>);            <span class="comment">// 执行优化，这里只迭代 10 次作为示例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 6. 获取/输出结果 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Optimization finished.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 从位姿顶点获取优化后的估计值 (SE3Quat 类型)</span></span><br><span class="line">    SE3Quat optimized_pose = pose_vertex-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">    <span class="comment">// 将优化后的位姿转换为 Eigen::Isometry3d (方便表示为 4x4 变换矩阵)</span></span><br><span class="line">    <span class="function">Eigen::Isometry3d <span class="title">optimized_T</span><span class="params">(optimized_pose)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Optimized Transformation Matrix (T_world_camera): &quot;</span> &lt;&lt; endl &lt;&lt; optimized_T.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要，可以将 optimized_T 分解回 R 和 t 并更新输入的 cv::Mat</span></span><br><span class="line">    <span class="comment">// Eigen::Matrix3d optimized_R = optimized_T.rotation();</span></span><br><span class="line">    <span class="comment">// Eigen::Vector3d optimized_t = optimized_T.translation();</span></span><br><span class="line">    <span class="comment">// ... (代码将 Eigen 矩阵/向量写回 cv::Mat R, t) ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：本示例没有显式清理 new 出来的顶点、边、参数和算法对象。</span></span><br><span class="line">    <span class="comment">// 在实际应用中，如果优化器析构时没有自动管理这些资源，可能需要手动 delete。</span></span><br><span class="line">    <span class="comment">// 但通常 g2o 的 SparseOptimizer 会接管所有权。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 示例调用 (需要补充完整) ---</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">    // 1. 准备 points_3d, points_2d, K, R_initial, t_initial 数据</span></span><br><span class="line"><span class="comment">    std::vector&lt;cv::Point3f&gt; points_3d = &#123; ... &#125;;</span></span><br><span class="line"><span class="comment">    std::vector&lt;cv::Point2f&gt; points_2d = &#123; ... &#125;;</span></span><br><span class="line"><span class="comment">    cv::Mat K = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; fx, 0, cx, 0, fy, cy, 0, 0, 1);</span></span><br><span class="line"><span class="comment">    cv::Mat R_initial = ...; // 初始旋转</span></span><br><span class="line"><span class="comment">    cv::Mat t_initial = ...; // 初始平移</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 2. 调用 BA 函数</span></span><br><span class="line"><span class="comment">    bundleAdjustment(points_3d, points_2d, K, R_initial, t_initial);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 3. (可选) 使用优化后的 R_initial, t_initial</span></span><br><span class="line"><span class="comment">    // 注意：上面的函数示例仅打印结果，未修改 R_initial, t_initial</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—g2o库—曲线拟合</title>
      <link href="/2025/04/28/c8/"/>
      <url>/2025/04/28/c8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>我们有一系列二维数据点 $(x_i, y_i)$，我们相信这些数据点是由一个指数模型生成的，具体形式为：</p><p>$$y &#x3D; \exp(ax^2 + bx + c)$$</p><p>然而，我们的观测值 $y_i$ 包含噪声。我们的目标是：根据这些带有噪声的观测数据 $(x_i, y_i)$，<strong>估计出最可能生成这些数据的模型参数 $(a, b, c)$ 的值</strong>。</p><p>这本质上是一个优化问题：寻找一组参数 $(a, b, c)$，使得模型预测值 $\exp(ax_i^2 + bx_i + c)$ 与实际观测值 $y_i$ 之间的总误差最小（通常是最小化误差的平方和）。</p><h3 id="2-思考：如何用图优化解决？"><a href="#2-思考：如何用图优化解决？" class="headerlink" title="2. 思考：如何用图优化解决？"></a>2. 思考：如何用图优化解决？</h3><p>我们要将这个问题”翻译”成 g2o 的语言——图。一个图由 <strong>顶点 (Vertices)</strong> 和 <strong>边 (Edges)</strong> 组成。</p><ul><li><p><strong>顶点 (Vertex) 代表什么？</strong></p><ul><li>顶点代表了我们要优化的 <strong>未知变量</strong>。</li><li>在这个问题中，未知变量就是曲线的参数 $(a, b, c)$。这三个参数需要一起被估计，它们共同构成了一个状态。</li><li><strong>因此，我们将 $(a, b, c)$ 定义为一个 g2o 顶点。</strong></li></ul></li><li><p><strong>边 (Edge) 代表什么？</strong></p><ul><li>边代表了变量之间的 <strong>约束</strong> 或者 <strong>测量带来的误差项</strong>。</li><li>我们拥有的信息是 $N$ 个数据点 $(x_i, y_i)$。每一个数据点都提供了一个约束：对于给定的 $x_i$，由当前估计的 $(a, b, c)$ 计算出的预测值 $\exp(ax_i^2 + bx_i + c)$ 应该接近观测值 $y_i$。</li><li><strong>因此，每一个数据点 $(x_i, y_i)$ 都对应图中的一条边。</strong> 这条边衡量了模型预测值与实际测量值之间的误差（残差）。</li></ul></li><li><p><strong>顶点和边如何连接？</strong></p><ul><li>计算第 $i$ 个数据点的误差 $e_i &#x3D; y_i - \exp(ax_i^2 + bx_i + c)$ 时，我们只需要用到参数 $(a, b, c)$ （也就是那个唯一的顶点）和对应的 $x_i$ 值。</li><li>这意味着每条边 <strong>只连接到我们定义的那个参数顶点上</strong>。</li><li><strong>因此，这些边都是一元边 (Unary Edge)。</strong></li></ul></li></ul><p><strong>总结思路：</strong> 我们将创建一个包含 <strong>一个顶点</strong> (代表参数 a, b, c) 和 <strong>N 条一元边</strong> (每条边代表一个数据点 (x, y) 带来的约束&#x2F;误差) 的图。然后，让 g2o 优化这个图，调整顶点的值 (a, b, c)，使得所有边的误差平方和（考虑信息矩阵加权）最小。</p><h3 id="3-g2o-实现步骤"><a href="#3-g2o-实现步骤" class="headerlink" title="3. g2o 实现步骤"></a>3. g2o 实现步骤</h3><p>根据上面的思考，我们需要在 g2o 中完成以下步骤：</p><p><strong>3.1 定义顶点 (<code>CurveFittingVertex</code>)</strong></p><ul><li><strong>目的:</strong> 表示待优化的参数 $(a, b, c)$。</li><li><strong>实现:</strong><ul><li>继承 <code>g2o::BaseVertex&lt;D, T&gt;</code>。</li><li><code>D</code> (维度): 参数有 a, b, c 三个，所以维度是 <strong>3</strong>。</li><li><code>T</code> (类型): 用 Eigen 的三维向量 <code>Eigen::Vector3d</code> 来存储 $(a, b, c)$。</li><li>所以继承 <code>g2o::BaseVertex&lt;3, Eigen::Vector3d&gt;</code>。</li><li><strong>重写 <code>setToOriginImpl()</code>:</strong> 设置顶点的初始估计值。通常设为 (0, 0, 0)。</li><li><strong>重写 <code>oplusImpl()</code>:</strong> 定义如何将优化算法计算出的增量 <code>update</code> (一个包含 $\Delta a, \Delta b, \Delta c$ 的 3 维向量) 应用到当前估计值 <code>_estimate</code> 上。对于 $(a, b, c)$ 这种简单的向量空间变量，直接做向量加法 <code>_estimate += update</code> 即可。</li><li><code>read</code>&#x2F;<code>write</code> 函数在此例中可以留空。</li></ul></li></ul><p><strong>3.2 定义边 (<code>CurveFittingEdge</code>)</strong></p><ul><li><strong>目的:</strong> 表示每个数据点 $(x_i, y_i)$ 带来的约束，并计算其误差。</li><li><strong>实现:</strong><ul><li>继承 <code>g2o::BaseUnaryEdge&lt;D, E, VertexType&gt;</code> (因为只连接一个顶点)。</li><li><code>D</code> (误差维度): 误差 $e_i &#x3D; y_i - \exp(\dots)$ 是一个标量，所以维度是 <strong>1</strong>。</li><li><code>E</code> (测量值类型): 测量值 $y_i$ 是一个 <code>double</code> 类型。</li><li><code>VertexType</code>: 这条边连接的顶点类型是 <code>CurveFittingVertex</code>。</li><li>所以继承 <code>g2o::BaseUnaryEdge&lt;1, double, CurveFittingVertex&gt;</code>。</li><li><strong>构造函数:</strong> 计算误差时需要用到 $x_i$，但 $x_i$ 不是待优化变量，也不是全局参数。它只与这条特定的边（这个特定的数据点）相关。因此，在创建边对象时，需要将对应的 $x_i$ 传入并存储在边对象的成员变量 (如 <code>_x</code>) 中。</li><li><strong>重写 <code>computeError()</code>:</strong> 这是 <strong>边的核心</strong>。在此函数中：<ol><li>获取所连接的顶点 (<code>_vertices[0]</code>)。</li><li>获取顶点当前的估计值 $(a, b, c) &#x3D; \text{vertex}-&gt;\text{estimate}()$。</li><li>使用存储的 <code>_x</code> 和当前的 $(a, b, c)$ 计算预测值 $y_{pred} &#x3D; \exp(a\textit{x}^2 + b\textit{x} + c)$。</li><li>计算误差 $e &#x3D; \text{_measurement} - y_{pred}$，并将结果赋给 <code>_error(0,0)</code>。（<code>_measurement</code> 存储的是观测值 $y_i$，通过 <code>setMeasurement()</code> 设置）。</li></ol></li><li><strong><code>linearizeOplus()</code> (雅可比计算):</strong> 这个例子中 <strong>没有重写</strong> 这个函数。这意味着 g2o 会默认使用 <strong>自动求导</strong> 来计算误差 $e$ 对参数 $a, b, c$ 的偏导数 $(\frac{\partial e}{\partial a}, \frac{\partial e}{\partial b}, \frac{\partial e}{\partial c})$。对于简单问题，自动求导很方便；对于性能要求高的复杂问题，通常需要手动计算并重写此函数。</li><li><code>read</code>&#x2F;<code>write</code> 函数在此例中可以留空。</li></ul></li></ul><p><strong>3.3 配置优化器</strong></p><ul><li><strong>目的:</strong> 告诉 g2o 如何求解这个优化问题。</li><li><strong>实现:</strong><ul><li><strong>选择求解器类型:</strong><ul><li><code>BlockSolver</code>: 定义了优化变量（顶点）和误差（边）的维度。这里是 <code>BlockSolverTraits&lt;3, 1&gt;</code> (顶点维度 3, 边维度 1)。</li><li><code>LinearSolver</code>: 定义了如何求解线性方程组 $Hx &#x3D; -b$。对于规模不大的问题，可以用 <code>LinearSolverDense</code>；对于规模较大、稀疏性较好的问题（如 SLAM），常用 <code>LinearSolverCSparse</code> 或 <code>LinearSolverCholmod</code>。本例用了 <code>LinearSolverCSparse</code>。</li></ul></li><li><strong>选择优化算法:</strong><ul><li>常用的有 <code>OptimizationAlgorithmLevenberg</code> (LM 算法，鲁棒性好)、<code>OptimizationAlgorithmGaussNewton</code> (高斯牛顿法)、<code>OptimizationAlgorithmDogleg</code>。本例用了 LM 算法。</li></ul></li><li><strong>创建 <code>SparseOptimizer</code> 对象:</strong> 这是整个图优化的管理器。</li><li><strong>设置:</strong> 将选择的优化算法设置给 <code>SparseOptimizer</code>，可以设置 <code>setVerbose(true)</code> 来打印优化过程信息。</li></ul></li></ul><p><strong>3.4 构建图</strong></p><ul><li><strong>目的:</strong> 将具体的顶点和边添加到优化器中。</li><li><strong>实现:</strong><ul><li><strong>添加顶点:</strong><ol><li>创建 <code>CurveFittingVertex</code> 对象。</li><li>设置其初始估计值 (<code>setEstimate</code>)，例如 <code>(0, 0, 0)</code>。</li><li>设置其唯一 ID (<code>setId</code>)。</li><li>调用 <code>optimizer.addVertex()</code> 将其添加到图中。</li></ol></li><li><strong>添加边:</strong><ol><li>遍历所有数据点 $(x_i, y_i)$。</li><li>为每个数据点创建一个 <code>CurveFittingEdge</code> 对象，传入 $x_i$。</li><li>设置其唯一 ID (<code>setId</code>)。</li><li><strong>连接到顶点:</strong> 调用 <code>edge-&gt;setVertex(0, vertex_pointer)</code>，将边的第 0 个接口连接到之前创建的顶点。</li><li><strong>设置测量值:</strong> 调用 <code>edge-&gt;setMeasurement(y_i)</code>。</li><li><strong>设置信息矩阵:</strong> 调用 <code>edge-&gt;setInformation(...)</code>。信息矩阵是测量噪声协方差矩阵的逆，代表了这条边的权重。如果假设噪声是高斯分布，标准差为 $\sigma$，那么对于一维误差，信息矩阵就是 $1&#x2F;\sigma^2$。这告诉优化器：噪声越小（$\sigma$ 越小，信息矩阵越大），这个测量值就越可信，优化时应该更努力地满足这个约束。</li><li>调用 <code>optimizer.addEdge()</code> 将边添加到图中。</li></ol></li></ul></li></ul><p><strong>3.5 执行优化</strong></p><ul><li><strong>目的:</strong> 启动 g2o 的优化过程。</li><li><strong>实现:</strong><ul><li>调用 <code>optimizer.initializeOptimization()</code> 进行初始化。</li><li>调用 <code>optimizer.optimize(max_iterations)</code> 开始迭代优化，指定最大迭代次数。</li></ul></li></ul><p><strong>3.6 获取结果</strong></p><ul><li><strong>目的:</strong> 从优化后的图中提取最终的参数估计值。</li><li><strong>实现:</strong><ul><li>优化完成后，顶点对象内部的 <code>_estimate</code> 成员变量已经被更新为最优值。</li><li>直接调用 <code>vertex-&gt;estimate()</code> 即可获取优化后的 $(a, b, c)$。</li></ul></li></ul><h3 id="4-准备工作"><a href="#4-准备工作" class="headerlink" title="4. 准备工作"></a>4. 准备工作</h3><p>在编写 g2o 代码之前，需要：</p><ul><li><strong>包含头文件:</strong> 包含 g2o 核心库、求解器、算法以及 Eigen 库等必要的头文件。</li><li><strong>准备数据:</strong> 生成或加载用于拟合的数据点 <code>x_data</code> 和 <code>y_data</code>。例子中是程序内部生成的带高斯噪声的数据。</li><li><strong>定义参数:</strong> 确定噪声标准差 <code>w_sigma</code> (用于生成数据和设置信息矩阵)，数据点数量 <code>N</code> 等。</li></ul><h3 id="5-完整示例代码"><a href="#5-完整示例代码" class="headerlink" title="5. 完整示例代码"></a>5. 完整示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen 核心部分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 核心库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_unary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/block_solver.h&gt;</span> <span class="comment">// 块求解器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/sparse_optimizer.h&gt;</span> <span class="comment">// 优化器主类</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 优化算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o 线性求解器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span> <span class="comment">// 稠密求解器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/solvers/csparse/linear_solver_csparse.h&gt;</span> <span class="comment">// CSparse 稀疏求解器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenCV (仅用于随机数生成)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> g2o;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 1. 定义顶点：表示待优化参数 (a, b, c) ---</span></span><br><span class="line"><span class="comment">// 模板参数：优化变量维度 D=3, 数据类型 T=Eigen::Vector3d</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurveFittingVertex</span> : <span class="keyword">public</span> BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW <span class="comment">// Eigen 内存对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CurveFittingVertex</span>() &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置函数：设置初始估计值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>; <span class="comment">// 初始猜测 a=0, b=0, c=0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增量更新函数：如何应用优化增量</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *update)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _estimate += Eigen::<span class="built_in">Vector3d</span>(update); <span class="comment">// 直接向量加法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写函数 (本例中可以忽略)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 2. 定义边：表示每个数据点的约束和误差 ---</span></span><br><span class="line"><span class="comment">// 模板参数：误差维度 D=1, 测量值类型 E=double, 连接的顶点类型 CurveFittingVertex</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurveFittingEdge</span> : <span class="keyword">public</span> BaseUnaryEdge&lt;<span class="number">1</span>, <span class="type">double</span>, CurveFittingVertex&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数：传入该数据点对应的 x 值</span></span><br><span class="line">    <span class="built_in">CurveFittingEdge</span>(<span class="type">double</span> x) : <span class="built_in">BaseUnaryEdge</span>(), _x(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算误差函数：核心部分</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">computeError</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取连接的顶点 (强制类型转换)</span></span><br><span class="line">        <span class="type">const</span> CurveFittingVertex *v = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> CurveFittingVertex *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 获取顶点当前的估计值 (a, b, c)</span></span><br><span class="line">        <span class="type">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        <span class="comment">// 计算模型预测值 y_pred = exp(a*x^2 + b*x + c)</span></span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> prediction = std::<span class="built_in">exp</span>(<span class="built_in">abc</span>(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + <span class="built_in">abc</span>(<span class="number">1</span>, <span class="number">0</span>) * _x + <span class="built_in">abc</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 计算误差 error = measurement - prediction</span></span><br><span class="line">        <span class="comment">// _measurement 是基类成员，存储观测值 y_i</span></span><br><span class="line">        <span class="comment">// _error 是基类成员 (1x1 矩阵)，存储计算结果</span></span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - prediction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性化函数 (雅可比计算)</span></span><br><span class="line">    <span class="comment">// 本例中未实现，g2o 将使用自动求导</span></span><br><span class="line">    <span class="comment">// virtual void linearizeOplus() override &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写函数 (本例中可以忽略)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> _x; <span class="comment">// 存储该边对应的数据点的 x 值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// --- 数据准备 ---</span></span><br><span class="line">    <span class="type">double</span> real_a = <span class="number">1.0</span>, real_b = <span class="number">2.0</span>, real_c = <span class="number">1.0</span>; <span class="comment">// 真实参数</span></span><br><span class="line">    <span class="type">int</span> N = <span class="number">100</span>;                                     <span class="comment">// 数据点数量</span></span><br><span class="line">    <span class="type">double</span> w_sigma = <span class="number">1.0</span>;                            <span class="comment">// 噪声标准差</span></span><br><span class="line">    cv::RNG rng;                                     <span class="comment">// OpenCV 随机数生成器</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; x_data, y_data; <span class="comment">// 存储数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Generating data...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(real_a * x * x + real_b * x + real_c) + rng.<span class="built_in">gaussian</span>(w_sigma));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- g2o 配置 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Configuring g2o...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 1. 定义块求解器类型 BlockSolver&lt; BlockSolverTraits&lt;顶点维度, 边维度&gt; &gt;</span></span><br><span class="line">    <span class="keyword">typedef</span> BlockSolver&lt;BlockSolverTraits&lt;<span class="number">3</span>, <span class="number">1</span>&gt;&gt; BlockSolverType;</span><br><span class="line">    <span class="comment">// 2. 定义线性求解器类型</span></span><br><span class="line">    <span class="keyword">typedef</span> LinearSolverCSparse&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType;</span><br><span class="line">    <span class="comment">// 3. 创建线性求解器 (使用智能指针管理)</span></span><br><span class="line">    <span class="keyword">auto</span> linearSolver = std::<span class="built_in">make_unique</span>&lt;LinearSolverType&gt;();</span><br><span class="line">    <span class="comment">// 4. 创建块求解器 (使用智能指针管理)</span></span><br><span class="line">    <span class="keyword">auto</span> blockSolver = std::<span class="built_in">make_unique</span>&lt;BlockSolverType&gt;(std::<span class="built_in">move</span>(linearSolver));</span><br><span class="line">    <span class="comment">// 5. 创建优化算法 (Levenberg-Marquardt)</span></span><br><span class="line">    OptimizationAlgorithmLevenberg *algorithm = <span class="keyword">new</span> <span class="built_in">OptimizationAlgorithmLevenberg</span>(std::<span class="built_in">move</span>(blockSolver));</span><br><span class="line">    <span class="comment">// 6. 创建稀疏优化器 (图模型)</span></span><br><span class="line">    SparseOptimizer optimizer;</span><br><span class="line">    <span class="comment">// 7. 设置优化算法</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(algorithm);</span><br><span class="line">    <span class="comment">// 8. 启用详细输出</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 构建图 ---</span></span><br><span class="line">    <span class="comment">// 1. 添加顶点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding vertex...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    CurveFittingVertex *vertex = <span class="keyword">new</span> <span class="built_in">CurveFittingVertex</span>();</span><br><span class="line">    vertex-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 设置初始值</span></span><br><span class="line">    vertex-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);                             <span class="comment">// 设置 ID</span></span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(vertex);                  <span class="comment">// 添加到图中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加边</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Adding &quot;</span> &lt;&lt; N &lt;&lt; <span class="string">&quot; edges...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        CurveFittingEdge *edge = <span class="keyword">new</span> <span class="built_in">CurveFittingEdge</span>(x_data[i]); <span class="comment">// 创建边，传入 x_i</span></span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(i);                                          <span class="comment">// 设置 ID</span></span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, vertex);                              <span class="comment">// 连接到顶点</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(y_data[i]);                         <span class="comment">// 设置测量值 y_i</span></span><br><span class="line">        <span class="comment">// 设置信息矩阵 (1x1)，值为 1 / sigma^2</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="type">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>() * <span class="number">1</span> / (w_sigma * w_sigma));</span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);                                 <span class="comment">// 添加到图中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 执行优化 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Starting optimization...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">// 初始化</span></span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">100</span>);            <span class="comment">// 执行优化，最多 100 次迭代</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 输出结果 ---</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Optimization finished.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Eigen::Vector3d estimated_abc = vertex-&gt;<span class="built_in">estimate</span>(); <span class="comment">// 获取优化后的顶点估计值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Estimated model parameters (a, b, c): &quot;</span> &lt;&lt; estimated_abc.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Real model parameters (a, b, c):      &quot;</span> &lt;&lt; real_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; real_b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; real_c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 (OptimizationAlgorithmLevenberg* algorithm 是 new 出来的，理论上应 delete，</span></span><br><span class="line">    <span class="comment">// 但 setAlgorithm 后 optimizer 会接管，通常不需要手动 delete)</span></span><br><span class="line">    <span class="comment">// delete algorithm; // 可能导致重复释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—Ceres库</title>
      <link href="/2025/04/27/c7/"/>
      <url>/2025/04/27/c7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>略</p><h2 id="2-问题定义"><a href="#2-问题定义" class="headerlink" title="2. 问题定义"></a>2. 问题定义</h2><p>以 $y &#x3D; \exp \left( {a{x}^{2} + {bx} + c}\right)$ 为例</p><p>我们现在拥有一系列的观测值</p><table><thead><tr><th align="center">x</th><th align="center">$x_1$</th><th align="center">$x_2$</th><th align="center">…</th><th align="center">$x_n$</th></tr></thead><tbody><tr><td align="center">y</td><td align="center">$y_1$</td><td align="center">$y_2$</td><td align="center">…</td><td align="center">$y_n$</td></tr></tbody></table><p>目标是用函数 $y &#x3D; \exp(ax^2 + bx + c)$ 拟合这些数据点，确定参数 $a$、$b$ 和 $c$ 的最佳值</p><p>在迭代的某一步，假设我们有参数的当前估计值 $a_k$、$b_k$ 和 $c_k$。</p><p>对于每个数据点 $x_i$，我们可以计算模型预测值 ：$\hat{y}_i$</p><p>$\hat{y}_i &#x3D; \exp(a_k x_i^2 + b_k x_i + c_k)$</p><p>那么<strong>残差</strong>就是实际观测值与预测值的差</p><p>$r_i &#x3D; y_i - \hat{y}_i &#x3D; y_i - \exp(a_k x_i^2 + b_k x_i + c_k)$</p><p>我们不希望正负残差相互抵消，所以计算残差的平方，然后求和得到<strong>代价函数</strong>：</p><p>$J(a, b, c) &#x3D; \sum_{i&#x3D;1}^{n} r_i^2 &#x3D; \sum_{i&#x3D;1}^{n} [y_i - \exp(a x_i^2 + b x_i + c)]^2$</p><p>最小二乘法的目标是找到参数 $a$、$b$ 和 $c$ 的值，使得代价函数 $J(a, b, c)$ 最小。即：</p><p>$\min_{a, b, c} J(a, b, c) &#x3D; \min_{a, b, c} \sum_{i&#x3D;1}^{n} [y_i - \exp(a x_i^2 + b x_i + c)]^2$</p><h2 id="3-三种求解方式"><a href="#3-三种求解方式" class="headerlink" title="3. 三种求解方式"></a>3. 三种求解方式</h2><h3 id="3-1-方法一：解析求导"><a href="#3-1-方法一：解析求导" class="headerlink" title="3.1 方法一：解析求导"></a>3.1 方法一：解析求导</h3><p>这种方法需要我们手动计算雅可比矩阵，并将其提供给 Ceres。</p><h3 id="3-1-1-计算雅可比矩阵"><a href="#3-1-1-计算雅可比矩阵" class="headerlink" title="3.1.1 计算雅可比矩阵"></a>3.1.1 计算雅可比矩阵</h3><p>我们有残差 $r(a, b, c) &#x3D; y - \exp(ax^2 + bx + c)$<br>令 $E &#x3D; \exp(ax^2 + bx + c)$<br>使用链式法则求偏导：</p><ul><li>$\frac{\partial r}{\partial a} &#x3D; - \frac{\partial E}{\partial a} &#x3D; - E \cdot \frac{\partial (ax^2 + bx + c)}{\partial a} &#x3D; - E \cdot x^2$</li><li>$\frac{\partial r}{\partial b} &#x3D; - \frac{\partial E}{\partial b} &#x3D; - E \cdot \frac{\partial (ax^2 + bx + c)}{\partial b} &#x3D; - E \cdot x$</li><li>$\frac{\partial r}{\partial c} &#x3D; - \frac{\partial E}{\partial c} &#x3D; - E \cdot \frac{\partial (ax^2 + bx + c)}{\partial c} &#x3D; - E \cdot 1$</li></ul><h3 id="3-1-2-实现-Ceres-Cost-Function"><a href="#3-1-2-实现-Ceres-Cost-Function" class="headerlink" title="3.1.2 实现 Ceres Cost Function"></a>3.1.2 实现 Ceres Cost Function</h3><p>在Ceres Solver中实现解析求导，我们需要继承的是<code>ceres::SizedCostFunction</code>类。</p><p><code>SizedCostFunction</code>是一个模板类，参数格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceres::SizedCostFunction&lt;残差数量, 参数块<span class="number">1</span>大小, 参数块<span class="number">2</span>大小, ...&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于这个问题（拟合模型 y &#x3D; exp(ax² + bx + c)）：</p><ul><li><strong>残差数量</strong> &#x3D; 1（每个观测点产生1个残差值）</li><li><strong>参数块大小</strong> &#x3D; 3（我们优化的参数是a, b, c）</li></ul><p>所以我们需要继承的类是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceres::SizedCostFunction&lt;<span class="number">1</span>, <span class="number">3</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义我们的CostFunction类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析求导的Cost Function</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExponentialResidualAnalytic</span> : <span class="keyword">public</span> ceres::SizedCostFunction&lt;<span class="number">1</span>, <span class="number">3</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ExponentialResidualAnalytic</span>(<span class="type">double</span> x, <span class="type">double</span> y)</span><br><span class="line">        : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须重写的Evaluate函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Evaluate</span><span class="params">(<span class="type">double</span> <span class="type">const</span>* <span class="type">const</span>* parameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">double</span>* residuals,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">double</span>** jacobians)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储数据点的成员变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x_;  <span class="comment">// x坐标</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> y_;  <span class="comment">// y坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现Evaluate函数</p><p>这是最重要的一步，它包含两部分：</p><ol><li>计算残差值（必须）</li><li>计算雅可比矩阵（可选，但解析求导的关键）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ExponentialResidualAnalytic::Evaluate</span><span class="params">(<span class="type">double</span> <span class="type">const</span>* <span class="type">const</span>* parameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">double</span>* residuals,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">double</span>** jacobians)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取参数值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> a = parameters[<span class="number">0</span>][<span class="number">0</span>];  <span class="comment">// 第一个参数块的第一个元素</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> b = parameters[<span class="number">0</span>][<span class="number">1</span>];  <span class="comment">// 第一个参数块的第二个元素</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> c = parameters[<span class="number">0</span>][<span class="number">2</span>];  <span class="comment">// 第一个参数块的第三个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 计算残差 r = y - exp(ax² + bx + c)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> exponent = a * x_ * x_ + b * x_ + c;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> prediction = std::<span class="built_in">exp</span>(exponent);</span><br><span class="line">    residuals[<span class="number">0</span>] = y_ - prediction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 如果需要计算雅可比矩阵（这是一种优化策略，有时候迭代过程中不需要计算就会传入null）</span></span><br><span class="line">    <span class="keyword">if</span> (jacobians != <span class="literal">nullptr</span> &amp;&amp; jacobians[<span class="number">0</span>] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 我们要计算残差对参数a, b, c的偏导数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预先计算的exp项（提高效率）</span></span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> exp_term = std::<span class="built_in">exp</span>(exponent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dr/da = -exp(ax² + bx + c) * x²</span></span><br><span class="line">        jacobians[<span class="number">0</span>][<span class="number">0</span>] = -exp_term * x_ * x_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dr/db = -exp(ax² + bx + c) * x</span></span><br><span class="line">        jacobians[<span class="number">0</span>][<span class="number">1</span>] = -exp_term * x_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dr/dc = -exp(ax² + bx + c)</span></span><br><span class="line">        jacobians[<span class="number">0</span>][<span class="number">2</span>] = -exp_term;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回计算成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-1-3-Evaluate函数参数详解"><a href="#3-1-3-Evaluate函数参数详解" class="headerlink" title="3.1.3 Evaluate函数参数详解"></a>3.1.3 Evaluate函数参数详解</h3><p><strong>1. <code>double const* const* parameters</code></strong></p><ul><li>这是一个指向指针数组的指针</li><li><code>parameters[i]</code>访问第i个参数块（我们只有一个参数块，所以使用<code>parameters[0]</code>）</li><li><code>parameters[0][j]</code>访问第一个参数块的第j个元素</li></ul><p><strong>2. <code>double* residuals</code></strong></p><ul><li>用于存储计算的残差值</li><li><code>residuals[i]</code>写入第i个残差值（我们只有一个残差，所以使用<code>residuals[0]</code>）</li></ul><p><strong>3. <code>double** jacobians</code></strong></p><ul><li>用于存储计算的雅可比矩阵</li><li>如果为<code>nullptr</code>，表示优化器不需要计算雅可比矩阵</li><li><code>jacobians[i]</code>指向与第i个参数块相关的雅可比矩阵</li><li><code>jacobians[0][j]</code>存储残差对第一个参数块中第j个参数的偏导数</li></ul><h3 id="3-2-方法二：自动求导-Automatic-Differentiation"><a href="#3-2-方法二：自动求导-Automatic-Differentiation" class="headerlink" title="3.2 方法二：自动求导 (Automatic Differentiation)"></a>3.2 方法二：自动求导 (Automatic Differentiation)</h3><p>这是 Ceres 推荐的方法之一，因为它结合了易用性和效率。我们只需要定义一个计算残差的模板化 “Functor”，Ceres 会自动计算导数。</p><h3 id="3-2-1-Functor-结构基本形式"><a href="#3-2-1-Functor-结构基本形式" class="headerlink" title="3.2.1 Functor 结构基本形式"></a>3.2.1 Functor 结构基本形式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ExponentialResidualAutoDiff</span> &#123;</span><br><span class="line">    <span class="comment">// 构造函数：保存每个残差项所需的输入数据</span></span><br><span class="line">    <span class="built_in">ExponentialResidualAutoDiff</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板化的 operator()：这是自动求导的关键</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* <span class="type">const</span> parameters, T* residual)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从参数数组中提取参数</span></span><br><span class="line">        <span class="comment">// 执行计算</span></span><br><span class="line">        <span class="comment">// 设置残差</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储每个数据点的信息</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x_;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-2-关键点详解"><a href="#3-2-2-关键点详解" class="headerlink" title="3.2.2 关键点详解"></a>3.2.2 关键点详解</h3><h3 id="模板化-operator"><a href="#模板化-operator" class="headerlink" title="模板化 operator()"></a>模板化 operator()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* <span class="type">const</span> parameters, T* residual)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>这是自动求导的核心。这里的类型 <code>T</code> 是关键，Ceres 会：</p><ul><li>使用 <code>T = double</code> 调用此函数来计算残差值</li><li>使用 <code>T = ceres::Jet&lt;double, N&gt;</code> 调用此函数来计算导数</li></ul><p><code>ceres::Jet</code> 类型是 Ceres 的特殊类型，它存储了值和对应的导数信息。当函数使用 <code>Jet</code> 类型执行计算时，它自动跟踪导数。</p><h3 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h3><ul><li><code>const T* const parameters</code>：包含优化参数的数组</li><li><code>T* residual</code>：输出残差的数组</li><li>返回 <code>bool</code>：表示计算是否成功</li></ul><h3 id="3-2-3-详细示例：分步解析"><a href="#3-2-3-详细示例：分步解析" class="headerlink" title="3.2.3 详细示例：分步解析"></a>3.2.3 详细示例：分步解析</h3><p>对于模型 $y &#x3D; \exp(ax^2 + bx + c)$，以下是详细的自动求导 Functor 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ExponentialResidualAutoDiff</span> &#123;</span><br><span class="line">    <span class="comment">// 构造函数：存储每个数据点的 x 和 y 值</span></span><br><span class="line">    <span class="built_in">ExponentialResidualAutoDiff</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* <span class="type">const</span> parameters, T* residual)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 步骤 1: 从参数数组中提取 a, b, c</span></span><br><span class="line">        <span class="type">const</span> T a = parameters[<span class="number">0</span>];</span><br><span class="line">        <span class="type">const</span> T b = parameters[<span class="number">1</span>];</span><br><span class="line">        <span class="type">const</span> T c = parameters[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 2: 将常量 x_ 和 y_ 转换为类型 T</span></span><br><span class="line">        <span class="comment">// 这是必要的，因为所有计算都需要在 T 类型的环境中进行</span></span><br><span class="line">        <span class="type">const</span> T x = <span class="built_in">T</span>(x_);</span><br><span class="line">        <span class="type">const</span> T y = <span class="built_in">T</span>(y_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 3: 计算模型预测值</span></span><br><span class="line">        <span class="comment">// 注意：所有数学运算都使用 T 类型的变量</span></span><br><span class="line">        T exponent = a * x * x + b * x + c;</span><br><span class="line">        T prediction = <span class="built_in">exp</span>(exponent);  <span class="comment">// 使用与 T 兼容的 exp 函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 4: 计算残差 (observed - predicted)</span></span><br><span class="line">        residual[<span class="number">0</span>] = y - prediction;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 数据点的 x 和 y 值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x_;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-方法三：数值求导-Numeric-Differentiation"><a href="#3-3-方法三：数值求导-Numeric-Differentiation" class="headerlink" title="3.3 方法三：数值求导 (Numeric Differentiation)"></a>3.3 方法三：数值求导 (Numeric Differentiation)</h3><p>这种方法最容易实现，因为我们只需要提供计算残差的函数。Ceres 会通过微小地改变参数值并观察残差的变化来近似计算雅可比矩阵。但它通常比自动或解析求导慢，并且可能不太精确。</p><h3 id="3-3-1-实现-Functor-与自动求导类似，但非模板化"><a href="#3-3-1-实现-Functor-与自动求导类似，但非模板化" class="headerlink" title="3.3.1 实现 Functor (与自动求导类似，但非模板化)"></a>3.3.1 实现 Functor (与自动求导类似，但非模板化)</h3><p>创建一个结构体（或类），重载 <code>operator()</code>，但这次只使用 <code>double</code> 类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值求导的 Functor</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ExponentialResidualNumeric</span> &#123;</span><br><span class="line">    <span class="built_in">ExponentialResidualNumeric</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：这里 operator() 不是模板化的</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">double</span>* <span class="type">const</span> parameters, <span class="type">double</span>* residual)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> a = parameters[<span class="number">0</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> b = parameters[<span class="number">1</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> c = parameters[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> x = x_;</span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> y = y_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算预测值 prediction = exp(ax^2 + bx + c)</span></span><br><span class="line">        <span class="type">double</span> exponent_term = a * x * x + b * x + c;</span><br><span class="line">        <span class="type">double</span> prediction = std::<span class="built_in">exp</span>(exponent_term);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算残差 residual = y - prediction</span></span><br><span class="line">        residual[<span class="number">0</span>] = y - prediction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x_; <span class="comment">// 观测数据 x</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> y_; <span class="comment">// 观测数据 y</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-后续步骤"><a href="#4-后续步骤" class="headerlink" title="4. 后续步骤"></a>4. 后续步骤</h2><p>流程：</p><ol><li><p><strong>定义残差函数</strong>：使用解析求导、自动求导或数值求导</p></li><li><p><strong>创建和配置 Problem</strong>：</p><p> 在 Ceres 中，<code>Problem</code> 是整个优化问题的容器，它包含了所有残差块和参数块。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceres::Problem problem;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 上面这行代码创建了一个空的 Problem 对象。接下来，我们需要向它添加残差块（即我们前面定义的成本函数）。</p><ul><li>添加残差块</li></ul><p> 对于每个数据点 $(x_i, y_i)$，我们需要添加一个残差块。这是通过 <code>AddResidualBlock</code> 方法完成的：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; x_data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    ceres::CostFunction* cost_function =</span><br><span class="line">        <span class="keyword">new</span> ceres::<span class="built_in">AutoDiffCostFunction</span>&lt;ExponentialResidualAutoDiff, <span class="number">1</span>, <span class="number">3</span>&gt;(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">ExponentialResidualAutoDiff</span>(x_data[i], y_data[i])</span><br><span class="line">        );</span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(cost_function,</span><br><span class="line">                             <span class="literal">nullptr</span>, <span class="comment">// 使用默认的平方损失函数</span></span><br><span class="line">                             parameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 这段代码的详细解释：</p><ol><li><strong>创建成本函数</strong>：<ul><li>对于自动求导，我们使用 <code>AutoDiffCostFunction&lt;&gt;</code> 类</li><li>模板参数 <code>ExponentialResidualAutoDiff</code> 是我们的函数对象类型</li><li><code>1</code> 表示残差的维度（每个观测产生一个标量残差）</li><li><code>3</code> 表示参数块的大小（我们的参数是 a, b, c 三个值）</li><li>构造函数参数是我们的函数对象实例，它保存了特定的 $x_i$ 和 $y_i$ 值</li></ul></li><li><strong>添加残差块</strong>：<ul><li><p><code>AddResidualBlock</code> 将成本函数添加到问题中</p></li><li><p>第一个参数是成本函数指针</p></li><li><p>第二个参数是损失函数指针（<code>nullptr</code> 表示使用默认的平方损失函数）</p><p>  损失函数用于减轻离群点（outliers）的影响。当为 <code>nullptr</code> 时，Ceres 使用默认的平方损失函数，即直接对残差平方求和。</p><p>  如果需要使用鲁棒损失函数，比如 Huber 损失，可以这样写：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceres::LossFunction* loss_function = <span class="keyword">new</span> ceres::<span class="built_in">HuberLoss</span>(<span class="number">1.0</span>);</span><br><span class="line">problem.<span class="built_in">AddResidualBlock</span>(cost_function, loss_function, parameters);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>第三个参数是指向我们要优化的参数数组的指针</p></li></ul></li></ol><ul><li><p>设置参数约束（如有需要）</p><p>  除了添加残差块外，还可以对参数设置一些约束：</p><ol><li><p><strong>固定某些参数</strong>（使它们在优化过程中不变）：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">problem.<span class="built_in">SetParameterBlockConstant</span>(parameters + <span class="number">2</span>); <span class="comment">// 固定第三个参数 c</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>设置参数的上下界</strong>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">problem.<span class="built_in">SetParameterLowerBound</span>(parameters, <span class="number">0</span>, <span class="number">0.0</span>); <span class="comment">// 设置 a &gt;= 0</span></span><br><span class="line">problem.<span class="built_in">SetParameterUpperBound</span>(parameters, <span class="number">1</span>, <span class="number">0.0</span>); <span class="comment">// 设置 b &lt;= 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p><strong>配置求解器选项</strong></p><p> 求解器负责实际运行优化算法。我们通过 <code>Solver::Options</code> 对象来配置求解器：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ceres::Solver::Options options;</span><br><span class="line">options.linear_solver_type = ceres::DENSE_QR;</span><br><span class="line">options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">options.max_num_iterations = <span class="number">50</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 详细解释：</p><ol><li><strong><code>linear_solver_type</code></strong>：<ul><li>在每次迭代中，非线性最小二乘问题会被线性化，产生一个线性子问题</li><li>这个选项决定如何求解这个线性子问题</li><li><code>DENSE_QR</code> 适合小规模问题（参数和残差数量都不太多）</li><li>对于大规模问题，可以考虑 <code>SPARSE_NORMAL_CHOLESKY</code> 或 <code>ITERATIVE_SCHUR</code> 等</li></ul></li><li><strong><code>minimizer_progress_to_stdout</code></strong>：<ul><li>设为 <code>true</code> 时会在优化过程中打印进度信息</li><li>非常有用，可以看到成本函数的下降情况和收敛过程</li></ul></li><li><strong><code>max_num_iterations</code></strong>：<ul><li>最大迭代次数</li><li>防止算法在难以收敛的情况下无限循环</li></ul></li></ol><p> 其他常用选项包括：</p><ul><li><strong><code>function_tolerance</code></strong>：当成本函数相对变化小于此值时停止</li><li><strong><code>gradient_tolerance</code></strong>：当梯度范数小于此值时停止</li><li><strong><code>parameter_tolerance</code></strong>：当参数相对变化小于此值时停止</li><li><strong><code>num_threads</code></strong>：使用的线程数量（并行化）</li></ul></li><li><p><strong>运行求解器</strong></p><p> 设置好 Problem 和 Options 后，调用 <code>Solve</code> 函数执行优化：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceres::Solver::Summary summary;</span><br><span class="line">ceres::Solve(options, &amp;problem, &amp;summary);</span><br></pre></td></tr></table></figure><p> 这会执行优化算法并将结果存储在 <code>summary</code> 对象中。优化过程完成后，最优参数值会被直接写入到我们提供给 Problem 的 <code>parameters</code> 数组中。</p></li><li><p><strong>分析结果</strong></p><p> 优化完成后，通常需要：</p><ol><li><p><strong>检查优化状态</strong>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p> 这会打印一个简短报告，包括终止状态、迭代次数、求解时间等</p></li><li><p><strong>查看最终参数值</strong>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; parameters[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; a_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; parameters[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; b_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; parameters[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; c_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>计算最终代价</strong>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> final_cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; x_data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">double</span> residual = y_data[i] - std::<span class="built_in">exp</span>(parameters[<span class="number">0</span>] * x_data[i] * x_data[i] +</span><br><span class="line">                                        parameters[<span class="number">1</span>] * x_data[i] + parameters[<span class="number">2</span>]);</span><br><span class="line">    final_cost += residual * residual;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Final Total Cost: &quot;</span> &lt;&lt; final_cost &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="5-完整代码实现"><a href="#5-完整代码实现" class="headerlink" title="5. 完整代码实现"></a>5. 完整代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于生成模拟数据的真实参数</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> a_true = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> b_true = <span class="number">2.0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> c_true = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成带噪声的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate_data</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt;&amp; x_data, std::vector&lt;<span class="type">double</span>&gt;&amp; y_data, <span class="type">int</span> num_points = <span class="number">100</span>, <span class="type">double</span> noise_stddev = <span class="number">0.1</span>)</span> </span>&#123;</span><br><span class="line">    x_data.<span class="built_in">resize</span>(num_points);</span><br><span class="line">    y_data.<span class="built_in">resize</span>(num_points);</span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">generator</span><span class="params">(<span class="number">123</span>)</span></span>; <span class="comment">// Use a fixed seed for reproducibility</span></span><br><span class="line">    <span class="function">std::normal_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, noise_stddev)</span></span>; <span class="comment">// 高斯噪声</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Generated Data:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_points; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> x = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i) / (num_points / <span class="number">10.0</span>); <span class="comment">// x 从 0 到 9.9 or similar range</span></span><br><span class="line">        x_data[i] = x;</span><br><span class="line">        <span class="type">double</span> y_clean = std::<span class="built_in">exp</span>(a_true * x * x + b_true * x + c_true);</span><br><span class="line">        <span class="type">double</span> noise = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        y_data[i] = y_clean + noise;</span><br><span class="line">        <span class="comment">// Optional: Print generated data to verify</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y_clean: &quot; &lt;&lt; y_clean &lt;&lt; &quot;, y_observed: &quot; &lt;&lt; y_data[i] &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Data generation complete. &quot;</span> &lt;&lt; num_points &lt;&lt; <span class="string">&quot; points generated.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]); <span class="comment">// 初始化 glog</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 生成数据</span></span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; x_data;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; y_data;</span><br><span class="line">    <span class="built_in">generate_data</span>(x_data, y_data, <span class="number">100</span>, <span class="number">0.2</span>); <span class="comment">// 使用 100 个点，噪声标准差 0.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置初始参数估计值</span></span><br><span class="line">    <span class="type">double</span> initial_a = <span class="number">0.9</span>;</span><br><span class="line">    <span class="type">double</span> initial_b = <span class="number">1.1</span>;</span><br><span class="line">    <span class="type">double</span> initial_c = <span class="number">0.9</span>;</span><br><span class="line">    <span class="type">double</span> parameters[<span class="number">3</span>] = &#123;initial_a, initial_b, initial_c&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 构建 Ceres 问题 (Problem)</span></span><br><span class="line">    ceres::Problem problem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 选择一种求导方法并将残差块添加到 Problem ---</span></span><br><span class="line">    <span class="comment">// --- 一次只能取消注释一个方法块来测试 ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法一：使用解析求导</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;\nUsing Analytic Differentiation:\n&quot;;</span></span><br><span class="line"><span class="comment">    for (size_t i = 0; i &lt; x_data.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">        ceres::CostFunction* cost_function =</span></span><br><span class="line"><span class="comment">            new ExponentialResidualAnalytic(x_data[i], y_data[i]);</span></span><br><span class="line"><span class="comment">        problem.AddResidualBlock(cost_function,</span></span><br><span class="line"><span class="comment">                                 nullptr, // 使用默认的平方损失函数</span></span><br><span class="line"><span class="comment">                                 parameters);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法二：使用自动求导</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nUsing Automatic Differentiation:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; x_data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        ceres::CostFunction* cost_function =</span><br><span class="line">            <span class="keyword">new</span> ceres::<span class="built_in">AutoDiffCostFunction</span>&lt;ExponentialResidualAutoDiff, <span class="number">1</span>, <span class="number">3</span>&gt;(</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">ExponentialResidualAutoDiff</span>(x_data[i], y_data[i])</span><br><span class="line">            );</span><br><span class="line">        problem.<span class="built_in">AddResidualBlock</span>(cost_function,</span><br><span class="line">                                 <span class="literal">nullptr</span>, <span class="comment">// 使用默认的平方损失函数</span></span><br><span class="line">                                 parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法三：使用数值求导</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;\nUsing Numeric Differentiation:\n&quot;;</span></span><br><span class="line"><span class="comment">    for (size_t i = 0; i &lt; x_data.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">        ceres::CostFunction* cost_function =</span></span><br><span class="line"><span class="comment">            new ceres::NumericDiffCostFunction&lt;ExponentialResidualNumeric, ceres::CENTRAL, 1, 3&gt;(</span></span><br><span class="line"><span class="comment">                new ExponentialResidualNumeric(x_data[i], y_data[i])</span></span><br><span class="line"><span class="comment">            );</span></span><br><span class="line"><span class="comment">        problem.AddResidualBlock(cost_function,</span></span><br><span class="line"><span class="comment">                                 nullptr, // 使用默认的平方损失函数</span></span><br><span class="line"><span class="comment">                                 parameters);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 配置求解器 (Solver)</span></span><br><span class="line">    ceres::Solver::Options options;</span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR; <span class="comment">// 对于小型问题，DENSE_QR 通常足够</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;  <span class="comment">// 将优化过程输出到控制台</span></span><br><span class="line">    options.max_num_iterations = <span class="number">50</span>;             <span class="comment">// 最大迭代次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 运行求解器</span></span><br><span class="line">    ceres::Solver::Summary summary;</span><br><span class="line">    ceres::<span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSolver Summary:\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; summary.FullReport() &lt;&lt; &quot;\n&quot;; // 更详细的报告</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nEstimated parameters:\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; parameters[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; a_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; parameters[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; b_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; parameters[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; (True: &quot;</span> &lt;&lt; c_true &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最终的总代价 (Sum of Squared Errors)</span></span><br><span class="line">    <span class="type">double</span> final_cost = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; x_data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">         <span class="type">double</span> residual = y_data[i] - std::<span class="built_in">exp</span>(parameters[<span class="number">0</span>] * x_data[i] * x_data[i] + parameters[<span class="number">1</span>] * x_data[i] + parameters[<span class="number">2</span>]);</span><br><span class="line">         final_cost += residual * residual;</span><br><span class="line">     &#125;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Final Total Cost (Sum of Squared Errors): &quot;</span> &lt;&lt; final_cost &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-如何选择求导方法"><a href="#6-如何选择求导方法" class="headerlink" title="6. 如何选择求导方法"></a>6. 如何选择求导方法</h2><ul><li><strong>自动求导 (AutoDiff):</strong> 通常是<strong>首选</strong>。它易于实现（只需写 Functor），准确（不像数值求导有近似误差），并且通常比数值求导快。Ceres 对其进行了高度优化。</li><li><strong>解析求导 (Analytic):</strong> 如果你能正确无误地推导出雅可比矩阵并实现它，这通常是<strong>最快</strong>的方法。但是，手动求导和实现很容易出错，尤其对于复杂的模型。调试起来也比较困难。</li><li><strong>数值求导 (Numeric):</strong> <strong>最容易实现</strong>，因为你只需要提供计算残差的函数。但它通常是<strong>最慢</strong>的，并且其精度受限于步长选择（Ceres 会尝试选择合适的步长），可能在某些情况下导致收敛性问题。适合快速原型设计或当解析&#x2F;自动求导难以实现时。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—cmake的新旧方法</title>
      <link href="/2025/04/24/c5/"/>
      <url>/2025/04/24/c5/</url>
      
        <content type="html"><![CDATA[<h1 id="CMake新旧方法对比详解"><a href="#CMake新旧方法对比详解" class="headerlink" title="CMake新旧方法对比详解"></a>CMake新旧方法对比详解</h1><h2 id="一、include-directories-vs-target-include-directories"><a href="#一、include-directories-vs-target-include-directories" class="headerlink" title="一、include_directories() vs target_include_directories()"></a>一、include_directories() vs target_include_directories()</h2><p>这两者的核心区别在于<strong>作用域(Scope)</strong>：</p><h3 id="1-include-directories-AFTER-BEFORE-SYSTEM-dir1-dir2-…"><a href="#1-include-directories-AFTER-BEFORE-SYSTEM-dir1-dir2-…" class="headerlink" title="1. include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])"></a>1. include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])</h3><p><strong>作用域：目录级别</strong></p><ul><li><strong>作用:</strong> 将指定的目录添加到<strong>当前<code>CMakeLists.txt</code>文件以及所有在它之后处理的子目录</strong>的头文件搜索路径中</li><li><strong>影响:</strong> 在调用后定义的<strong>所有目标</strong>都会将这些目录添加到它们的include路径中</li><li><strong>特点:</strong> 类似于”全局”设置（在当前目录及子目录范围内）</li><li><strong>问题:</strong> 不够精确，可能导致目标获得不必要的包含路径</li></ul><h3 id="2-target-include-directories-SYSTEM-AFTER-BEFORE-items1…-items2…-…"><a href="#2-target-include-directories-SYSTEM-AFTER-BEFORE-items1…-items2…-…" class="headerlink" title="2. target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1…] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2…] …])"></a>2. target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1…] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2…] …])</h3><p><strong>作用域：目标级别</strong></p><ul><li><strong>作用:</strong> 将指定的目录添加到**特定目标<code>&lt;target&gt;</code>**的头文件搜索路径中</li><li><strong>影响:</strong> 只有指定的<code>&lt;target&gt;</code>会使用这些include路径</li><li><strong>关键修饰符:</strong><ul><li><code>PRIVATE</code>: 目录只用于编译<code>&lt;target&gt;</code>自身，不会传递给依赖者</li><li><code>PUBLIC</code>: 目录既用于编译<code>&lt;target&gt;</code>自身，也会传递给依赖<code>&lt;target&gt;</code>的其他目标</li><li><code>INTERFACE</code>: 目录不用于编译<code>&lt;target&gt;</code>自身，但会传递给依赖<code>&lt;target&gt;</code>的其他目标</li></ul></li><li><strong>优点:</strong> 非常精确和清晰，为每个目标精确指定所需的头文件路径</li></ul><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table><thead><tr><th>特性</th><th><code>include_directories()</code></th><th><code>target_include_directories()</code></th></tr></thead><tbody><tr><td><strong>作用域</strong></td><td>目录级别 (影响当前及子目录所有后续目标)</td><td>目标级别 (只影响指定目标)</td></tr><tr><td><strong>精确性</strong></td><td>低</td><td>高</td></tr><tr><td><strong>封装性</strong></td><td>差 (设置是”全局”的)</td><td>好 (设置附加到具体目标)</td></tr><tr><td><strong>现代推荐</strong></td><td><strong>否</strong> (除非有特定全局需求)</td><td><strong>是</strong> (现代CMake的核心用法)</td></tr><tr><td><strong>依赖传递</strong></td><td>不直接处理</td><td>通过<code>PUBLIC</code>&#x2F;<code>INTERFACE</code>关键字明确控制</td></tr></tbody></table><h2 id="二、CMake旧方式-vs-新方式-现代CMake"><a href="#二、CMake旧方式-vs-新方式-现代CMake" class="headerlink" title="二、CMake旧方式 vs 新方式(现代CMake)"></a>二、CMake旧方式 vs 新方式(现代CMake)</h2><p>核心区别在于从<strong>基于变量和全局&#x2F;目录设置</strong>转向<strong>基于目标及其属性</strong>。</p><h3 id="1-旧方式-Variable-Centric-Directory-Scoped-CMake-2-x时代"><a href="#1-旧方式-Variable-Centric-Directory-Scoped-CMake-2-x时代" class="headerlink" title="1. 旧方式 (Variable-Centric, Directory-Scoped - CMake 2.x时代)"></a>1. 旧方式 (Variable-Centric, Directory-Scoped - CMake 2.x时代)</h3><p><strong>核心思想:</strong> <code>find_package</code>等命令设置全局变量，手动使用这些变量配置目标</p><h4 id="典型流程"><a href="#典型流程" class="headerlink" title="典型流程:"></a>典型流程:</h4><ol><li><p><strong>查找和配置库</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(SomeLib REQUIRED)</span><br><span class="line"><span class="comment"># 执行FindSomeLib.cmake或旧式SomeLibConfig.cmake</span></span><br><span class="line"><span class="comment"># 设置变量：SomeLib_FOUND, SomeLib_INCLUDE_DIRS, SomeLib_LIBRARIES等</span></span><br></pre></td></tr></table></figure></li><li><p><strong>手动应用这些变量</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局设置，影响后续所有目标</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;SomeLib_INCLUDE_DIRS&#125;</span>) </span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;SomeLib_DEFINITIONS&#125;</span>)     </span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"><span class="comment"># 手动链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app <span class="variable">$&#123;SomeLib_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="特点与问题"><a href="#特点与问题" class="headerlink" title="特点与问题:"></a>特点与问题:</h4><ul><li><strong>全局状态:</strong> 变量和设置通常影响整个目录或项目，容易冲突</li><li><strong>手动管理:</strong> 需了解每个库设置的变量，手动应用到目标的各属性</li><li><strong>传递依赖困难:</strong> 如<code>my_app</code>依赖<code>my_lib</code>，而<code>my_lib</code>依赖<code>SomeLib</code>，则<code>my_app</code>的配置文件可能也需了解<code>SomeLib</code>，破坏封装性</li><li><strong>不够清晰:</strong> 链接指令通常只是变量引用，不明确表达依赖关系</li></ul><h3 id="2-新方式-Modern-CMake-Target-Centric-CMake-3-0-时代"><a href="#2-新方式-Modern-CMake-Target-Centric-CMake-3-0-时代" class="headerlink" title="2. 新方式 (Modern CMake &#x2F; Target-Centric - CMake 3.0+时代)"></a>2. 新方式 (Modern CMake &#x2F; Target-Centric - CMake 3.0+时代)</h3><p><strong>核心思想:</strong> 将构建所需的所有信息附加到目标上，使用导入目标(Imported Targets)</p><h4 id="典型流程-1"><a href="#典型流程-1" class="headerlink" title="典型流程:"></a>典型流程:</h4><ol><li><p><strong>查找和配置库</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(SomeLib REQUIRED)</span><br><span class="line"><span class="comment"># 执行现代SomeLibConfig.cmake</span></span><br><span class="line"><span class="comment"># 定义导入目标，如SomeLib::Core</span></span><br></pre></td></tr></table></figure></li><li><p><strong>直接链接导入目标</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只需链接目标，CMake自动处理其他所有事情</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE SomeLib::Core)</span><br></pre></td></tr></table></figure></li></ol><h4 id="特点与优势"><a href="#特点与优势" class="headerlink" title="特点与优势:"></a>特点与优势:</h4><ul><li><strong>目标即一切:</strong> 所有配置围绕目标进行，使用<code>target_*</code>系列命令</li><li><strong>封装性:</strong> 库的使用细节被封装在导入目标中，配置文件只需知道目标名称</li><li><strong>自动传递依赖:</strong> 链接导入目标时，该目标的公共依赖自动传递</li><li><strong>清晰明确:</strong> 链接指令直接表明依赖关系</li><li><strong>精确控制:</strong> 使用<code>PRIVATE</code>&#x2F;<code>PUBLIC</code>&#x2F;<code>INTERFACE</code>关键字精确控制依赖传递</li></ul><h3 id="对比总结-1"><a href="#对比总结-1" class="headerlink" title="对比总结"></a>对比总结</h3><table><thead><tr><th>方面</th><th>旧方式 (Variable-Centric)</th><th>新方式 (Target-Centric)</th></tr></thead><tbody><tr><td><strong>核心</strong></td><td>全局&#x2F;目录变量 (<code>_DIRS</code>, <code>_LIBS</code>)</td><td>目标及其属性 (<code>target_*</code>命令, 导入目标)</td></tr><tr><td><strong><code>find_package</code></strong></td><td>主要设置变量</td><td>主要定义导入目标 (<code>Namespace::Target</code>)</td></tr><tr><td><strong>配置方式</strong></td><td>手动应用变量到目标</td><td>链接导入目标，CMake自动处理细节</td></tr><tr><td><strong>包含路径</strong></td><td><code>include_directories()</code> (全局)</td><td><code>target_include_directories()</code> (目标级)</td></tr><tr><td><strong>链接</strong></td><td><code>target_link_libraries(... $&#123;..._LIBS&#125;)</code></td><td><code>target_link_libraries(... Namespace::Target)</code></td></tr><tr><td><strong>依赖传递</strong></td><td>手动处理，易出错</td><td>自动处理 (通过<code>PUBLIC</code>&#x2F;<code>INTERFACE</code>)</td></tr><tr><td><strong>封装性</strong></td><td>差</td><td>好</td></tr><tr><td><strong>推荐度</strong></td><td>不推荐</td><td><strong>强烈推荐</strong></td></tr></tbody></table><h2 id="三、实践建议"><a href="#三、实践建议" class="headerlink" title="三、实践建议"></a>三、实践建议</h2><ol><li><p><strong>始终优先使用现代CMake方法</strong></p><ul><li>使用<code>target_*</code>系列命令而非全局设置</li><li>链接导入目标而非变量列表</li></ul></li><li><p><strong>合理使用作用域关键字</strong></p><ul><li><code>PRIVATE</code>: 仅在目标内部使用，不传递给依赖者</li><li><code>PUBLIC</code>: 在目标内部使用且传递给依赖者</li><li><code>INTERFACE</code>: 不在目标内部使用，仅传递给依赖者</li></ul></li><li><p><strong>创建自己的库时</strong></p><ul><li>导出明确的目标而非变量</li><li>正确设置<code>PUBLIC</code>和<code>INTERFACE</code>属性以确保依赖正确传递</li></ul></li><li><p><strong>处理旧式库时</strong></p><ul><li>可以创建接口库封装旧式变量，使其符合现代CMake风格</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(SomeOldLib::SomeOldLib INTERFACE IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(SomeOldLib::SomeOldLib PROPERTIES</span><br><span class="line">  INTERFACE_INCLUDE_DIRECTORIES <span class="string">&quot;$&#123;SomeOldLib_INCLUDE_DIRS&#125;&quot;</span></span><br><span class="line">  INTERFACE_LINK_LIBRARIES <span class="string">&quot;$&#123;SomeOldLib_LIBRARIES&#125;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—find原理—以ceres为例子的实操</title>
      <link href="/2025/04/24/c6/"/>
      <url>/2025/04/24/c6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-更新-locate-数据库（必做！）"><a href="#1-更新-locate-数据库（必做！）" class="headerlink" title="1. 更新 locate 数据库（必做！）"></a>1. 更新 locate 数据库（必做！）</h2><ul><li><strong>操作:</strong> 打开终端，运行 <code>sudo updatedb</code></li><li><strong>原因:</strong> 确保 locate 的数据库包含你刚刚安装的新库的文件信息，否则后续步骤可能找不到任何内容</li></ul><h2 id="2-初步定位：查找核心配置文件-Config-cmake"><a href="#2-初步定位：查找核心配置文件-Config-cmake" class="headerlink" title="2. 初步定位：查找核心配置文件 (Config.cmake)"></a>2. 初步定位：查找核心配置文件 (Config.cmake)</h2><ul><li><strong>操作:</strong> 运行以下命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;ceres&#x27;</span></span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/home/xfy/3d/ceres/ceres-solver/build/third_party/abseil-cpp/abslConfig.cmake</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/cmake/CeresConfig.cmake.in</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/cmake/CreateCeresConfig.cmake</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/third_party/abseil-cpp/CMake/abslConfig.cmake.in</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/third_party/googletest/googletest/cmake/Config.cmake.in</span><br><span class="line">/usr/lib/cmake/Ceres/CeresConfig.cmake</span><br><span class="line">/usr/local/lib/cmake/Ceres/CeresConfig.cmake</span><br></pre></td></tr></table></figure><p>可以看到最后两行就是要找的，一个是系统级安装目录，一个是用户安装目录的。</p><h2 id="3-确定-find-package-名称"><a href="#3-确定-find-package-名称" class="headerlink" title="3. 确定 find_package 名称"></a>3. 确定 find_package 名称</h2><p>由CeresConfig.cmake可以知道这里的名称大小写是Ceres，所以应该是<code>find_package(Ceres REQUIRED)</code></p><h2 id="4-如何使用"><a href="#4-如何使用" class="headerlink" title="4. 如何使用"></a>4. 如何使用</h2><p>这个文档的注释中没有像OpenCV那样写出如何使用，此时就需要自己来寻找。</p><p>首先查找*Config.cmake 文件中是否有创建目标的代码：</p><ul><li><code>add_library(库名 IMPORTED)</code></li><li><code>add_library(库名::组件名 IMPORTED)</code></li></ul><p>这里查找看到：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">TARGET</span> ceres)</span><br><span class="line">  <span class="comment"># For backwards compatibility, create a local &#x27;alias&#x27; target with the</span></span><br><span class="line">  <span class="comment"># non-namespace-qualified Ceres target name. Note that this is not a</span></span><br><span class="line">  <span class="comment"># true ALIAS library in CMake terms as they cannot point to imported targets.</span></span><br><span class="line">  <span class="keyword">add_library</span>(ceres INTERFACE IMPORTED)</span><br><span class="line">  <span class="keyword">set_target_properties</span>(ceres PROPERTIES INTERFACE_LINK_LIBRARIES Ceres::ceres)</span><br></pre></td></tr></table></figure><p>创建了目标<code>Ceres::ceres</code>。</p><p>既然创建了目标，那说明是cmake的新使用方法就行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(my_app Ceres::ceres)</span><br></pre></td></tr></table></figure><h3 id="通用方法判断库是否提供导入目标"><a href="#通用方法判断库是否提供导入目标" class="headerlink" title="通用方法判断库是否提供导入目标"></a>通用方法判断库是否提供导入目标</h3><p>从这个 Ceres 的例子中，我们可以总结出一些通用方法来判断任何库是否提供导入目标：</p><ol><li><strong>查看库的配置文件</strong>：<ul><li>寻找 <code>include($&#123;XXX_DIR&#125;/XXXTargets.cmake)</code> 这样的语句</li><li>寻找 <code>add_library(XXX::XXX IMPORTED)</code> 这样的语句</li><li>寻找 <code>set_target_properties(XXX::XXX ...)</code> 这样的语句</li></ul></li><li><strong>查看库变量的设置</strong>：<ul><li>如果看到 <code>set(XXX_LIBRARIES XXX::XXX)</code>，表明库提供了导入目标</li></ul></li></ol><p>如果是传统方式的话：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统方式 - 需要同时设置包含目录和链接库</span></span><br><span class="line"><span class="comment"># 例外，在ceres和opencv的cmake中都说明了不需要target_include_directories</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PRIVATE <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-补充小知识：findpackage的查找顺序"><a href="#5-补充小知识：findpackage的查找顺序" class="headerlink" title="5. 补充小知识：findpackage的查找顺序"></a>5. 补充小知识：findpackage的查找顺序</h2><ol><li><strong>首先检查 Ceres_DIR 变量</strong><ul><li>如果设置了 Ceres_DIR，CMake 会直接查找该目录下的 CeresConfig.cmake</li><li>如果找到了有效的配置文件，查找过程立即结束</li></ul></li><li><strong>然后才会搜索 CMAKE_PREFIX_PATH</strong></li><li><strong>接着是 CMAKE_FRAMEWORK_PATH 和 CMAKE_APPBUNDLE_PATH</strong>（主要用于 macOS）</li><li><strong>最后是标准系统安装位置</strong><ul><li>&#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;Ceres&#x2F;</li><li>&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;Ceres&#x2F;</li></ul></li></ol><h3 id="如果想要指定版本，有两种方式："><a href="#如果想要指定版本，有两种方式：" class="headerlink" title="如果想要指定版本，有两种方式："></a>如果想要指定版本，有两种方式：</h3><ol><li><p><strong>使用 CMAKE_PREFIX_PATH（推荐）</strong></p><p> 这是最通用、最干净的方式，尤其是当处理多个第三方库时：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令行设置</span></span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=/home/xfy/3d/ceres/ceres-solver/build ..</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 或在 CMakeLists.txt 中：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 find_package 之前设置</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_PREFIX_PATH <span class="string">&quot;/home/xfy/3d/ceres/ceres-solver/build&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Ceres REQUIRED)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>优点</strong>：</p><ul><li>可以一次性指定多个库的搜索路径</li><li>不需要为每个库单独设置变量</li><li>是 CMake 推荐的方式</li></ul></li><li><p><strong>使用特定库的 _DIR 变量</strong></p><p> 对于单个库，直接设置其专用变量也很有效：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令行方式</span></span><br><span class="line">cmake -DCeres_DIR=/home/xfy/3d/ceres/ceres-solver/build/lib/cmake/Ceres ..</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 或在 CMakeLists.txt 中：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(Ceres_DIR <span class="string">&quot;/home/xfy/3d/ceres/ceres-solver/build/lib/cmake/Ceres&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Ceres REQUIRED)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>注意</strong>：Ceres_DIR 应该指向包含 CeresConfig.cmake 的确切目录，而不仅仅是构建目录。其中Ceres就是<strong>find_package名称</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—find原理—以opencv为例子的实操</title>
      <link href="/2025/04/24/c4/"/>
      <url>/2025/04/24/c4/</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>更新 <code>locate</code> 数据库 (必做！)</strong></p><ul><li><strong>操作:</strong> 打开终端，运行 <code>sudo updatedb</code>。</li><li><strong>原因:</strong> 确保 <code>locate</code> 的数据库包含你刚刚安装的新库的文件信息。否则后续步骤可能什么也找不到。</li></ul></li><li><p><strong>初步定位：查找核心配置文件 (<code>Config.cmake</code>)</strong></p><ul><li><p><strong>操作:</strong> 运行以下命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;opencv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为</span></span><br><span class="line">~ ❯ locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;opencv&#x27;</span></span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/3rdparty/ade/ade-0.1.1f/sources/ade/cmake/adeConfig.cmake.in</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/CPackConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/CPackSourceConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/OpenCVConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/opencv_python_config.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/unix-install/OpenCVConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/cmake/OpenCVGenConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/cmake/OpenCVGenPkgconfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/cmake/templates/OpenCVConfig.cmake.in</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/samples/hal/c_hal/config.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/samples/hal/slow_hal/config.cmake</span><br><span class="line">/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVConfig.cmake</span><br><span class="line">/usr/local/opencv/4.5.5/lib/cmake/opencv4/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/3rdparty/ade/ade-0.1.1f/sources/ade/cmake/adeConfig.cmake.in</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/CPackConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/CPackSourceConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/opencv_python_config.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/unix-install/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/cmake/OpenCVGenConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/cmake/OpenCVGenPkgconfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/cmake/templates/OpenCVConfig.cmake.in</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/samples/hal/c_hal/config.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/samples/hal/slow_hal/config.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/usr/local/lib/cmake/opencv4/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/1f605c5b588ec93f0f1947a29092b374d5fd184eedbfea41eba42bc85f33b932/diff/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVConfig.cmake</span><br></pre></td></tr></table></figure><p>  可以看到有很多，但是我知道我是安装到&#x2F;usr&#x2F;local&#x2F;的所以看&#x2F;usr&#x2F;local&#x2F;opencv&#x2F;4.5.5&#x2F;lib&#x2F;cmake&#x2F;opencv4&#x2F;OpenCVConfig.cmake<br>  这一个</p></li></ul></li><li><p><strong>确定 <code>find_package</code> 名称</strong></p><p> 由OpenCVConfig.cmake可以知道这里的名称大小写是OpenCV，所以应该是find_package(OpenCV REQUIRED)</p><p> 这里可以指定模块，也可以不指定，没有太大影响的。之前文章的例子里指定了模块的写法是find_package(OpenCV REQUIRED COMPONENTS core imgcodecs highgui)</p></li><li><p><strong>然后通过gedit或者vim等等查看这个文件</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  The OpenCV CMake configuration file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#             ** File generated automatically, do not modify **</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Usage from an external project:</span></span><br><span class="line"><span class="comment">#    In your CMakeLists.txt, add these lines:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED)</span></span><br><span class="line"><span class="comment">#    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # Not needed for CMake &gt;= 2.8.11</span></span><br><span class="line"><span class="comment">#    target_link_libraries(MY_TARGET_NAME $&#123;OpenCV_LIBS&#125;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Or you can search for specific OpenCV modules:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core videoio)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    You can also mark OpenCV components as optional:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core OPTIONAL_COMPONENTS viz)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    If the module is found then OPENCV_&lt;MODULE&gt;_FOUND is set to TRUE.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    This file will define the following variables:</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIBS                     : The list of all imported targets for OpenCV modules.</span></span><br><span class="line"><span class="comment">#      - OpenCV_INCLUDE_DIRS             : The OpenCV include directories.</span></span><br><span class="line"><span class="comment">#      - OpenCV_COMPUTE_CAPABILITIES     : The version of compute capability.</span></span><br><span class="line"><span class="comment">#      - OpenCV_ANDROID_NATIVE_API_LEVEL : Minimum required level of Android API.</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION                  : The version of this OpenCV build: &quot;4.5.5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MAJOR            : Major version part of OpenCV_VERSION: &quot;4&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MINOR            : Minor version part of OpenCV_VERSION: &quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_PATCH            : Patch version part of OpenCV_VERSION: &quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_STATUS           : Development status of this build: &quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Advanced variables:</span></span><br><span class="line"><span class="comment">#      - OpenCV_SHARED                   : Use OpenCV as shared library</span></span><br><span class="line"><span class="comment">#      - OpenCV_INSTALL_PATH             : OpenCV location</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIB_COMPONENTS           : Present OpenCV modules list</span></span><br><span class="line"><span class="comment">#      - OpenCV_USE_MANGLED_PATHS        : Mangled OpenCV path flag</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Deprecated variables:</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_TWEAK            : Always &quot;0&quot;</span></span><br></pre></td></tr></table></figure><p> 翻译一下</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================================================</span></span><br><span class="line"><span class="comment">#  OpenCV CMake 配置文件</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#             ** 文件自动生成，请勿修改 **</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  从外部项目使用：</span></span><br><span class="line"><span class="comment">#    在你的 CMakeLists.txt 中，添加这些行：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED)</span></span><br><span class="line"><span class="comment">#    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # 对于 CMake &gt;= 2.8.11 已不再需要</span></span><br><span class="line"><span class="comment">#    target_link_libraries(MY_TARGET_NAME $&#123;OpenCV_LIBS&#125;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    或者你可以搜索特定的 OpenCV 模块：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core videoio)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    你也可以将 OpenCV 组件标记为可选：</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core OPTIONAL_COMPONENTS viz)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    如果找到了模块，那么 OPENCV_&lt;MODULE&gt;_FOUND 会被设置为 TRUE。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    该文件将定义以下变量：</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIBS                     : OpenCV 模块的所有导入目标 (imported targets) 的列表。</span></span><br><span class="line"><span class="comment">#      - OpenCV_INCLUDE_DIRS             : OpenCV 的包含目录。</span></span><br><span class="line"><span class="comment">#      - OpenCV_COMPUTE_CAPABILITIES     : 计算能力 (Compute Capability) 的版本。</span></span><br><span class="line"><span class="comment">#      - OpenCV_ANDROID_NATIVE_API_LEVEL : 最低要求的 Android API 级别。</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION                  : 此 OpenCV 构建的版本：&quot;4.5.5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MAJOR            : OpenCV_VERSION 的主版本号：&quot;4&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MINOR            : OpenCV_VERSION 的次版本号：&quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_PATCH            : OpenCV_VERSION 的修订版本号：&quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_STATUS           : 此构建的开发状态：&quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    高级变量：</span></span><br><span class="line"><span class="comment">#      - OpenCV_SHARED                   : 将 OpenCV 作为共享库使用</span></span><br><span class="line"><span class="comment">#      - OpenCV_INSTALL_PATH             : OpenCV 的位置</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIB_COMPONENTS           : 当前存在的 OpenCV 模块列表</span></span><br><span class="line"><span class="comment">#      - OpenCV_USE_MANGLED_PATHS        : Mangled OpenCV 路径标志</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    已弃用变量：</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_TWEAK            : 始终为 &quot;0&quot;</span></span><br></pre></td></tr></table></figure><p> 可以看到这里说明了执行findpackage之后给哪些变量赋予了哪些值，也写了用法</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  从外部项目使用：</span></span><br><span class="line"><span class="comment">#    在你的 CMakeLists.txt 中，添加这些行：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED)</span></span><br><span class="line"><span class="comment">#    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # 对于 CMake &gt;= 2.8.11 已不再需要</span></span><br><span class="line"><span class="comment">#    target_link_libraries(MY_TARGET_NAME $&#123;OpenCV_LIBS&#125;)</span></span><br></pre></td></tr></table></figure><p> 这段注释虽然目的是指导用户，但它本身混合了新旧两种风格的痕迹，我们需要仔细解读：</p><ol><li><strong>旧方式 (Variable-Based) 的体现：</strong><ul><li><p><strong>明确的指令:</strong> 注释中明确给出了以下使用步骤：</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MY_TARGET_NAME <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p>这是典型的旧式 CMake 用法。它依赖于 <code>find_package</code> 执行后设置的两个<strong>变量</strong>：</p><ul><li><code>$&#123;OpenCV_INCLUDE_DIRS&#125;</code>: 包含了需要添加到编译器搜索路径的头文件目录。你需要手动调用 <code>include_directories()</code> (或现代的 <code>target_include_directories()</code>) 来使用它。</li><li><code>$&#123;OpenCV_LIBS&#125;</code>: 包含了需要链接的库文件列表（可能是库文件的绝对路径，也可能在旧 CMake 中是链接器标志）。你需要手动将这个变量传递给 <code>target_link_libraries()</code>。</li></ul></li></ul></li><li><strong>新方式 (Target-Based) 的线索和提示：</strong><ul><li><p><strong>关键注释:</strong> <code>include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # Not needed for CMake &gt;= 2.8.11</code></p><ul><li>这是<strong>最强烈的暗示</strong>。它告诉你，对于较新版本的 CMake (2.8.11 及以后，实际上现代 CMake 实践通常指 3.x 系列)，手动添加 <code>OpenCV_INCLUDE_DIRS</code> 是<strong>不必要</strong>的。为什么？因为现代 CMake 的核心是<strong>目标 (Target)</strong>。当你链接到一个设计良好的<strong>导入目标 (Imported Target)</strong> 时，这个目标本身就封装了它所需的包含目录、链接库、编译定义等信息。CMake 会自动将这些信息传递给链接它的目标。</li></ul></li><li><p><strong>变量 <code>OpenCV_LIBS</code> 的描述:</strong> <code>OpenCV_LIBS : The list of all **imported targets** for OpenCV modules.</code></p><ul><li>这一点非常重要！虽然旧方式的使用示例中是 <code>target_link_libraries(... $&#123;OpenCV_LIBS&#125;)</code>，但这里对 <code>OpenCV_LIBS</code> 变量内容的描述明确指出了它包含的是 <strong>“imported targets”</strong>。这意味着 <code>$&#123;OpenCV_LIBS&#125;</code> 变量里存放的不再仅仅是库文件名或路径，而是 CMake 能理解的、代表了 OpenCV 各个模块的<strong>目标名称</strong>列表（例如 <code>OpenCV::core</code>, <code>OpenCV::imgproc</code> 等）。</li></ul></li><li><p>结合以上两点，可以推断出新方式的用法（尽管这段注释没有直接写出来）</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED COMPONENTS core imgproc highgui) <span class="comment"># 假设需要这三个</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MY_TARGET_NAME PRIVATE OpenCV::core OpenCV::imgproc OpenCV::highgui)</span><br><span class="line"></span><br><span class="line">这里<span class="keyword">find_package</span>可以不指定具体哪个模块而是用</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line">区别不大</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>推荐指定模块，不然就会把所有模块全都链接到项目上</span><br><span class="line"></span><br><span class="line">说是这样说，但是我指定模块运行失败，不知道是因为名字不对还是啥</span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)才成功的</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h3 id="总结：还是用文档里说的吧"><a href="#总结：还是用文档里说的吧" class="headerlink" title="总结：还是用文档里说的吧"></a>总结：还是用文档里说的吧</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  从外部项目使用：</span></span><br><span class="line"><span class="comment">#    在你的 CMakeLists.txt 中，添加这些行：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>) <span class="comment"># 对于 CMake &gt;= 2.8.11 已不再需要</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MY_TARGET_NAME <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line">其中<span class="keyword">include_directories</span>可有可无</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—find原理</title>
      <link href="/2025/04/24/c3/"/>
      <url>/2025/04/24/c3/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在CMake中找到并链接新安装的库"><a href="#如何在CMake中找到并链接新安装的库" class="headerlink" title="如何在CMake中找到并链接新安装的库"></a>如何在CMake中找到并链接新安装的库</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在安装新库后，找出在CMake中<code>find_package</code>所需的<strong>精确包名</strong>（包括大小写），并了解如何正确链接该库（优先使用现代CMake目标）。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1-更新locate数据库（必做！）"><a href="#1-更新locate数据库（必做！）" class="headerlink" title="1. 更新locate数据库（必做！）"></a>1. 更新<code>locate</code>数据库（必做！）</h3><ul><li><strong>操作:</strong> 打开终端，运行<code>sudo updatedb</code></li><li><strong>原因:</strong> 确保<code>locate</code>的数据库包含你刚刚安装的新库的文件信息</li><li><strong>注意:</strong> 如果跳过此步骤，后续步骤可能找不到任何结果</li></ul><h3 id="2-初步定位：查找核心配置文件（Config-cmake）"><a href="#2-初步定位：查找核心配置文件（Config-cmake）" class="headerlink" title="2. 初步定位：查找核心配置文件（Config.cmake）"></a>2. 初步定位：查找核心配置文件（<code>Config.cmake</code>）</h3><ul><li><strong>操作:</strong> 运行以下命令（替换<code>库名关键词</code>）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;库名关键词&#x27;</span></span><br></pre></td></tr></table></figure></li><li><strong>目的:</strong> 查找包含<code>config.cmake</code>（不区分大小写）且路径中包含指定库名关键词的文件</li><li><strong>分析结果:</strong> 注意文件路径，例如：<ul><li><code>/usr/lib/x86_64-linux-gnu/cmake/SomeLib/SomeLibConfig.cmake</code></li><li><code>/opt/my_libs/lib/cmake/somelib/somelib-config.cmake</code></li></ul></li></ul><h3 id="3-确定find-package名称"><a href="#3-确定find-package名称" class="headerlink" title="3. 确定find_package名称"></a>3. 确定<code>find_package</code>名称</h3><ul><li><strong>操作:</strong> 从上一步找到的配置文件路径中提取<strong>保留原始大小写的包名</strong></li><li><strong>提取方法:</strong> 包名通常位于<code>.../cmake/</code>目录之后，是<code>Config.cmake</code>文件或其所在目录的名称<ul><li>例如：<ul><li><code>/usr/lib/x86_64-linux-gnu/cmake/SomeLib/SomeLibConfig.cmake</code> → 包名为<code>SomeLib</code></li><li><code>/opt/my_libs/lib/cmake/somelib/somelib-config.cmake</code> → 包名为<code>somelib</code></li></ul></li></ul></li><li><strong>结果:</strong> 提取出的精确名称将用于<code>CMakeLists.txt</code>中的<code>find_package()</code></li></ul><h3 id="4-全面查找：找到所有相关的-cmake文件（可选但推荐）"><a href="#4-全面查找：找到所有相关的-cmake文件（可选但推荐）" class="headerlink" title="4. 全面查找：找到所有相关的.cmake文件（可选但推荐）"></a>4. 全面查找：找到所有相关的<code>.cmake</code>文件（可选但推荐）</h3><ul><li><strong>操作:</strong> 运行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;库名关键词&#x27;</span> | grep -i <span class="string">&#x27;\.cmake$&#x27;</span></span><br></pre></td></tr></table></figure></li><li><strong>目的:</strong> 找到所有路径包含库名关键词且以<code>.cmake</code>结尾的文件</li><li><strong>用途:</strong> 这有助于了解整个CMake配置的结构</li></ul><h3 id="5-深入检查：查看文件内容，确认链接方式"><a href="#5-深入检查：查看文件内容，确认链接方式" class="headerlink" title="5. 深入检查：查看文件内容，确认链接方式"></a>5. 深入检查：查看文件内容，确认链接方式</h3><ul><li><strong>操作:</strong><ul><li>用文本编辑器打开第2步找到的核心<code>Config.cmake</code>文件</li><li>检查是否通过<code>include()</code>命令包含了其他<code>.cmake</code>文件，如有则一并查看</li></ul></li><li><strong>检查要点:</strong><ul><li><strong>寻找导入目标:</strong> 搜索<code>add_library</code>关键字，寻找形如<code>add_library(Namespace::Target IMPORTED ...)</code>的行<ul><li>如找到，<strong>强烈建议</strong>使用现代CMake的链接方式：<code>target_link_libraries(... Namespace::Target)</code></li></ul></li><li><strong>寻找变量定义:</strong> 搜索<code>set(</code>命令，查找版本变量<code>$&#123;SomeLib_VERSION&#125;</code>或包含目录&#x2F;库变量<code>$&#123;SomeLib_INCLUDE_DIRS&#125;</code>, <code>$&#123;SomeLib_LIBRARIES&#125;</code></li><li><strong>查看依赖:</strong> 注意是否有<code>find_dependency(...)</code>命令，了解库是否自动处理依赖</li><li><strong>阅读注释:</strong> 好的配置文件通常包含使用说明</li></ul></li></ul><h3 id="6-在CMakeLists-txt中实践"><a href="#6-在CMakeLists-txt中实践" class="headerlink" title="6. 在CMakeLists.txt中实践"></a>6. 在<code>CMakeLists.txt</code>中实践</h3><ul><li><strong>操作:</strong><ul><li>使用第3步确定的<strong>精确包名</strong>调用<code>find_package</code>:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(SomeLib REQUIRED) <span class="comment"># 使用大小写正确的名字</span></span><br><span class="line"><span class="comment"># 或者，如果库支持组件：</span></span><br><span class="line"><span class="comment"># find_package(SomeLib REQUIRED COMPONENTS core gui)</span></span><br></pre></td></tr></table></figure></li><li><strong>优先使用导入目标</strong>（如果在第5步找到）:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(your_target PRIVATE SomeLib::core SomeLib::gui)</span><br></pre></td></tr></table></figure></li><li><strong>如果找不到导入目标</strong>（旧式库）:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(your_target PRIVATE <span class="variable">$&#123;SomeLib_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_target PRIVATE <span class="variable">$&#123;SomeLib_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ol><li>先用<code>locate</code>定位关键的<code>*Config.cmake</code>文件，确定<code>find_package</code>的官方名称</li><li>检查配置文件内容，确认链接方式：<ul><li>现代方式：使用导入目标(<code>Namespace::Target</code>)</li><li>传统方式：使用包含目录和库变量</li></ul></li><li>在实际项目中正确使用找到的库</li></ol><blockquote><p><strong>提示：</strong> 虽然<code>locate</code>是方便的本地检查工具，但<strong>库的官方文档</strong>仍然是了解其CMake用法的最权威来源。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—CMake</title>
      <link href="/2025/04/24/c2/"/>
      <url>/2025/04/24/c2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-最小可行的-CMakeLists-txt"><a href="#1-最小可行的-CMakeLists-txt" class="headerlink" title="1. 最小可行的 CMakeLists.txt"></a>1. <strong>最小可行的 CMakeLists.txt</strong></h2><p><strong>思考：</strong></p><p>我需要告诉 CMake 什么？</p><ul><li>它需要知道最低兼容的 CMake 版本是多少？（<code>cmake_minimum_required</code>）</li><li>我的项目叫什么名字？（<code>project</code>）</li><li>我想生成什么？（一个可执行文件？一个库？）（<code>add_executable</code> 或 <code>add_library</code>）</li><li>这个生成目标需要哪些源文件？（<code>add_executable</code> 或 <code>add_library</code> 的参数）</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 指定 CMake 最低版本要求</span></span><br><span class="line"><span class="comment">#    Ubuntu 22.04 自带的 CMake 版本通常较高 (如 3.22+)，但设置一个稍低的版本（如 3.16）可以增加兼容性。</span></span><br><span class="line"><span class="comment">#    这确保了我们使用的 CMake 命令和特性在该版本及以上可用。</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定义项目名称和语言</span></span><br><span class="line"><span class="comment">#    项目名称会用在一些默认变量和 IDE 中。</span></span><br><span class="line"><span class="comment">#    指定 CXX 表示这是一个 C++ 项目，CMake 会自动寻找并配置 C++ 编译器。</span></span><br><span class="line"><span class="keyword">project</span>(MyMinimalProject CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加一个可执行文件目标</span></span><br><span class="line"><span class="comment">#    第一个参数 &quot;my_app&quot; 是你想要生成的可执行文件的名字。</span></span><br><span class="line"><span class="comment">#    后续参数是构成这个可执行文件的源文件列表。这里只有一个 main.cpp。</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>cmake_minimum_required(VERSION 3.16)</code>：告诉 CMake 使用至少 3.16 版本的语法和功能。如果系统上的 CMake 版本低于此，它会报错。</li><li><code>project(MyMinimalProject CXX)</code>：定义项目名为 <code>MyMinimalProject</code>，并声明主要语言是 C++ (<code>CXX</code>)。这会让 CMake 检查 C++ 编译器是否可用。</li><li><code>add_executable(my_app main.cpp)</code>：指示 CMake 创建一个名为 <code>my_app</code> 的可执行文件，该文件由 <code>main.cpp</code> 编译而来。</li></ul><p><strong>构建步骤：</strong></p><ol><li>打开终端，进入 <code>my_minimal_project</code> 目录。</li><li>创建构建目录并进入：<code>mkdir build &amp;&amp; cd build</code> (推荐将构建产物与源码分开)</li><li>运行 CMake 配置：<code>cmake ..</code> ( <code>..</code> 指向包含 <code>CMakeLists.txt</code> 的上级目录)</li><li>编译项目：<code>make</code> (或者 <code>cmake --build .</code>)</li><li>运行可执行文件：<code>./my_app</code></li></ol><h2 id="2-更多源文件的处理"><a href="#2-更多源文件的处理" class="headerlink" title="2. 更多源文件的处理"></a>2. <strong>更多源文件的处理</strong></h2><p><strong>思考：</strong></p><ol><li><strong>如何告诉 <code>add_executable</code> 所有需要的 <code>.cpp</code> 文件？</strong><ul><li>直接在 <code>add_executable</code> 命令中列出所有 <code>.cpp</code> 文件？</li><li>用一个变量来存储源文件列表，然后传递给 <code>add_executable</code>？（更整洁）</li><li>让 CMake 自动查找目录下的 <code>.cpp</code> 文件？（<code>aux_source_directory</code> 或 <code>file(GLOB ...)</code>，<strong>不推荐</strong>用于源文件，因为新增&#x2F;删除文件时 CMake 可能不会自动检测到变化）</li></ul></li><li><strong>如果源文件分散在不同目录（如 <code>src/</code>），CMake 如何找到它们？</strong><ul><li>在文件名中包含相对路径（例如 <code>src/main.cpp</code>）。</li></ul></li><li><strong>如果头文件放在单独的目录（如 <code>include/</code>），编译器如何找到它们？</strong><ul><li>需要告诉 CMake 头文件的搜索路径。（<code>target_include_directories</code>）</li></ul></li></ol><p><strong>代码示例：</strong></p><p>假设项目结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_multi_file_project/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include/</span><br><span class="line">│   └── helper.h</span><br><span class="line">└── src/</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    └── helper.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>include/helper.h</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELPER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELPER_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELPER_H</span></span></span><br></pre></td></tr></table></figure><p><code>src/helper.cpp</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span> <span class="comment">// 注意这里可以直接 include，因为我们会告诉 CMake 头文件路径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Message from helper!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/main.cpp</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span> <span class="comment">// 包含我们自己的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_message</span>(); <span class="comment">// 调用来自 helper 的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(MyMultiFileProject CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 使用变量存储源文件列表 (推荐方式)</span></span><br><span class="line"><span class="comment">#    将所有需要编译的 .cpp 文件列在这里。使用相对路径。</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/helper.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加可执行文件目标，使用变量</span></span><br><span class="line"><span class="comment">#    将 $&#123;SOURCES&#125; 变量的内容展开作为源文件列表。</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_app <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 指定头文件搜索路径</span></span><br><span class="line"><span class="comment">#    告诉 CMake，当编译 my_app 这个目标时，</span></span><br><span class="line"><span class="comment">#    应该到 &quot;include&quot; 目录下查找头文件 (#include &quot;...&quot;).</span></span><br><span class="line"><span class="comment">#    PUBLIC 意味着如果其他目标链接到 my_app，它们也会自动获得这个 include 目录。</span></span><br><span class="line"><span class="comment">#    对于可执行文件，PRIVATE 通常也足够。</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>set(SOURCES ...)</code>：创建了一个名为 <code>SOURCES</code> 的 CMake 变量，存储了所有 <code>.cpp</code> 文件的列表。这比在 <code>add_executable</code> 中写一长串文件名更清晰，易于维护。</li><li><code>add_executable(my_app $&#123;SOURCES&#125;)</code>：使用 <code>$&#123;VAR_NAME&#125;</code> 语法来引用变量 <code>SOURCES</code>。</li><li><code>target_include_directories(my_app PUBLIC include)</code>：这是关键一步。它告诉编译器在编译 <code>my_app</code> 的源文件时，去 <code>include</code> 目录下查找 <code>#include</code> 的头文件。没有这一行，<code>#include &quot;helper.h&quot;</code> 会失败。<code>PUBLIC</code> 关键字表示这个包含目录不仅 <code>my_app</code> 自己用，如果将来有其他 CMake 目标链接到 <code>my_app</code>，它们也会继承这个包含目录（对于可执行文件，通常用 <code>PRIVATE</code> 即可，表示仅 <code>my_app</code> 内部使用）。</li></ul><h2 id="3-第三方库如何使用（以OpenCV为例）"><a href="#3-第三方库如何使用（以OpenCV为例）" class="headerlink" title="3.  第三方库如何使用（以OpenCV为例）"></a>3.  第三方库如何使用（以OpenCV为例）</h2><p><strong>思考：</strong></p><ol><li><strong>如何让 CMake 找到已安装的 OpenCV 库？</strong><ul><li>使用 <code>find_package</code> 命令。这是 CMake 查找外部库的标准方式。</li></ul></li><li><strong>我需要 OpenCV 的哪些部分（模块）？</strong><ul><li>OpenCV 是模块化的（如 <code>core</code>, <code>imgproc</code>, <code>highgui</code> 等）。明确指定需要的模块可以减少不必要的依赖和链接。</li><li><code>find_package</code> 允许通过 <code>COMPONENTS</code> 参数指定所需模块。</li></ul></li><li><strong><code>find_package</code> 找到库后，如何将它链接到我的目标（<code>my_app</code>）？</strong><ul><li>需要告诉 CMake 两件事：<ul><li>编译器在哪里找到 OpenCV 的头文件</li><li>链接器在哪里找到 OpenCV 的库文件并将它们链接到我的可执行文件</li></ul></li><li><strong>现代 CMake 方式（推荐）：</strong> 使用 <code>target_link_libraries</code> 配合 <code>find_package</code> 提供的 “Imported Target” (例如 <code>OpenCV::opencv_core</code>)。这种方式会自动处理头文件路径和库链接。</li><li><strong>旧式 CMake 方式（了解即可）：</strong> <code>find_package</code> 会设置一些变量（如 <code>OpenCV_INCLUDE_DIRS</code> 和 <code>OpenCV_LIBS</code>），然后手动使用 <code>target_include_directories</code> 和 <code>target_link_libraries</code>。</li></ul></li></ol><p><strong>代码示例：</strong></p><p>假设项目结构不变，我们修改 <code>main.cpp</code> 来使用 OpenCV。</p><p><code>src/main.cpp</code> (示例：读取并显示一张图片):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含 OpenCV 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;Image_Path&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_message</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图片</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(argv[<span class="number">1</span>], cv::IMREAD_COLOR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Could not read the image: &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图片</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Display window&quot;</span>, image);</span><br><span class="line">    <span class="type">int</span> k = cv::<span class="built_in">waitKey</span>(<span class="number">0</span>); <span class="comment">// 等待按键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(MyOpenCVProject CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/helper.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- OpenCV Integration ---</span></span><br><span class="line"><span class="comment"># 1. 查找 OpenCV 包</span></span><br><span class="line"><span class="comment">#    REQUIRED: 如果找不到 OpenCV，CMake 会报错停止。</span></span><br><span class="line"><span class="comment">#    COMPONENTS: 指定我们需要的模块。</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED COMPONENTS core imgcodecs highgui)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否成功找到 (可选，但推荐)</span></span><br><span class="line"><span class="keyword">if</span>(OpenCV_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Found OpenCV version: $&#123;OpenCV_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;OpenCV not found!&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># --- End OpenCV Integration ---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my_app <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Link OpenCV to the target ---</span></span><br><span class="line"><span class="comment"># 2. 将 OpenCV 链接到我们的可执行文件 (现代方式)</span></span><br><span class="line"><span class="comment">#    OpenCV 的 find_package 脚本会创建所谓的 &quot;Imported Targets&quot;。</span></span><br><span class="line"><span class="comment">#    通常格式是 `OpenCV::module_name` (例如 OpenCV::core, OpenCV::imgcodecs)。</span></span><br><span class="line"><span class="comment">#    链接这些 Imported Targets 会自动处理包含目录和库文件。</span></span><br><span class="line"><span class="comment">#    PRIVATE 表示链接的库仅 my_app 内部使用，不会传递给链接到 my_app 的其他目标。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐这样做，但我实际操作找不到</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE</span><br><span class="line">    OpenCV::core</span><br><span class="line">    OpenCV::imgcodecs</span><br><span class="line">    OpenCV::highgui</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 最后是通过这个成功运行的</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- End Link OpenCV ---</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>find_package(OpenCV REQUIRED COMPONENTS ...)</code>：指示 CMake 查找 OpenCV。<code>REQUIRED</code> 确保找不到时构建失败。<code>COMPONENTS</code> 列出了我们代码中实际用到的 OpenCV 模块 (<code>core</code> 对应 <code>cv::Mat</code>, <code>imgcodecs</code> 对应 <code>cv::imread</code>, <code>highgui</code> 对应 <code>cv::imshow</code>, <code>cv::waitKey</code>)。</li><li><code>message(STATUS ...)</code>：在 CMake 配置阶段打印信息，方便调试。</li><li><code>target_link_libraries(my_app PRIVATE OpenCV::core ...)</code>：这是最关键的一步。它将 <code>my_app</code> 链接到 <code>find_package</code> 找到的 OpenCV 模块。使用 <code>OpenCV::module_name</code> 这种 Imported Target 是现代 CMake 的推荐做法，它比旧方法更简洁、更健壮，CMake 会自动管理头文件路径 (<code>target_include_directories</code> 不需要再为 OpenCV 手动添加) 和库文件链接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—基础篇</title>
      <link href="/2025/04/24/c1/"/>
      <url>/2025/04/24/c1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-学习笔记—基础篇"><a href="#C-学习笔记—基础篇" class="headerlink" title="C++学习笔记—基础篇"></a>C++学习笔记—基础篇</h1><h2 id="1-安装最基础的编译环境"><a href="#1-安装最基础的编译环境" class="headerlink" title="1. 安装最基础的编译环境"></a>1. 安装最基础的编译环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install build-essential</span><br></pre></td></tr></table></figure><p>验证有没有装好，输出版本信息即装好了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ --version</span><br><span class="line">make --version</span><br></pre></td></tr></table></figure><h2 id="2-第一个程序"><a href="#2-第一个程序" class="headerlink" title="2. 第一个程序"></a>2. 第一个程序</h2><p>使用任意的编辑器编写一个hello.cpp然后编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure><ul><li><code>g++</code>: 调用 GNU C++ 编译器。</li><li><code>hello.cpp</code>: 你要编译的源文件。</li><li><code>o hello</code>: 这个选项告诉编译器，将生成的可执行文件命名为 <code>hello</code>。如果没有 <code>o</code> 选项，默认会生成一个名为 <code>a.out</code> 的文件。</li></ul><h2 id="3-使用-make-简化编译"><a href="#3-使用-make-简化编译" class="headerlink" title="3. 使用 make 简化编译"></a>3. <strong>使用 <code>make</code> 简化编译</strong></h2><p>如果项目比较复杂的话，只通过命令编译就会很长</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp math_utils.cpp -o my_calc -Wall -Wextra -std=c++11</span><br></pre></td></tr></table></figure><p><code>make</code> 通过 <code>Makefile</code> 文件来解决手动编译的许多问题</p><p>创建一个 <code>Makefile</code> 文件然后通过 <code>make</code> 命令就可以自动的编译（过程省略）但是 <code>Makefile</code> 文件不是很好写</p><h2 id="4-使用-CMake"><a href="#4-使用-CMake" class="headerlink" title="4. 使用 CMake"></a>4. <strong>使用 <code>CMake</code></strong></h2><p><code>CMake</code> 作为构建系统生成器，解决了 <code>make</code> 的许多局限性，尤其是在跨平台和管理复杂性方面。</p><ol><li><p><strong>创建 <code>CMakeLists.txt</code>:</strong> 在 <code>calculator</code> 目录下创建 <code>CMakeLists.txt</code> 文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称和语言</span></span><br><span class="line"><span class="keyword">project</span>(Calculator LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 C++ 标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (可选) 添加编译选项，会传递给编译器</span></span><br><span class="line"><span class="comment"># add_compile_options(-Wall -Wextra) # 或者更现代的方式如下：</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(my_calc INTERFACE -Wall -Wextra) <span class="comment"># 应用于 my_calc 及其使用者</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件目标</span></span><br><span class="line"><span class="comment"># CMake 会自动分析 main.cpp 和 math_utils.cpp 之间的依赖</span></span><br><span class="line"><span class="comment"># 以及它们对 math_utils.h 的依赖</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_calc main.cpp math_utils.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果头文件在 include 目录:</span></span><br><span class="line"><span class="comment"># target_include_directories(my_calc PRIVATE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>操作 (Out-of-Source Build):</strong></p><ul><li><p><strong>创建构建目录并进入:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure></li><li><p>**运行 CMake (配置阶段):**CMake 会读取 <code>../CMakeLists.txt</code>，检测你的编译器，并生成一个 <code>Makefile</code> (或其他本地构建系统文件) 在 <code>build</code> 目录中。它会自动处理 <code>main.cpp</code> 对 <code>math_utils.h</code> 的依赖。</p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure></li><li><p><strong>运行构建工具 (构建阶段):</strong><code>make</code> 会使用 CMake 生成的 <code>Makefile</code> 来编译项目。可执行文件 <code>my_calc</code> 会出现在 <code>build</code> 目录。</p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p><strong>运行:</strong></p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_calc</span><br></pre></td></tr></table></figure></li><li><p><strong>清理:</strong></p><ul><li>可以使用 <code>make clean</code> (由 CMake 生成的 <code>Makefile</code> 提供)。</li><li>或者更彻底地，删除整个 <code>build</code> 目录：<code>cd .. &amp;&amp; rm -rf build</code>。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git学习记录</title>
      <link href="/2025/04/22/git/"/>
      <url>/2025/04/22/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><hr><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>在官方网站安装: <a href="https://git-scm.com/">https://git-scm.com/</a></p><hr><h2 id="2-初始化配置"><a href="#2-初始化配置" class="headerlink" title="2. 初始化配置"></a>2. 初始化配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置全局用户名和邮箱</span></span><br><span class="line">git config --global user.name <span class="string">&quot;name&quot;</span></span><br><span class="line">git config --global user.email xxxx@gmail.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 凭证存储</span></span><br><span class="line"><span class="comment"># 第一次通过 HTTPS 方式 push 或 pull 时，Git 会要求输入用户名和密码</span></span><br><span class="line"><span class="comment"># （或 Personal Access Token）。操作成功后，&quot;store&quot; 会把凭证以明文格式写入文件</span></span><br><span class="line"><span class="comment"># 以后再访问同一个远程仓库时，Git 会自动读取凭证，不再重复询问</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置默认分支，现在推荐使用main</span></span><br><span class="line">git config --global init.defaultBranch main</span><br></pre></td></tr></table></figure><hr><h2 id="3-创建一个新仓库"><a href="#3-创建一个新仓库" class="headerlink" title="3. 创建一个新仓库"></a>3. 创建一个新仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 初始化本地仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 克隆远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;仓库URL&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="4-工作区域和文件状态"><a href="#4-工作区域和文件状态" class="headerlink" title="4. 工作区域和文件状态"></a>4. 工作区域和文件状态</h2><h3 id="Git中的三种工作区域"><a href="#Git中的三种工作区域" class="headerlink" title="Git中的三种工作区域"></a>Git中的三种工作区域</h3><ol><li><p><strong>工作区</strong>(.git所在目录)</p><ul><li>在资源管理器中看到的目录</li></ul></li><li><p><strong>暂存区</strong>(.git&#x2F;index)</p><ul><li>用于保存即将提交到Git仓库的修改内容</li></ul></li><li><p><strong>本地仓库</strong>(.git&#x2F;objects)</p><ul><li>Git存储代码和版本信息的主要位置</li></ul></li></ol><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423151837456.png" alt="工作区域"></p><h3 id="Git中的四种文件状态"><a href="#Git中的四种文件状态" class="headerlink" title="Git中的四种文件状态"></a>Git中的四种文件状态</h3><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423153227238.png" alt="文件状态"></p><hr><h2 id="5-添加和提交文件"><a href="#5-添加和提交文件" class="headerlink" title="5. 添加和提交文件"></a>5. 添加和提交文件</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h3><p>查看仓库的状态</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><code>git add</code></h3><p>将文件添加到暂存区</p><ul><li>可以使用通配符：<code>git add *.txt</code></li><li>也可以使用目录：<code>git add .</code></li></ul><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h3><p>提交到本地仓库</p><ul><li>只提交<strong>暂存区</strong>中的内容，不会提交<strong>工作区</strong>中的内容</li></ul><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h3><p>查看仓库提交历史记录</p><ul><li>使用 <code>--oneline</code> 参数查看简洁的提交记录</li></ul><h3 id="git-ls-files"><a href="#git-ls-files" class="headerlink" title="git ls-files"></a><code>git ls-files</code></h3><p>查看暂存区的内容</p><hr><h2 id="6-git-reset回退版本"><a href="#6-git-reset回退版本" class="headerlink" title="6. git reset回退版本"></a>6. git reset回退版本</h2><h3 id="Git-reset的三种模式"><a href="#Git-reset的三种模式" class="headerlink" title="Git reset的三种模式"></a>Git reset的三种模式</h3><ul><li><p><code>git reset --soft</code> </p><ul><li>回退到某个版本，保留工作区和暂存区的所有内容</li></ul></li><li><p><code>git reset --hard</code> </p><ul><li>回退到某个版本，丢弃工作区和暂存区的所有内容</li></ul></li><li><p><code>git reset --mixed</code> (默认参数)</p><ul><li>回退到某个版本，保留工作区的内容，丢弃暂存区的内容</li></ul></li></ul><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423155650856.png" alt="Git reset模式"></p><hr><h2 id="7-使用git-diff查看差异"><a href="#7-使用git-diff查看差异" class="headerlink" title="7. 使用git diff查看差异"></a>7. 使用git diff查看差异</h2><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a><code>git diff</code></h3><p>比较：<strong>工作区</strong> 🆚 <strong>暂存区</strong></p><h3 id="git-diff-HEAD"><a href="#git-diff-HEAD" class="headerlink" title="git diff HEAD"></a><code>git diff HEAD</code></h3><p>比较：<strong>工作区 + 暂存区</strong> 🆚 <strong>本地仓库</strong></p><h3 id="git-diff-cached-git-diff-staged"><a href="#git-diff-cached-git-diff-staged" class="headerlink" title="git diff --cached &#x2F; git diff --staged"></a><code>git diff --cached</code> &#x2F; <code>git diff --staged</code></h3><p>比较：<strong>暂存区</strong> 🆚 <strong>本地仓库</strong></p><h3 id="git-diff-1"><a href="#git-diff-1" class="headerlink" title="git diff &lt;commit_hash&gt; &lt;commit_hash&gt;"></a><code>git diff &lt;commit_hash&gt; &lt;commit_hash&gt;</code></h3><h3 id="git-diff-HEAD-HEAD"><a href="#git-diff-HEAD-HEAD" class="headerlink" title="git diff HEAD~ HEAD"></a><code>git diff HEAD~ HEAD</code></h3><p>比较两个**提交（commit）**之间的差异</p><h3 id="git-diff-2"><a href="#git-diff-2" class="headerlink" title="git diff &lt;branch_name&gt; &lt;branch_name&gt;"></a><code>git diff &lt;branch_name&gt; &lt;branch_name&gt;</code></h3><p>比较两个<strong>分支</strong>之间的差异</p><hr><h2 id="8-Git-删除文件命令"><a href="#8-Git-删除文件命令" class="headerlink" title="8. Git 删除文件命令"></a>8. Git 删除文件命令</h2><h3 id="rm-file-git-add-file"><a href="#rm-file-git-add-file" class="headerlink" title="rm file; git add file"></a><code>rm file; git add file</code></h3><ul><li>先从<strong>工作区</strong>删除文件</li><li>然后使用 <code>git add</code> 让 Git 追踪这次删除（即加入暂存区）</li></ul><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm &lt;file&gt;"></a><code>git rm &lt;file&gt;</code></h3><ul><li>同时从<strong>工作区</strong>和<strong>暂存区</strong>删除文件</li></ul><h3 id="git-rm-cached"><a href="#git-rm-cached" class="headerlink" title="git rm --cached &lt;file&gt;"></a><code>git rm --cached &lt;file&gt;</code></h3><ul><li><strong>只从暂存区删除</strong>文件，但保留工作区中的文件（文件依然存在本地）</li></ul><h3 id="git-rm-r"><a href="#git-rm-r" class="headerlink" title="git rm -r *"></a><code>git rm -r *</code></h3><ul><li><strong>递归删除</strong>当前目录及子目录下的所有文件和文件夹</li></ul><blockquote><p><strong>提示</strong>：删除文件后记得使用 <code>git commit</code> 提交更改！</p></blockquote><hr><h2 id="9-gitignore忽略文件"><a href="#9-gitignore忽略文件" class="headerlink" title="9. gitignore忽略文件"></a>9. gitignore忽略文件</h2><h3 id="常见忽略文件列表"><a href="#常见忽略文件列表" class="headerlink" title="常见忽略文件列表"></a>常见忽略文件列表</h3><ul><li>忽略日志文件和日志目录</li><li>忽略所有 <code>.class</code> 文件</li><li>忽略所有 <code>.o</code> 文件（编译生成的中间文件）</li><li>忽略所有 <code>.env</code> 文件（包含环境变量配置）</li><li>忽略所有 <code>.zip</code> 和 <code>.tar</code> 压缩包</li><li>忽略所有 <code>.pem</code> 文件（安全凭证）</li></ul><h3 id="一般应该忽略的文件类型"><a href="#一般应该忽略的文件类型" class="headerlink" title="一般应该忽略的文件类型"></a>一般应该忽略的文件类型</h3><ul><li><strong>系统或软件自动生成的文件</strong></li><li><strong>编译产生的中间文件和结果文件</strong></li><li><strong>运行时生成的日志、缓存、临时文件</strong></li><li><strong>涉及身份、密码、口令、秘钥等敏感信息的文件</strong></li></ul><h3 id="示例-gitignore-文件内容"><a href="#示例-gitignore-文件内容" class="headerlink" title="示例 .gitignore 文件内容"></a>示例 <code>.gitignore</code> 文件内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 日志文件</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># 编译输出</span><br><span class="line">*.class</span><br><span class="line">*.o</span><br><span class="line"></span><br><span class="line"># 环境变量</span><br><span class="line">.env</span><br><span class="line"></span><br><span class="line"># 压缩包</span><br><span class="line">*.zip</span><br><span class="line">*.tar</span><br><span class="line"></span><br><span class="line"># 安全证书等敏感信息</span><br><span class="line">*.pem</span><br></pre></td></tr></table></figure><hr><h2 id="10-SSH配置"><a href="#10-SSH配置" class="headerlink" title="10. SSH配置"></a>10. SSH配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 回到根目录</span></span><br><span class="line"><span class="built_in">cd</span> ~ 或者 <span class="built_in">cd</span> 直接回车</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入ssh文件夹</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 生成ssh密钥</span></span><br><span class="line">ssh-keygen -t rsa -b 4096</span><br><span class="line"><span class="comment"># -t代表协议为rsa</span></span><br><span class="line"><span class="comment"># -b代表生成大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 回车后提醒输入密钥名称</span></span><br><span class="line"><span class="comment"># 如果是第一次使用这个命令，直接回车就行了，使用默认的名称id_rsa</span></span><br><span class="line"><span class="comment"># 如果之前用过最好不要直接回车，会覆盖掉之前的密钥，且操作不可逆</span></span><br><span class="line"><span class="comment"># 输入一个新的名字例如test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 再回车后提醒输入密码，可以为空直接回车</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 可以看到本地生成了两个文件，一个密钥，一个密钥.pub</span></span><br><span class="line"><span class="comment"># 私钥文件谁都不要给，公钥打开复制到github</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 点开头像-设置-ssh和gpg密钥配置--new ssh key --然后起个名字将公钥粘贴进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 如果是第一次配置默认的名称，到此就结束了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 如果是自己命名的密钥</span></span><br><span class="line"><span class="comment"># 打开 ~/.ssh/config 文件，如果没有就创建，如果有就附加在后面</span></span><br><span class="line"><span class="comment"># 填入</span></span><br><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/test</span><br><span class="line"><span class="comment"># 意思是访问github时指定访问test密钥</span></span><br></pre></td></tr></table></figure><h3 id="SSH通过HTTPS端口连接GitHub-解决网络问题"><a href="#SSH通过HTTPS端口连接GitHub-解决网络问题" class="headerlink" title="SSH通过HTTPS端口连接GitHub (解决网络问题)"></a>SSH通过HTTPS端口连接GitHub (解决网络问题)</h3><p>当无法通过SSH默认端口访问GitHub时，可以通过HTTPS端口(443)绕过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑SSH配置文件</span></span><br><span class="line">nano ~/.ssh/config</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">vim ~/.ssh/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下配置</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName ssh.github.com</span><br><span class="line">    Port 443</span><br><span class="line">    User git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试连接</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># 成功会显示：Hi username! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在可以正常克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:Git-xfy/remote-repo.git</span><br></pre></td></tr></table></figure><p><strong>这种方法有效的原因</strong>:</p><ol><li>许多公司和网络环境会阻止SSH的标准端口(22)，但允许HTTPS端口(443)</li><li>这种方法仍使用SSH协议及其安全特性和密钥认证</li><li>通信通过通常允许的HTTPS端口传输，从而绕过防火墙限制</li></ol><hr><h2 id="11-关联本地仓库和远程仓库"><a href="#11-关联本地仓库和远程仓库" class="headerlink" title="11. 关联本地仓库和远程仓库"></a>11. 关联本地仓库和远程仓库</h2><h3 id="git-remote-add"><a href="#git-remote-add" class="headerlink" title="git remote add &lt;shortname&gt; &lt;url&gt;"></a><code>git remote add &lt;shortname&gt; &lt;url&gt;</code></h3><ul><li>shortname - 起一个短名字，一般都是origin</li><li>url - 要关联的远程仓库地址</li></ul><h3 id="git-remote-v"><a href="#git-remote-v" class="headerlink" title="git remote -v"></a><code>git remote -v</code></h3><p>查看当前仓库所对应的远程仓库的别名和地址</p><h3 id="git-branch-M-main"><a href="#git-branch-M-main" class="headerlink" title="git branch -M main"></a><code>git branch -M main</code></h3><p>将本地仓库当前分支命名为main</p><ul><li>GitHub默认的主分支名称是main，而本地分支有时候默认是master</li><li>如果已经设置过默认分支为main，则不需要此操作</li></ul><h3 id="git-push-u-origin-main"><a href="#git-push-u-origin-main" class="headerlink" title="git push -u origin main"></a><code>git push -u origin main</code></h3><p>把本地分支和远程分支的main关联起来</p><ul><li>全称是<code>git push -u origin main:main</code></li><li>将本地的main分支（冒号前）与远程main分支（冒号后）关联起来</li><li>名称一样可以省略一个</li></ul><h3 id="简化命令"><a href="#简化命令" class="headerlink" title="简化命令"></a>简化命令</h3><ul><li>关联后可以直接使用 <code>git push</code></li><li>未关联则需使用 <code>git push &lt;remote_name&gt; &lt;local_branch_name&gt;:&lt;remote_branch_name&gt;</code></li></ul><h3 id="拉取命令"><a href="#拉取命令" class="headerlink" title="拉取命令"></a>拉取命令</h3><ul><li>关联后：<code>git pull</code></li><li>未关联：<code>git pull &lt;remote_name&gt; &lt;local_branch_name&gt;:&lt;remote_branch_name&gt;</code></li><li>省略时默认拉取origin的main分支</li><li><code>git pull</code> 会自动合并，如有冲突需解决</li><li><code>git fetch</code> 是获取后不自动合并</li></ul><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423170207574.png" alt="拉取示意图"></p><hr><h2 id="12-分支的基本操作"><a href="#12-分支的基本操作" class="headerlink" title="12. 分支的基本操作"></a>12. 分支的基本操作</h2><h3 id="查看分支列表"><a href="#查看分支列表" class="headerlink" title="查看分支列表"></a>查看分支列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统方式</span></span><br><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐方式（Git 2.23+）</span></span><br><span class="line">git switch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><ul><li><strong>已合并的分支</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>未合并的分支</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：分支操作前，建议先查看当前分支状态：<code>git status</code>。合并前确保工作区干净，删除前确认无误。</p></blockquote><hr><h2 id="13-解决合并冲突"><a href="#13-解决合并冲突" class="headerlink" title="13. 解决合并冲突"></a>13. 解决合并冲突</h2><h3 id="冲突说明"><a href="#冲突说明" class="headerlink" title="冲突说明"></a>冲突说明</h3><ul><li><strong>若两个分支修改了同一个文件的不同位置</strong> → Git会自动合并 ✓</li><li><strong>若两个分支修改了同一个文件的相同位置</strong> → 发生冲突 ✗</li></ul><h3 id="解决冲突步骤"><a href="#解决冲突步骤" class="headerlink" title="解决冲突步骤"></a>解决冲突步骤</h3><ol><li><strong>手动修改冲突文件</strong>，处理冲突内容</li><li><strong>添加到暂存区</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><strong>提交更改</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;解决合并冲突&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="中止合并操作"><a href="#中止合并操作" class="headerlink" title="中止合并操作"></a>中止合并操作</h3><p>如果不想继续合并，可使用以下命令中止合并过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：合并冲突发生时，Git会标记冲突区域（如 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>），你需要手动选择保留哪一部分内容。</p></blockquote><hr><h2 id="14-回退和Rebase"><a href="#14-回退和Rebase" class="headerlink" title="14. 回退和Rebase"></a>14. 回退和Rebase</h2><h3 id="Git-Rebase（变基）"><a href="#Git-Rebase（变基）" class="headerlink" title="Git Rebase（变基）"></a>Git Rebase（变基）</h3><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>将当前分支的提交”转移”到目标分支的最新提交之后，<strong>重写提交历史</strong>。</p><h3 id="Rebase-vs-Merge-区别"><a href="#Rebase-vs-Merge-区别" class="headerlink" title="Rebase vs Merge 区别"></a>Rebase vs Merge 区别</h3><table><thead><tr><th>比较项</th><th><code>git merge</code></th><th><code>git rebase</code></th></tr></thead><tbody><tr><td>历史记录</td><td>保留分支历史，产生合并提交</td><td>重写提交历史，线性、干净</td></tr><tr><td>可读性</td><td>可能出现分叉，历史分支交错</td><td>历史更线性，便于回顾</td></tr><tr><td>是否生成新提交</td><td>会生成一个合并提交</td><td>不会生成合并提交，重用原提交</td></tr><tr><td>冲突处理</td><td>只处理一次冲突</td><td>每次变基提交可能都需手动解决冲突</td></tr></tbody></table><h3 id="什么时候用什么？"><a href="#什么时候用什么？" class="headerlink" title="什么时候用什么？"></a>什么时候用什么？</h3><ul><li><p><strong>使用 <code>merge</code></strong>：</p><ul><li>团队协作中保留分支历史</li><li>避免修改提交历史</li><li>合并已推送的公共分支</li></ul></li><li><p><strong>使用 <code>rebase</code></strong>：</p><ul><li>自己在本地整理提交历史</li><li>保持提交历史简洁、线性</li><li>合并前清理开发分支历史，提升可读性</li></ul></li></ul><blockquote><p><strong>小提示</strong>：</p><ul><li><code>rebase</code> 更适合<strong>个人分支开发阶段</strong></li><li><code>merge</code> 更适合<strong>团队协作与主分支合并</strong></li><li>注意：不要对已经推送到远程的公共分支使用 <code>rebase</code>，可能导致历史冲突！</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
