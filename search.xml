<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++学习笔记—cmake的新旧方法</title>
      <link href="/2025/04/24/c5/"/>
      <url>/2025/04/24/c5/</url>
      
        <content type="html"><![CDATA[<h1 id="CMake新旧方法对比详解"><a href="#CMake新旧方法对比详解" class="headerlink" title="CMake新旧方法对比详解"></a>CMake新旧方法对比详解</h1><h2 id="一、include-directories-vs-target-include-directories"><a href="#一、include-directories-vs-target-include-directories" class="headerlink" title="一、include_directories() vs target_include_directories()"></a>一、include_directories() vs target_include_directories()</h2><p>这两者的核心区别在于<strong>作用域(Scope)</strong>：</p><h3 id="1-include-directories-AFTER-BEFORE-SYSTEM-dir1-dir2-…"><a href="#1-include-directories-AFTER-BEFORE-SYSTEM-dir1-dir2-…" class="headerlink" title="1. include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])"></a>1. include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])</h3><p><strong>作用域：目录级别</strong></p><ul><li><strong>作用:</strong> 将指定的目录添加到<strong>当前<code>CMakeLists.txt</code>文件以及所有在它之后处理的子目录</strong>的头文件搜索路径中</li><li><strong>影响:</strong> 在调用后定义的<strong>所有目标</strong>都会将这些目录添加到它们的include路径中</li><li><strong>特点:</strong> 类似于”全局”设置（在当前目录及子目录范围内）</li><li><strong>问题:</strong> 不够精确，可能导致目标获得不必要的包含路径</li></ul><h3 id="2-target-include-directories-SYSTEM-AFTER-BEFORE-items1…-items2…-…"><a href="#2-target-include-directories-SYSTEM-AFTER-BEFORE-items1…-items2…-…" class="headerlink" title="2. target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1…] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2…] …])"></a>2. target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1…] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2…] …])</h3><p><strong>作用域：目标级别</strong></p><ul><li><strong>作用:</strong> 将指定的目录添加到**特定目标<code>&lt;target&gt;</code>**的头文件搜索路径中</li><li><strong>影响:</strong> 只有指定的<code>&lt;target&gt;</code>会使用这些include路径</li><li><strong>关键修饰符:</strong><ul><li><code>PRIVATE</code>: 目录只用于编译<code>&lt;target&gt;</code>自身，不会传递给依赖者</li><li><code>PUBLIC</code>: 目录既用于编译<code>&lt;target&gt;</code>自身，也会传递给依赖<code>&lt;target&gt;</code>的其他目标</li><li><code>INTERFACE</code>: 目录不用于编译<code>&lt;target&gt;</code>自身，但会传递给依赖<code>&lt;target&gt;</code>的其他目标</li></ul></li><li><strong>优点:</strong> 非常精确和清晰，为每个目标精确指定所需的头文件路径</li></ul><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table><thead><tr><th>特性</th><th><code>include_directories()</code></th><th><code>target_include_directories()</code></th></tr></thead><tbody><tr><td><strong>作用域</strong></td><td>目录级别 (影响当前及子目录所有后续目标)</td><td>目标级别 (只影响指定目标)</td></tr><tr><td><strong>精确性</strong></td><td>低</td><td>高</td></tr><tr><td><strong>封装性</strong></td><td>差 (设置是”全局”的)</td><td>好 (设置附加到具体目标)</td></tr><tr><td><strong>现代推荐</strong></td><td><strong>否</strong> (除非有特定全局需求)</td><td><strong>是</strong> (现代CMake的核心用法)</td></tr><tr><td><strong>依赖传递</strong></td><td>不直接处理</td><td>通过<code>PUBLIC</code>&#x2F;<code>INTERFACE</code>关键字明确控制</td></tr></tbody></table><h2 id="二、CMake旧方式-vs-新方式-现代CMake"><a href="#二、CMake旧方式-vs-新方式-现代CMake" class="headerlink" title="二、CMake旧方式 vs 新方式(现代CMake)"></a>二、CMake旧方式 vs 新方式(现代CMake)</h2><p>核心区别在于从<strong>基于变量和全局&#x2F;目录设置</strong>转向<strong>基于目标及其属性</strong>。</p><h3 id="1-旧方式-Variable-Centric-Directory-Scoped-CMake-2-x时代"><a href="#1-旧方式-Variable-Centric-Directory-Scoped-CMake-2-x时代" class="headerlink" title="1. 旧方式 (Variable-Centric, Directory-Scoped - CMake 2.x时代)"></a>1. 旧方式 (Variable-Centric, Directory-Scoped - CMake 2.x时代)</h3><p><strong>核心思想:</strong> <code>find_package</code>等命令设置全局变量，手动使用这些变量配置目标</p><h4 id="典型流程"><a href="#典型流程" class="headerlink" title="典型流程:"></a>典型流程:</h4><ol><li><p><strong>查找和配置库</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(SomeLib REQUIRED)</span><br><span class="line"><span class="comment"># 执行FindSomeLib.cmake或旧式SomeLibConfig.cmake</span></span><br><span class="line"><span class="comment"># 设置变量：SomeLib_FOUND, SomeLib_INCLUDE_DIRS, SomeLib_LIBRARIES等</span></span><br></pre></td></tr></table></figure></li><li><p><strong>手动应用这些变量</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局设置，影响后续所有目标</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;SomeLib_INCLUDE_DIRS&#125;</span>) </span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;SomeLib_DEFINITIONS&#125;</span>)     </span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"><span class="comment"># 手动链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app <span class="variable">$&#123;SomeLib_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="特点与问题"><a href="#特点与问题" class="headerlink" title="特点与问题:"></a>特点与问题:</h4><ul><li><strong>全局状态:</strong> 变量和设置通常影响整个目录或项目，容易冲突</li><li><strong>手动管理:</strong> 需了解每个库设置的变量，手动应用到目标的各属性</li><li><strong>传递依赖困难:</strong> 如<code>my_app</code>依赖<code>my_lib</code>，而<code>my_lib</code>依赖<code>SomeLib</code>，则<code>my_app</code>的配置文件可能也需了解<code>SomeLib</code>，破坏封装性</li><li><strong>不够清晰:</strong> 链接指令通常只是变量引用，不明确表达依赖关系</li></ul><h3 id="2-新方式-Modern-CMake-Target-Centric-CMake-3-0-时代"><a href="#2-新方式-Modern-CMake-Target-Centric-CMake-3-0-时代" class="headerlink" title="2. 新方式 (Modern CMake &#x2F; Target-Centric - CMake 3.0+时代)"></a>2. 新方式 (Modern CMake &#x2F; Target-Centric - CMake 3.0+时代)</h3><p><strong>核心思想:</strong> 将构建所需的所有信息附加到目标上，使用导入目标(Imported Targets)</p><h4 id="典型流程-1"><a href="#典型流程-1" class="headerlink" title="典型流程:"></a>典型流程:</h4><ol><li><p><strong>查找和配置库</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(SomeLib REQUIRED)</span><br><span class="line"><span class="comment"># 执行现代SomeLibConfig.cmake</span></span><br><span class="line"><span class="comment"># 定义导入目标，如SomeLib::Core</span></span><br></pre></td></tr></table></figure></li><li><p><strong>直接链接导入目标</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只需链接目标，CMake自动处理其他所有事情</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE SomeLib::Core)</span><br></pre></td></tr></table></figure></li></ol><h4 id="特点与优势"><a href="#特点与优势" class="headerlink" title="特点与优势:"></a>特点与优势:</h4><ul><li><strong>目标即一切:</strong> 所有配置围绕目标进行，使用<code>target_*</code>系列命令</li><li><strong>封装性:</strong> 库的使用细节被封装在导入目标中，配置文件只需知道目标名称</li><li><strong>自动传递依赖:</strong> 链接导入目标时，该目标的公共依赖自动传递</li><li><strong>清晰明确:</strong> 链接指令直接表明依赖关系</li><li><strong>精确控制:</strong> 使用<code>PRIVATE</code>&#x2F;<code>PUBLIC</code>&#x2F;<code>INTERFACE</code>关键字精确控制依赖传递</li></ul><h3 id="对比总结-1"><a href="#对比总结-1" class="headerlink" title="对比总结"></a>对比总结</h3><table><thead><tr><th>方面</th><th>旧方式 (Variable-Centric)</th><th>新方式 (Target-Centric)</th></tr></thead><tbody><tr><td><strong>核心</strong></td><td>全局&#x2F;目录变量 (<code>_DIRS</code>, <code>_LIBS</code>)</td><td>目标及其属性 (<code>target_*</code>命令, 导入目标)</td></tr><tr><td><strong><code>find_package</code></strong></td><td>主要设置变量</td><td>主要定义导入目标 (<code>Namespace::Target</code>)</td></tr><tr><td><strong>配置方式</strong></td><td>手动应用变量到目标</td><td>链接导入目标，CMake自动处理细节</td></tr><tr><td><strong>包含路径</strong></td><td><code>include_directories()</code> (全局)</td><td><code>target_include_directories()</code> (目标级)</td></tr><tr><td><strong>链接</strong></td><td><code>target_link_libraries(... $&#123;..._LIBS&#125;)</code></td><td><code>target_link_libraries(... Namespace::Target)</code></td></tr><tr><td><strong>依赖传递</strong></td><td>手动处理，易出错</td><td>自动处理 (通过<code>PUBLIC</code>&#x2F;<code>INTERFACE</code>)</td></tr><tr><td><strong>封装性</strong></td><td>差</td><td>好</td></tr><tr><td><strong>推荐度</strong></td><td>不推荐</td><td><strong>强烈推荐</strong></td></tr></tbody></table><h2 id="三、实践建议"><a href="#三、实践建议" class="headerlink" title="三、实践建议"></a>三、实践建议</h2><ol><li><p><strong>始终优先使用现代CMake方法</strong></p><ul><li>使用<code>target_*</code>系列命令而非全局设置</li><li>链接导入目标而非变量列表</li></ul></li><li><p><strong>合理使用作用域关键字</strong></p><ul><li><code>PRIVATE</code>: 仅在目标内部使用，不传递给依赖者</li><li><code>PUBLIC</code>: 在目标内部使用且传递给依赖者</li><li><code>INTERFACE</code>: 不在目标内部使用，仅传递给依赖者</li></ul></li><li><p><strong>创建自己的库时</strong></p><ul><li>导出明确的目标而非变量</li><li>正确设置<code>PUBLIC</code>和<code>INTERFACE</code>属性以确保依赖正确传递</li></ul></li><li><p><strong>处理旧式库时</strong></p><ul><li>可以创建接口库封装旧式变量，使其符合现代CMake风格</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(SomeOldLib::SomeOldLib INTERFACE IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(SomeOldLib::SomeOldLib PROPERTIES</span><br><span class="line">  INTERFACE_INCLUDE_DIRECTORIES <span class="string">&quot;$&#123;SomeOldLib_INCLUDE_DIRS&#125;&quot;</span></span><br><span class="line">  INTERFACE_LINK_LIBRARIES <span class="string">&quot;$&#123;SomeOldLib_LIBRARIES&#125;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—find原理—以ceres为例子的实操</title>
      <link href="/2025/04/24/c6/"/>
      <url>/2025/04/24/c6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-更新-locate-数据库（必做！）"><a href="#1-更新-locate-数据库（必做！）" class="headerlink" title="1. 更新 locate 数据库（必做！）"></a>1. 更新 locate 数据库（必做！）</h2><ul><li><strong>操作:</strong> 打开终端，运行 <code>sudo updatedb</code></li><li><strong>原因:</strong> 确保 locate 的数据库包含你刚刚安装的新库的文件信息，否则后续步骤可能找不到任何内容</li></ul><h2 id="2-初步定位：查找核心配置文件-Config-cmake"><a href="#2-初步定位：查找核心配置文件-Config-cmake" class="headerlink" title="2. 初步定位：查找核心配置文件 (Config.cmake)"></a>2. 初步定位：查找核心配置文件 (Config.cmake)</h2><ul><li><strong>操作:</strong> 运行以下命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;ceres&#x27;</span></span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/home/xfy/3d/ceres/ceres-solver/build/third_party/abseil-cpp/abslConfig.cmake</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/cmake/CeresConfig.cmake.in</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/cmake/CreateCeresConfig.cmake</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/third_party/abseil-cpp/CMake/abslConfig.cmake.in</span><br><span class="line">/home/xfy/3d/ceres/ceres-solver/third_party/googletest/googletest/cmake/Config.cmake.in</span><br><span class="line">/usr/lib/cmake/Ceres/CeresConfig.cmake</span><br><span class="line">/usr/local/lib/cmake/Ceres/CeresConfig.cmake</span><br></pre></td></tr></table></figure><p>可以看到最后两行就是要找的，一个是系统级安装目录，一个是用户安装目录的。</p><h2 id="3-确定-find-package-名称"><a href="#3-确定-find-package-名称" class="headerlink" title="3. 确定 find_package 名称"></a>3. 确定 find_package 名称</h2><p>由CeresConfig.cmake可以知道这里的名称大小写是Ceres，所以应该是<code>find_package(Ceres REQUIRED)</code></p><h2 id="4-如何使用"><a href="#4-如何使用" class="headerlink" title="4. 如何使用"></a>4. 如何使用</h2><p>这个文档的注释中没有像OpenCV那样写出如何使用，此时就需要自己来寻找。</p><p>首先查找*Config.cmake 文件中是否有创建目标的代码：</p><ul><li><code>add_library(库名 IMPORTED)</code></li><li><code>add_library(库名::组件名 IMPORTED)</code></li></ul><p>这里查找看到：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">TARGET</span> ceres)</span><br><span class="line">  <span class="comment"># For backwards compatibility, create a local &#x27;alias&#x27; target with the</span></span><br><span class="line">  <span class="comment"># non-namespace-qualified Ceres target name. Note that this is not a</span></span><br><span class="line">  <span class="comment"># true ALIAS library in CMake terms as they cannot point to imported targets.</span></span><br><span class="line">  <span class="keyword">add_library</span>(ceres INTERFACE IMPORTED)</span><br><span class="line">  <span class="keyword">set_target_properties</span>(ceres PROPERTIES INTERFACE_LINK_LIBRARIES Ceres::ceres)</span><br></pre></td></tr></table></figure><p>创建了目标<code>Ceres::ceres</code>。</p><p>既然创建了目标，那说明是cmake的新使用方法就行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(my_app Ceres::ceres)</span><br></pre></td></tr></table></figure><h3 id="通用方法判断库是否提供导入目标"><a href="#通用方法判断库是否提供导入目标" class="headerlink" title="通用方法判断库是否提供导入目标"></a>通用方法判断库是否提供导入目标</h3><p>从这个 Ceres 的例子中，我们可以总结出一些通用方法来判断任何库是否提供导入目标：</p><ol><li><strong>查看库的配置文件</strong>：<ul><li>寻找 <code>include($&#123;XXX_DIR&#125;/XXXTargets.cmake)</code> 这样的语句</li><li>寻找 <code>add_library(XXX::XXX IMPORTED)</code> 这样的语句</li><li>寻找 <code>set_target_properties(XXX::XXX ...)</code> 这样的语句</li></ul></li><li><strong>查看库变量的设置</strong>：<ul><li>如果看到 <code>set(XXX_LIBRARIES XXX::XXX)</code>，表明库提供了导入目标</li></ul></li></ol><p>如果是传统方式的话：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统方式 - 需要同时设置包含目录和链接库</span></span><br><span class="line"><span class="comment"># 例外，在ceres和opencv的cmake中都说明了不需要target_include_directories</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PRIVATE <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-补充小知识：findpackage的查找顺序"><a href="#5-补充小知识：findpackage的查找顺序" class="headerlink" title="5. 补充小知识：findpackage的查找顺序"></a>5. 补充小知识：findpackage的查找顺序</h2><ol><li><strong>首先检查 Ceres_DIR 变量</strong><ul><li>如果设置了 Ceres_DIR，CMake 会直接查找该目录下的 CeresConfig.cmake</li><li>如果找到了有效的配置文件，查找过程立即结束</li></ul></li><li><strong>然后才会搜索 CMAKE_PREFIX_PATH</strong></li><li><strong>接着是 CMAKE_FRAMEWORK_PATH 和 CMAKE_APPBUNDLE_PATH</strong>（主要用于 macOS）</li><li><strong>最后是标准系统安装位置</strong><ul><li>&#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;Ceres&#x2F;</li><li>&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;Ceres&#x2F;</li></ul></li></ol><h3 id="如果想要指定版本，有两种方式："><a href="#如果想要指定版本，有两种方式：" class="headerlink" title="如果想要指定版本，有两种方式："></a>如果想要指定版本，有两种方式：</h3><ol><li><p><strong>使用 CMAKE_PREFIX_PATH（推荐）</strong></p><p> 这是最通用、最干净的方式，尤其是当处理多个第三方库时：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令行设置</span></span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=/home/xfy/3d/ceres/ceres-solver/build ..</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 或在 CMakeLists.txt 中：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 find_package 之前设置</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_PREFIX_PATH <span class="string">&quot;/home/xfy/3d/ceres/ceres-solver/build&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Ceres REQUIRED)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>优点</strong>：</p><ul><li>可以一次性指定多个库的搜索路径</li><li>不需要为每个库单独设置变量</li><li>是 CMake 推荐的方式</li></ul></li><li><p><strong>使用特定库的 _DIR 变量</strong></p><p> 对于单个库，直接设置其专用变量也很有效：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令行方式</span></span><br><span class="line">cmake -DCeres_DIR=/home/xfy/3d/ceres/ceres-solver/build/lib/cmake/Ceres ..</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 或在 CMakeLists.txt 中：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(Ceres_DIR <span class="string">&quot;/home/xfy/3d/ceres/ceres-solver/build/lib/cmake/Ceres&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Ceres REQUIRED)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>注意</strong>：Ceres_DIR 应该指向包含 CeresConfig.cmake 的确切目录，而不仅仅是构建目录。其中Ceres就是<strong>find_package名称</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—find原理—以opencv为例子的实操</title>
      <link href="/2025/04/24/c4/"/>
      <url>/2025/04/24/c4/</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>更新 <code>locate</code> 数据库 (必做！)</strong></p><ul><li><strong>操作:</strong> 打开终端，运行 <code>sudo updatedb</code>。</li><li><strong>原因:</strong> 确保 <code>locate</code> 的数据库包含你刚刚安装的新库的文件信息。否则后续步骤可能什么也找不到。</li></ul></li><li><p><strong>初步定位：查找核心配置文件 (<code>Config.cmake</code>)</strong></p><ul><li><p><strong>操作:</strong> 运行以下命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;opencv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为</span></span><br><span class="line">~ ❯ locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;opencv&#x27;</span></span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/3rdparty/ade/ade-0.1.1f/sources/ade/cmake/adeConfig.cmake.in</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/CPackConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/CPackSourceConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/OpenCVConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/opencv_python_config.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/build/unix-install/OpenCVConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/cmake/OpenCVGenConfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/cmake/OpenCVGenPkgconfig.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/cmake/templates/OpenCVConfig.cmake.in</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/samples/hal/c_hal/config.cmake</span><br><span class="line">/home/xfy/opencv_versions/4.5.5/opencv/samples/hal/slow_hal/config.cmake</span><br><span class="line">/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVConfig.cmake</span><br><span class="line">/usr/local/opencv/4.5.5/lib/cmake/opencv4/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/3rdparty/ade/ade-0.1.1f/sources/ade/cmake/adeConfig.cmake.in</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/CPackConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/CPackSourceConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/opencv_python_config.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/build/unix-install/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/cmake/OpenCVGenConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/cmake/OpenCVGenPkgconfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/cmake/templates/OpenCVConfig.cmake.in</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/samples/hal/c_hal/config.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/home/myslam/3d/opencv-4.2.0/samples/hal/slow_hal/config.cmake</span><br><span class="line">/var/lib/docker/overlay2/0809ea31aa8a06f4c911b20f04526b19005bfabdd262f23d6bb3a4ee464f4dbb/diff/usr/local/lib/cmake/opencv4/OpenCVConfig.cmake</span><br><span class="line">/var/lib/docker/overlay2/1f605c5b588ec93f0f1947a29092b374d5fd184eedbfea41eba42bc85f33b932/diff/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVConfig.cmake</span><br></pre></td></tr></table></figure><p>  可以看到有很多，但是我知道我是安装到&#x2F;usr&#x2F;local&#x2F;的所以看&#x2F;usr&#x2F;local&#x2F;opencv&#x2F;4.5.5&#x2F;lib&#x2F;cmake&#x2F;opencv4&#x2F;OpenCVConfig.cmake<br>  这一个</p></li></ul></li><li><p><strong>确定 <code>find_package</code> 名称</strong></p><p> 由OpenCVConfig.cmake可以知道这里的名称大小写是OpenCV，所以应该是find_package(OpenCV REQUIRED)</p><p> 这里可以指定模块，也可以不指定，没有太大影响的。之前文章的例子里指定了模块的写法是find_package(OpenCV REQUIRED COMPONENTS core imgcodecs highgui)</p></li><li><p><strong>然后通过gedit或者vim等等查看这个文件</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  The OpenCV CMake configuration file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#             ** File generated automatically, do not modify **</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Usage from an external project:</span></span><br><span class="line"><span class="comment">#    In your CMakeLists.txt, add these lines:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED)</span></span><br><span class="line"><span class="comment">#    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # Not needed for CMake &gt;= 2.8.11</span></span><br><span class="line"><span class="comment">#    target_link_libraries(MY_TARGET_NAME $&#123;OpenCV_LIBS&#125;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Or you can search for specific OpenCV modules:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core videoio)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    You can also mark OpenCV components as optional:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core OPTIONAL_COMPONENTS viz)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    If the module is found then OPENCV_&lt;MODULE&gt;_FOUND is set to TRUE.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    This file will define the following variables:</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIBS                     : The list of all imported targets for OpenCV modules.</span></span><br><span class="line"><span class="comment">#      - OpenCV_INCLUDE_DIRS             : The OpenCV include directories.</span></span><br><span class="line"><span class="comment">#      - OpenCV_COMPUTE_CAPABILITIES     : The version of compute capability.</span></span><br><span class="line"><span class="comment">#      - OpenCV_ANDROID_NATIVE_API_LEVEL : Minimum required level of Android API.</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION                  : The version of this OpenCV build: &quot;4.5.5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MAJOR            : Major version part of OpenCV_VERSION: &quot;4&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MINOR            : Minor version part of OpenCV_VERSION: &quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_PATCH            : Patch version part of OpenCV_VERSION: &quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_STATUS           : Development status of this build: &quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Advanced variables:</span></span><br><span class="line"><span class="comment">#      - OpenCV_SHARED                   : Use OpenCV as shared library</span></span><br><span class="line"><span class="comment">#      - OpenCV_INSTALL_PATH             : OpenCV location</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIB_COMPONENTS           : Present OpenCV modules list</span></span><br><span class="line"><span class="comment">#      - OpenCV_USE_MANGLED_PATHS        : Mangled OpenCV path flag</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Deprecated variables:</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_TWEAK            : Always &quot;0&quot;</span></span><br></pre></td></tr></table></figure><p> 翻译一下</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================================================</span></span><br><span class="line"><span class="comment">#  OpenCV CMake 配置文件</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#             ** 文件自动生成，请勿修改 **</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  从外部项目使用：</span></span><br><span class="line"><span class="comment">#    在你的 CMakeLists.txt 中，添加这些行：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED)</span></span><br><span class="line"><span class="comment">#    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # 对于 CMake &gt;= 2.8.11 已不再需要</span></span><br><span class="line"><span class="comment">#    target_link_libraries(MY_TARGET_NAME $&#123;OpenCV_LIBS&#125;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    或者你可以搜索特定的 OpenCV 模块：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core videoio)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    你也可以将 OpenCV 组件标记为可选：</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED core OPTIONAL_COMPONENTS viz)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    如果找到了模块，那么 OPENCV_&lt;MODULE&gt;_FOUND 会被设置为 TRUE。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    该文件将定义以下变量：</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIBS                     : OpenCV 模块的所有导入目标 (imported targets) 的列表。</span></span><br><span class="line"><span class="comment">#      - OpenCV_INCLUDE_DIRS             : OpenCV 的包含目录。</span></span><br><span class="line"><span class="comment">#      - OpenCV_COMPUTE_CAPABILITIES     : 计算能力 (Compute Capability) 的版本。</span></span><br><span class="line"><span class="comment">#      - OpenCV_ANDROID_NATIVE_API_LEVEL : 最低要求的 Android API 级别。</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION                  : 此 OpenCV 构建的版本：&quot;4.5.5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MAJOR            : OpenCV_VERSION 的主版本号：&quot;4&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_MINOR            : OpenCV_VERSION 的次版本号：&quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_PATCH            : OpenCV_VERSION 的修订版本号：&quot;5&quot;</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_STATUS           : 此构建的开发状态：&quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    高级变量：</span></span><br><span class="line"><span class="comment">#      - OpenCV_SHARED                   : 将 OpenCV 作为共享库使用</span></span><br><span class="line"><span class="comment">#      - OpenCV_INSTALL_PATH             : OpenCV 的位置</span></span><br><span class="line"><span class="comment">#      - OpenCV_LIB_COMPONENTS           : 当前存在的 OpenCV 模块列表</span></span><br><span class="line"><span class="comment">#      - OpenCV_USE_MANGLED_PATHS        : Mangled OpenCV 路径标志</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    已弃用变量：</span></span><br><span class="line"><span class="comment">#      - OpenCV_VERSION_TWEAK            : 始终为 &quot;0&quot;</span></span><br></pre></td></tr></table></figure><p> 可以看到这里说明了执行findpackage之后给哪些变量赋予了哪些值，也写了用法</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  从外部项目使用：</span></span><br><span class="line"><span class="comment">#    在你的 CMakeLists.txt 中，添加这些行：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    find_package(OpenCV REQUIRED)</span></span><br><span class="line"><span class="comment">#    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # 对于 CMake &gt;= 2.8.11 已不再需要</span></span><br><span class="line"><span class="comment">#    target_link_libraries(MY_TARGET_NAME $&#123;OpenCV_LIBS&#125;)</span></span><br></pre></td></tr></table></figure><p> 这段注释虽然目的是指导用户，但它本身混合了新旧两种风格的痕迹，我们需要仔细解读：</p><ol><li><strong>旧方式 (Variable-Based) 的体现：</strong><ul><li><p><strong>明确的指令:</strong> 注释中明确给出了以下使用步骤：</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MY_TARGET_NAME <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p>这是典型的旧式 CMake 用法。它依赖于 <code>find_package</code> 执行后设置的两个<strong>变量</strong>：</p><ul><li><code>$&#123;OpenCV_INCLUDE_DIRS&#125;</code>: 包含了需要添加到编译器搜索路径的头文件目录。你需要手动调用 <code>include_directories()</code> (或现代的 <code>target_include_directories()</code>) 来使用它。</li><li><code>$&#123;OpenCV_LIBS&#125;</code>: 包含了需要链接的库文件列表（可能是库文件的绝对路径，也可能在旧 CMake 中是链接器标志）。你需要手动将这个变量传递给 <code>target_link_libraries()</code>。</li></ul></li></ul></li><li><strong>新方式 (Target-Based) 的线索和提示：</strong><ul><li><p><strong>关键注释:</strong> <code>include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # Not needed for CMake &gt;= 2.8.11</code></p><ul><li>这是<strong>最强烈的暗示</strong>。它告诉你，对于较新版本的 CMake (2.8.11 及以后，实际上现代 CMake 实践通常指 3.x 系列)，手动添加 <code>OpenCV_INCLUDE_DIRS</code> 是<strong>不必要</strong>的。为什么？因为现代 CMake 的核心是<strong>目标 (Target)</strong>。当你链接到一个设计良好的<strong>导入目标 (Imported Target)</strong> 时，这个目标本身就封装了它所需的包含目录、链接库、编译定义等信息。CMake 会自动将这些信息传递给链接它的目标。</li></ul></li><li><p><strong>变量 <code>OpenCV_LIBS</code> 的描述:</strong> <code>OpenCV_LIBS : The list of all **imported targets** for OpenCV modules.</code></p><ul><li>这一点非常重要！虽然旧方式的使用示例中是 <code>target_link_libraries(... $&#123;OpenCV_LIBS&#125;)</code>，但这里对 <code>OpenCV_LIBS</code> 变量内容的描述明确指出了它包含的是 <strong>“imported targets”</strong>。这意味着 <code>$&#123;OpenCV_LIBS&#125;</code> 变量里存放的不再仅仅是库文件名或路径，而是 CMake 能理解的、代表了 OpenCV 各个模块的<strong>目标名称</strong>列表（例如 <code>OpenCV::core</code>, <code>OpenCV::imgproc</code> 等）。</li></ul></li><li><p>结合以上两点，可以推断出新方式的用法（尽管这段注释没有直接写出来）</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED COMPONENTS core imgproc highgui) <span class="comment"># 假设需要这三个</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MY_TARGET_NAME PRIVATE OpenCV::core OpenCV::imgproc OpenCV::highgui)</span><br><span class="line"></span><br><span class="line">这里<span class="keyword">find_package</span>可以不指定具体哪个模块而是用</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line">区别不大</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>推荐指定模块，不然就会把所有模块全都链接到项目上</span><br><span class="line"></span><br><span class="line">说是这样说，但是我指定模块运行失败，不知道是因为名字不对还是啥</span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)才成功的</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h3 id="总结：还是用文档里说的吧"><a href="#总结：还是用文档里说的吧" class="headerlink" title="总结：还是用文档里说的吧"></a>总结：还是用文档里说的吧</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  从外部项目使用：</span></span><br><span class="line"><span class="comment">#    在你的 CMakeLists.txt 中，添加这些行：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>) <span class="comment"># 对于 CMake &gt;= 2.8.11 已不再需要</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MY_TARGET_NAME <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line">其中<span class="keyword">include_directories</span>可有可无</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—find原理</title>
      <link href="/2025/04/24/c3/"/>
      <url>/2025/04/24/c3/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在CMake中找到并链接新安装的库"><a href="#如何在CMake中找到并链接新安装的库" class="headerlink" title="如何在CMake中找到并链接新安装的库"></a>如何在CMake中找到并链接新安装的库</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在安装新库后，找出在CMake中<code>find_package</code>所需的<strong>精确包名</strong>（包括大小写），并了解如何正确链接该库（优先使用现代CMake目标）。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1-更新locate数据库（必做！）"><a href="#1-更新locate数据库（必做！）" class="headerlink" title="1. 更新locate数据库（必做！）"></a>1. 更新<code>locate</code>数据库（必做！）</h3><ul><li><strong>操作:</strong> 打开终端，运行<code>sudo updatedb</code></li><li><strong>原因:</strong> 确保<code>locate</code>的数据库包含你刚刚安装的新库的文件信息</li><li><strong>注意:</strong> 如果跳过此步骤，后续步骤可能找不到任何结果</li></ul><h3 id="2-初步定位：查找核心配置文件（Config-cmake）"><a href="#2-初步定位：查找核心配置文件（Config-cmake）" class="headerlink" title="2. 初步定位：查找核心配置文件（Config.cmake）"></a>2. 初步定位：查找核心配置文件（<code>Config.cmake</code>）</h3><ul><li><strong>操作:</strong> 运行以下命令（替换<code>库名关键词</code>）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;config.cmake&#x27;</span> | grep -i <span class="string">&#x27;库名关键词&#x27;</span></span><br></pre></td></tr></table></figure></li><li><strong>目的:</strong> 查找包含<code>config.cmake</code>（不区分大小写）且路径中包含指定库名关键词的文件</li><li><strong>分析结果:</strong> 注意文件路径，例如：<ul><li><code>/usr/lib/x86_64-linux-gnu/cmake/SomeLib/SomeLibConfig.cmake</code></li><li><code>/opt/my_libs/lib/cmake/somelib/somelib-config.cmake</code></li></ul></li></ul><h3 id="3-确定find-package名称"><a href="#3-确定find-package名称" class="headerlink" title="3. 确定find_package名称"></a>3. 确定<code>find_package</code>名称</h3><ul><li><strong>操作:</strong> 从上一步找到的配置文件路径中提取<strong>保留原始大小写的包名</strong></li><li><strong>提取方法:</strong> 包名通常位于<code>.../cmake/</code>目录之后，是<code>Config.cmake</code>文件或其所在目录的名称<ul><li>例如：<ul><li><code>/usr/lib/x86_64-linux-gnu/cmake/SomeLib/SomeLibConfig.cmake</code> → 包名为<code>SomeLib</code></li><li><code>/opt/my_libs/lib/cmake/somelib/somelib-config.cmake</code> → 包名为<code>somelib</code></li></ul></li></ul></li><li><strong>结果:</strong> 提取出的精确名称将用于<code>CMakeLists.txt</code>中的<code>find_package()</code></li></ul><h3 id="4-全面查找：找到所有相关的-cmake文件（可选但推荐）"><a href="#4-全面查找：找到所有相关的-cmake文件（可选但推荐）" class="headerlink" title="4. 全面查找：找到所有相关的.cmake文件（可选但推荐）"></a>4. 全面查找：找到所有相关的<code>.cmake</code>文件（可选但推荐）</h3><ul><li><strong>操作:</strong> 运行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -i <span class="string">&#x27;库名关键词&#x27;</span> | grep -i <span class="string">&#x27;\.cmake$&#x27;</span></span><br></pre></td></tr></table></figure></li><li><strong>目的:</strong> 找到所有路径包含库名关键词且以<code>.cmake</code>结尾的文件</li><li><strong>用途:</strong> 这有助于了解整个CMake配置的结构</li></ul><h3 id="5-深入检查：查看文件内容，确认链接方式"><a href="#5-深入检查：查看文件内容，确认链接方式" class="headerlink" title="5. 深入检查：查看文件内容，确认链接方式"></a>5. 深入检查：查看文件内容，确认链接方式</h3><ul><li><strong>操作:</strong><ul><li>用文本编辑器打开第2步找到的核心<code>Config.cmake</code>文件</li><li>检查是否通过<code>include()</code>命令包含了其他<code>.cmake</code>文件，如有则一并查看</li></ul></li><li><strong>检查要点:</strong><ul><li><strong>寻找导入目标:</strong> 搜索<code>add_library</code>关键字，寻找形如<code>add_library(Namespace::Target IMPORTED ...)</code>的行<ul><li>如找到，<strong>强烈建议</strong>使用现代CMake的链接方式：<code>target_link_libraries(... Namespace::Target)</code></li></ul></li><li><strong>寻找变量定义:</strong> 搜索<code>set(</code>命令，查找版本变量<code>$&#123;SomeLib_VERSION&#125;</code>或包含目录&#x2F;库变量<code>$&#123;SomeLib_INCLUDE_DIRS&#125;</code>, <code>$&#123;SomeLib_LIBRARIES&#125;</code></li><li><strong>查看依赖:</strong> 注意是否有<code>find_dependency(...)</code>命令，了解库是否自动处理依赖</li><li><strong>阅读注释:</strong> 好的配置文件通常包含使用说明</li></ul></li></ul><h3 id="6-在CMakeLists-txt中实践"><a href="#6-在CMakeLists-txt中实践" class="headerlink" title="6. 在CMakeLists.txt中实践"></a>6. 在<code>CMakeLists.txt</code>中实践</h3><ul><li><strong>操作:</strong><ul><li>使用第3步确定的<strong>精确包名</strong>调用<code>find_package</code>:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(SomeLib REQUIRED) <span class="comment"># 使用大小写正确的名字</span></span><br><span class="line"><span class="comment"># 或者，如果库支持组件：</span></span><br><span class="line"><span class="comment"># find_package(SomeLib REQUIRED COMPONENTS core gui)</span></span><br></pre></td></tr></table></figure></li><li><strong>优先使用导入目标</strong>（如果在第5步找到）:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(your_target PRIVATE SomeLib::core SomeLib::gui)</span><br></pre></td></tr></table></figure></li><li><strong>如果找不到导入目标</strong>（旧式库）:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(your_target PRIVATE <span class="variable">$&#123;SomeLib_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_target PRIVATE <span class="variable">$&#123;SomeLib_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ol><li>先用<code>locate</code>定位关键的<code>*Config.cmake</code>文件，确定<code>find_package</code>的官方名称</li><li>检查配置文件内容，确认链接方式：<ul><li>现代方式：使用导入目标(<code>Namespace::Target</code>)</li><li>传统方式：使用包含目录和库变量</li></ul></li><li>在实际项目中正确使用找到的库</li></ol><blockquote><p><strong>提示：</strong> 虽然<code>locate</code>是方便的本地检查工具，但<strong>库的官方文档</strong>仍然是了解其CMake用法的最权威来源。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—CMake</title>
      <link href="/2025/04/24/c2/"/>
      <url>/2025/04/24/c2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-最小可行的-CMakeLists-txt"><a href="#1-最小可行的-CMakeLists-txt" class="headerlink" title="1. 最小可行的 CMakeLists.txt"></a>1. <strong>最小可行的 CMakeLists.txt</strong></h2><p><strong>思考：</strong></p><p>我需要告诉 CMake 什么？</p><ul><li>它需要知道最低兼容的 CMake 版本是多少？（<code>cmake_minimum_required</code>）</li><li>我的项目叫什么名字？（<code>project</code>）</li><li>我想生成什么？（一个可执行文件？一个库？）（<code>add_executable</code> 或 <code>add_library</code>）</li><li>这个生成目标需要哪些源文件？（<code>add_executable</code> 或 <code>add_library</code> 的参数）</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 指定 CMake 最低版本要求</span></span><br><span class="line"><span class="comment">#    Ubuntu 22.04 自带的 CMake 版本通常较高 (如 3.22+)，但设置一个稍低的版本（如 3.16）可以增加兼容性。</span></span><br><span class="line"><span class="comment">#    这确保了我们使用的 CMake 命令和特性在该版本及以上可用。</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定义项目名称和语言</span></span><br><span class="line"><span class="comment">#    项目名称会用在一些默认变量和 IDE 中。</span></span><br><span class="line"><span class="comment">#    指定 CXX 表示这是一个 C++ 项目，CMake 会自动寻找并配置 C++ 编译器。</span></span><br><span class="line"><span class="keyword">project</span>(MyMinimalProject CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加一个可执行文件目标</span></span><br><span class="line"><span class="comment">#    第一个参数 &quot;my_app&quot; 是你想要生成的可执行文件的名字。</span></span><br><span class="line"><span class="comment">#    后续参数是构成这个可执行文件的源文件列表。这里只有一个 main.cpp。</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>cmake_minimum_required(VERSION 3.16)</code>：告诉 CMake 使用至少 3.16 版本的语法和功能。如果系统上的 CMake 版本低于此，它会报错。</li><li><code>project(MyMinimalProject CXX)</code>：定义项目名为 <code>MyMinimalProject</code>，并声明主要语言是 C++ (<code>CXX</code>)。这会让 CMake 检查 C++ 编译器是否可用。</li><li><code>add_executable(my_app main.cpp)</code>：指示 CMake 创建一个名为 <code>my_app</code> 的可执行文件，该文件由 <code>main.cpp</code> 编译而来。</li></ul><p><strong>构建步骤：</strong></p><ol><li>打开终端，进入 <code>my_minimal_project</code> 目录。</li><li>创建构建目录并进入：<code>mkdir build &amp;&amp; cd build</code> (推荐将构建产物与源码分开)</li><li>运行 CMake 配置：<code>cmake ..</code> ( <code>..</code> 指向包含 <code>CMakeLists.txt</code> 的上级目录)</li><li>编译项目：<code>make</code> (或者 <code>cmake --build .</code>)</li><li>运行可执行文件：<code>./my_app</code></li></ol><h2 id="2-更多源文件的处理"><a href="#2-更多源文件的处理" class="headerlink" title="2. 更多源文件的处理"></a>2. <strong>更多源文件的处理</strong></h2><p><strong>思考：</strong></p><ol><li><strong>如何告诉 <code>add_executable</code> 所有需要的 <code>.cpp</code> 文件？</strong><ul><li>直接在 <code>add_executable</code> 命令中列出所有 <code>.cpp</code> 文件？</li><li>用一个变量来存储源文件列表，然后传递给 <code>add_executable</code>？（更整洁）</li><li>让 CMake 自动查找目录下的 <code>.cpp</code> 文件？（<code>aux_source_directory</code> 或 <code>file(GLOB ...)</code>，<strong>不推荐</strong>用于源文件，因为新增&#x2F;删除文件时 CMake 可能不会自动检测到变化）</li></ul></li><li><strong>如果源文件分散在不同目录（如 <code>src/</code>），CMake 如何找到它们？</strong><ul><li>在文件名中包含相对路径（例如 <code>src/main.cpp</code>）。</li></ul></li><li><strong>如果头文件放在单独的目录（如 <code>include/</code>），编译器如何找到它们？</strong><ul><li>需要告诉 CMake 头文件的搜索路径。（<code>target_include_directories</code>）</li></ul></li></ol><p><strong>代码示例：</strong></p><p>假设项目结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_multi_file_project/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include/</span><br><span class="line">│   └── helper.h</span><br><span class="line">└── src/</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    └── helper.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>include/helper.h</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELPER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELPER_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELPER_H</span></span></span><br></pre></td></tr></table></figure><p><code>src/helper.cpp</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span> <span class="comment">// 注意这里可以直接 include，因为我们会告诉 CMake 头文件路径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Message from helper!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/main.cpp</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span> <span class="comment">// 包含我们自己的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_message</span>(); <span class="comment">// 调用来自 helper 的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(MyMultiFileProject CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 使用变量存储源文件列表 (推荐方式)</span></span><br><span class="line"><span class="comment">#    将所有需要编译的 .cpp 文件列在这里。使用相对路径。</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/helper.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加可执行文件目标，使用变量</span></span><br><span class="line"><span class="comment">#    将 $&#123;SOURCES&#125; 变量的内容展开作为源文件列表。</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_app <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 指定头文件搜索路径</span></span><br><span class="line"><span class="comment">#    告诉 CMake，当编译 my_app 这个目标时，</span></span><br><span class="line"><span class="comment">#    应该到 &quot;include&quot; 目录下查找头文件 (#include &quot;...&quot;).</span></span><br><span class="line"><span class="comment">#    PUBLIC 意味着如果其他目标链接到 my_app，它们也会自动获得这个 include 目录。</span></span><br><span class="line"><span class="comment">#    对于可执行文件，PRIVATE 通常也足够。</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>set(SOURCES ...)</code>：创建了一个名为 <code>SOURCES</code> 的 CMake 变量，存储了所有 <code>.cpp</code> 文件的列表。这比在 <code>add_executable</code> 中写一长串文件名更清晰，易于维护。</li><li><code>add_executable(my_app $&#123;SOURCES&#125;)</code>：使用 <code>$&#123;VAR_NAME&#125;</code> 语法来引用变量 <code>SOURCES</code>。</li><li><code>target_include_directories(my_app PUBLIC include)</code>：这是关键一步。它告诉编译器在编译 <code>my_app</code> 的源文件时，去 <code>include</code> 目录下查找 <code>#include</code> 的头文件。没有这一行，<code>#include &quot;helper.h&quot;</code> 会失败。<code>PUBLIC</code> 关键字表示这个包含目录不仅 <code>my_app</code> 自己用，如果将来有其他 CMake 目标链接到 <code>my_app</code>，它们也会继承这个包含目录（对于可执行文件，通常用 <code>PRIVATE</code> 即可，表示仅 <code>my_app</code> 内部使用）。</li></ul><h2 id="3-第三方库如何使用（以OpenCV为例）"><a href="#3-第三方库如何使用（以OpenCV为例）" class="headerlink" title="3.  第三方库如何使用（以OpenCV为例）"></a>3.  第三方库如何使用（以OpenCV为例）</h2><p><strong>思考：</strong></p><ol><li><strong>如何让 CMake 找到已安装的 OpenCV 库？</strong><ul><li>使用 <code>find_package</code> 命令。这是 CMake 查找外部库的标准方式。</li></ul></li><li><strong>我需要 OpenCV 的哪些部分（模块）？</strong><ul><li>OpenCV 是模块化的（如 <code>core</code>, <code>imgproc</code>, <code>highgui</code> 等）。明确指定需要的模块可以减少不必要的依赖和链接。</li><li><code>find_package</code> 允许通过 <code>COMPONENTS</code> 参数指定所需模块。</li></ul></li><li><strong><code>find_package</code> 找到库后，如何将它链接到我的目标（<code>my_app</code>）？</strong><ul><li>需要告诉 CMake 两件事：<ul><li>编译器在哪里找到 OpenCV 的头文件</li><li>链接器在哪里找到 OpenCV 的库文件并将它们链接到我的可执行文件</li></ul></li><li><strong>现代 CMake 方式（推荐）：</strong> 使用 <code>target_link_libraries</code> 配合 <code>find_package</code> 提供的 “Imported Target” (例如 <code>OpenCV::opencv_core</code>)。这种方式会自动处理头文件路径和库链接。</li><li><strong>旧式 CMake 方式（了解即可）：</strong> <code>find_package</code> 会设置一些变量（如 <code>OpenCV_INCLUDE_DIRS</code> 和 <code>OpenCV_LIBS</code>），然后手动使用 <code>target_include_directories</code> 和 <code>target_link_libraries</code>。</li></ul></li></ol><p><strong>代码示例：</strong></p><p>假设项目结构不变，我们修改 <code>main.cpp</code> 来使用 OpenCV。</p><p><code>src/main.cpp</code> (示例：读取并显示一张图片):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含 OpenCV 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;Image_Path&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_message</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图片</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(argv[<span class="number">1</span>], cv::IMREAD_COLOR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Could not read the image: &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图片</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Display window&quot;</span>, image);</span><br><span class="line">    <span class="type">int</span> k = cv::<span class="built_in">waitKey</span>(<span class="number">0</span>); <span class="comment">// 等待按键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(MyOpenCVProject CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/main.cpp</span><br><span class="line">    src/helper.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- OpenCV Integration ---</span></span><br><span class="line"><span class="comment"># 1. 查找 OpenCV 包</span></span><br><span class="line"><span class="comment">#    REQUIRED: 如果找不到 OpenCV，CMake 会报错停止。</span></span><br><span class="line"><span class="comment">#    COMPONENTS: 指定我们需要的模块。</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED COMPONENTS core imgcodecs highgui)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否成功找到 (可选，但推荐)</span></span><br><span class="line"><span class="keyword">if</span>(OpenCV_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Found OpenCV version: $&#123;OpenCV_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;OpenCV not found!&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># --- End OpenCV Integration ---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my_app <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Link OpenCV to the target ---</span></span><br><span class="line"><span class="comment"># 2. 将 OpenCV 链接到我们的可执行文件 (现代方式)</span></span><br><span class="line"><span class="comment">#    OpenCV 的 find_package 脚本会创建所谓的 &quot;Imported Targets&quot;。</span></span><br><span class="line"><span class="comment">#    通常格式是 `OpenCV::module_name` (例如 OpenCV::core, OpenCV::imgcodecs)。</span></span><br><span class="line"><span class="comment">#    链接这些 Imported Targets 会自动处理包含目录和库文件。</span></span><br><span class="line"><span class="comment">#    PRIVATE 表示链接的库仅 my_app 内部使用，不会传递给链接到 my_app 的其他目标。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐这样做，但我实际操作找不到</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE</span><br><span class="line">    OpenCV::core</span><br><span class="line">    OpenCV::imgcodecs</span><br><span class="line">    OpenCV::highgui</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 最后是通过这个成功运行的</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_app PUBLIC <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- End Link OpenCV ---</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>find_package(OpenCV REQUIRED COMPONENTS ...)</code>：指示 CMake 查找 OpenCV。<code>REQUIRED</code> 确保找不到时构建失败。<code>COMPONENTS</code> 列出了我们代码中实际用到的 OpenCV 模块 (<code>core</code> 对应 <code>cv::Mat</code>, <code>imgcodecs</code> 对应 <code>cv::imread</code>, <code>highgui</code> 对应 <code>cv::imshow</code>, <code>cv::waitKey</code>)。</li><li><code>message(STATUS ...)</code>：在 CMake 配置阶段打印信息，方便调试。</li><li><code>target_link_libraries(my_app PRIVATE OpenCV::core ...)</code>：这是最关键的一步。它将 <code>my_app</code> 链接到 <code>find_package</code> 找到的 OpenCV 模块。使用 <code>OpenCV::module_name</code> 这种 Imported Target 是现代 CMake 的推荐做法，它比旧方法更简洁、更健壮，CMake 会自动管理头文件路径 (<code>target_include_directories</code> 不需要再为 OpenCV 手动添加) 和库文件链接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记—基础篇</title>
      <link href="/2025/04/24/c1/"/>
      <url>/2025/04/24/c1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-学习笔记—基础篇"><a href="#C-学习笔记—基础篇" class="headerlink" title="C++学习笔记—基础篇"></a>C++学习笔记—基础篇</h1><h2 id="1-安装最基础的编译环境"><a href="#1-安装最基础的编译环境" class="headerlink" title="1. 安装最基础的编译环境"></a>1. 安装最基础的编译环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install build-essential</span><br></pre></td></tr></table></figure><p>验证有没有装好，输出版本信息即装好了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ --version</span><br><span class="line">make --version</span><br></pre></td></tr></table></figure><h2 id="2-第一个程序"><a href="#2-第一个程序" class="headerlink" title="2. 第一个程序"></a>2. 第一个程序</h2><p>使用任意的编辑器编写一个hello.cpp然后编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure><ul><li><code>g++</code>: 调用 GNU C++ 编译器。</li><li><code>hello.cpp</code>: 你要编译的源文件。</li><li><code>o hello</code>: 这个选项告诉编译器，将生成的可执行文件命名为 <code>hello</code>。如果没有 <code>o</code> 选项，默认会生成一个名为 <code>a.out</code> 的文件。</li></ul><h2 id="3-使用-make-简化编译"><a href="#3-使用-make-简化编译" class="headerlink" title="3. 使用 make 简化编译"></a>3. <strong>使用 <code>make</code> 简化编译</strong></h2><p>如果项目比较复杂的话，只通过命令编译就会很长</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp math_utils.cpp -o my_calc -Wall -Wextra -std=c++11</span><br></pre></td></tr></table></figure><p><code>make</code> 通过 <code>Makefile</code> 文件来解决手动编译的许多问题</p><p>创建一个 <code>Makefile</code> 文件然后通过 <code>make</code> 命令就可以自动的编译（过程省略）但是 <code>Makefile</code> 文件不是很好写</p><h2 id="4-使用-CMake"><a href="#4-使用-CMake" class="headerlink" title="4. 使用 CMake"></a>4. <strong>使用 <code>CMake</code></strong></h2><p><code>CMake</code> 作为构建系统生成器，解决了 <code>make</code> 的许多局限性，尤其是在跨平台和管理复杂性方面。</p><ol><li><p><strong>创建 <code>CMakeLists.txt</code>:</strong> 在 <code>calculator</code> 目录下创建 <code>CMakeLists.txt</code> 文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称和语言</span></span><br><span class="line"><span class="keyword">project</span>(Calculator LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 C++ 标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (可选) 添加编译选项，会传递给编译器</span></span><br><span class="line"><span class="comment"># add_compile_options(-Wall -Wextra) # 或者更现代的方式如下：</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(my_calc INTERFACE -Wall -Wextra) <span class="comment"># 应用于 my_calc 及其使用者</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件目标</span></span><br><span class="line"><span class="comment"># CMake 会自动分析 main.cpp 和 math_utils.cpp 之间的依赖</span></span><br><span class="line"><span class="comment"># 以及它们对 math_utils.h 的依赖</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_calc main.cpp math_utils.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果头文件在 include 目录:</span></span><br><span class="line"><span class="comment"># target_include_directories(my_calc PRIVATE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>操作 (Out-of-Source Build):</strong></p><ul><li><p><strong>创建构建目录并进入:</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure></li><li><p>**运行 CMake (配置阶段):**CMake 会读取 <code>../CMakeLists.txt</code>，检测你的编译器，并生成一个 <code>Makefile</code> (或其他本地构建系统文件) 在 <code>build</code> 目录中。它会自动处理 <code>main.cpp</code> 对 <code>math_utils.h</code> 的依赖。</p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure></li><li><p><strong>运行构建工具 (构建阶段):</strong><code>make</code> 会使用 CMake 生成的 <code>Makefile</code> 来编译项目。可执行文件 <code>my_calc</code> 会出现在 <code>build</code> 目录。</p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p><strong>运行:</strong></p><p>  bash</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_calc</span><br></pre></td></tr></table></figure></li><li><p><strong>清理:</strong></p><ul><li>可以使用 <code>make clean</code> (由 CMake 生成的 <code>Makefile</code> 提供)。</li><li>或者更彻底地，删除整个 <code>build</code> 目录：<code>cd .. &amp;&amp; rm -rf build</code>。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git学习记录</title>
      <link href="/2025/04/22/git/"/>
      <url>/2025/04/22/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><hr><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>在官方网站安装: <a href="https://git-scm.com/">https://git-scm.com/</a></p><hr><h2 id="2-初始化配置"><a href="#2-初始化配置" class="headerlink" title="2. 初始化配置"></a>2. 初始化配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置全局用户名和邮箱</span></span><br><span class="line">git config --global user.name <span class="string">&quot;name&quot;</span></span><br><span class="line">git config --global user.email xxxx@gmail.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 凭证存储</span></span><br><span class="line"><span class="comment"># 第一次通过 HTTPS 方式 push 或 pull 时，Git 会要求输入用户名和密码</span></span><br><span class="line"><span class="comment"># （或 Personal Access Token）。操作成功后，&quot;store&quot; 会把凭证以明文格式写入文件</span></span><br><span class="line"><span class="comment"># 以后再访问同一个远程仓库时，Git 会自动读取凭证，不再重复询问</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置默认分支，现在推荐使用main</span></span><br><span class="line">git config --global init.defaultBranch main</span><br></pre></td></tr></table></figure><hr><h2 id="3-创建一个新仓库"><a href="#3-创建一个新仓库" class="headerlink" title="3. 创建一个新仓库"></a>3. 创建一个新仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 初始化本地仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 克隆远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;仓库URL&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="4-工作区域和文件状态"><a href="#4-工作区域和文件状态" class="headerlink" title="4. 工作区域和文件状态"></a>4. 工作区域和文件状态</h2><h3 id="Git中的三种工作区域"><a href="#Git中的三种工作区域" class="headerlink" title="Git中的三种工作区域"></a>Git中的三种工作区域</h3><ol><li><p><strong>工作区</strong>(.git所在目录)</p><ul><li>在资源管理器中看到的目录</li></ul></li><li><p><strong>暂存区</strong>(.git&#x2F;index)</p><ul><li>用于保存即将提交到Git仓库的修改内容</li></ul></li><li><p><strong>本地仓库</strong>(.git&#x2F;objects)</p><ul><li>Git存储代码和版本信息的主要位置</li></ul></li></ol><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423151837456.png" alt="工作区域"></p><h3 id="Git中的四种文件状态"><a href="#Git中的四种文件状态" class="headerlink" title="Git中的四种文件状态"></a>Git中的四种文件状态</h3><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423153227238.png" alt="文件状态"></p><hr><h2 id="5-添加和提交文件"><a href="#5-添加和提交文件" class="headerlink" title="5. 添加和提交文件"></a>5. 添加和提交文件</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h3><p>查看仓库的状态</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><code>git add</code></h3><p>将文件添加到暂存区</p><ul><li>可以使用通配符：<code>git add *.txt</code></li><li>也可以使用目录：<code>git add .</code></li></ul><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h3><p>提交到本地仓库</p><ul><li>只提交<strong>暂存区</strong>中的内容，不会提交<strong>工作区</strong>中的内容</li></ul><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h3><p>查看仓库提交历史记录</p><ul><li>使用 <code>--oneline</code> 参数查看简洁的提交记录</li></ul><h3 id="git-ls-files"><a href="#git-ls-files" class="headerlink" title="git ls-files"></a><code>git ls-files</code></h3><p>查看暂存区的内容</p><hr><h2 id="6-git-reset回退版本"><a href="#6-git-reset回退版本" class="headerlink" title="6. git reset回退版本"></a>6. git reset回退版本</h2><h3 id="Git-reset的三种模式"><a href="#Git-reset的三种模式" class="headerlink" title="Git reset的三种模式"></a>Git reset的三种模式</h3><ul><li><p><code>git reset --soft</code> </p><ul><li>回退到某个版本，保留工作区和暂存区的所有内容</li></ul></li><li><p><code>git reset --hard</code> </p><ul><li>回退到某个版本，丢弃工作区和暂存区的所有内容</li></ul></li><li><p><code>git reset --mixed</code> (默认参数)</p><ul><li>回退到某个版本，保留工作区的内容，丢弃暂存区的内容</li></ul></li></ul><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423155650856.png" alt="Git reset模式"></p><hr><h2 id="7-使用git-diff查看差异"><a href="#7-使用git-diff查看差异" class="headerlink" title="7. 使用git diff查看差异"></a>7. 使用git diff查看差异</h2><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a><code>git diff</code></h3><p>比较：<strong>工作区</strong> 🆚 <strong>暂存区</strong></p><h3 id="git-diff-HEAD"><a href="#git-diff-HEAD" class="headerlink" title="git diff HEAD"></a><code>git diff HEAD</code></h3><p>比较：<strong>工作区 + 暂存区</strong> 🆚 <strong>本地仓库</strong></p><h3 id="git-diff-cached-git-diff-staged"><a href="#git-diff-cached-git-diff-staged" class="headerlink" title="git diff --cached &#x2F; git diff --staged"></a><code>git diff --cached</code> &#x2F; <code>git diff --staged</code></h3><p>比较：<strong>暂存区</strong> 🆚 <strong>本地仓库</strong></p><h3 id="git-diff-1"><a href="#git-diff-1" class="headerlink" title="git diff &lt;commit_hash&gt; &lt;commit_hash&gt;"></a><code>git diff &lt;commit_hash&gt; &lt;commit_hash&gt;</code></h3><h3 id="git-diff-HEAD-HEAD"><a href="#git-diff-HEAD-HEAD" class="headerlink" title="git diff HEAD~ HEAD"></a><code>git diff HEAD~ HEAD</code></h3><p>比较两个**提交（commit）**之间的差异</p><h3 id="git-diff-2"><a href="#git-diff-2" class="headerlink" title="git diff &lt;branch_name&gt; &lt;branch_name&gt;"></a><code>git diff &lt;branch_name&gt; &lt;branch_name&gt;</code></h3><p>比较两个<strong>分支</strong>之间的差异</p><hr><h2 id="8-Git-删除文件命令"><a href="#8-Git-删除文件命令" class="headerlink" title="8. Git 删除文件命令"></a>8. Git 删除文件命令</h2><h3 id="rm-file-git-add-file"><a href="#rm-file-git-add-file" class="headerlink" title="rm file; git add file"></a><code>rm file; git add file</code></h3><ul><li>先从<strong>工作区</strong>删除文件</li><li>然后使用 <code>git add</code> 让 Git 追踪这次删除（即加入暂存区）</li></ul><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm &lt;file&gt;"></a><code>git rm &lt;file&gt;</code></h3><ul><li>同时从<strong>工作区</strong>和<strong>暂存区</strong>删除文件</li></ul><h3 id="git-rm-cached"><a href="#git-rm-cached" class="headerlink" title="git rm --cached &lt;file&gt;"></a><code>git rm --cached &lt;file&gt;</code></h3><ul><li><strong>只从暂存区删除</strong>文件，但保留工作区中的文件（文件依然存在本地）</li></ul><h3 id="git-rm-r"><a href="#git-rm-r" class="headerlink" title="git rm -r *"></a><code>git rm -r *</code></h3><ul><li><strong>递归删除</strong>当前目录及子目录下的所有文件和文件夹</li></ul><blockquote><p><strong>提示</strong>：删除文件后记得使用 <code>git commit</code> 提交更改！</p></blockquote><hr><h2 id="9-gitignore忽略文件"><a href="#9-gitignore忽略文件" class="headerlink" title="9. gitignore忽略文件"></a>9. gitignore忽略文件</h2><h3 id="常见忽略文件列表"><a href="#常见忽略文件列表" class="headerlink" title="常见忽略文件列表"></a>常见忽略文件列表</h3><ul><li>忽略日志文件和日志目录</li><li>忽略所有 <code>.class</code> 文件</li><li>忽略所有 <code>.o</code> 文件（编译生成的中间文件）</li><li>忽略所有 <code>.env</code> 文件（包含环境变量配置）</li><li>忽略所有 <code>.zip</code> 和 <code>.tar</code> 压缩包</li><li>忽略所有 <code>.pem</code> 文件（安全凭证）</li></ul><h3 id="一般应该忽略的文件类型"><a href="#一般应该忽略的文件类型" class="headerlink" title="一般应该忽略的文件类型"></a>一般应该忽略的文件类型</h3><ul><li><strong>系统或软件自动生成的文件</strong></li><li><strong>编译产生的中间文件和结果文件</strong></li><li><strong>运行时生成的日志、缓存、临时文件</strong></li><li><strong>涉及身份、密码、口令、秘钥等敏感信息的文件</strong></li></ul><h3 id="示例-gitignore-文件内容"><a href="#示例-gitignore-文件内容" class="headerlink" title="示例 .gitignore 文件内容"></a>示例 <code>.gitignore</code> 文件内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 日志文件</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># 编译输出</span><br><span class="line">*.class</span><br><span class="line">*.o</span><br><span class="line"></span><br><span class="line"># 环境变量</span><br><span class="line">.env</span><br><span class="line"></span><br><span class="line"># 压缩包</span><br><span class="line">*.zip</span><br><span class="line">*.tar</span><br><span class="line"></span><br><span class="line"># 安全证书等敏感信息</span><br><span class="line">*.pem</span><br></pre></td></tr></table></figure><hr><h2 id="10-SSH配置"><a href="#10-SSH配置" class="headerlink" title="10. SSH配置"></a>10. SSH配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 回到根目录</span></span><br><span class="line"><span class="built_in">cd</span> ~ 或者 <span class="built_in">cd</span> 直接回车</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入ssh文件夹</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 生成ssh密钥</span></span><br><span class="line">ssh-keygen -t rsa -b 4096</span><br><span class="line"><span class="comment"># -t代表协议为rsa</span></span><br><span class="line"><span class="comment"># -b代表生成大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 回车后提醒输入密钥名称</span></span><br><span class="line"><span class="comment"># 如果是第一次使用这个命令，直接回车就行了，使用默认的名称id_rsa</span></span><br><span class="line"><span class="comment"># 如果之前用过最好不要直接回车，会覆盖掉之前的密钥，且操作不可逆</span></span><br><span class="line"><span class="comment"># 输入一个新的名字例如test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 再回车后提醒输入密码，可以为空直接回车</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 可以看到本地生成了两个文件，一个密钥，一个密钥.pub</span></span><br><span class="line"><span class="comment"># 私钥文件谁都不要给，公钥打开复制到github</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 点开头像-设置-ssh和gpg密钥配置--new ssh key --然后起个名字将公钥粘贴进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 如果是第一次配置默认的名称，到此就结束了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 如果是自己命名的密钥</span></span><br><span class="line"><span class="comment"># 打开 ~/.ssh/config 文件，如果没有就创建，如果有就附加在后面</span></span><br><span class="line"><span class="comment"># 填入</span></span><br><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/test</span><br><span class="line"><span class="comment"># 意思是访问github时指定访问test密钥</span></span><br></pre></td></tr></table></figure><h3 id="SSH通过HTTPS端口连接GitHub-解决网络问题"><a href="#SSH通过HTTPS端口连接GitHub-解决网络问题" class="headerlink" title="SSH通过HTTPS端口连接GitHub (解决网络问题)"></a>SSH通过HTTPS端口连接GitHub (解决网络问题)</h3><p>当无法通过SSH默认端口访问GitHub时，可以通过HTTPS端口(443)绕过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑SSH配置文件</span></span><br><span class="line">nano ~/.ssh/config</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">vim ~/.ssh/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下配置</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName ssh.github.com</span><br><span class="line">    Port 443</span><br><span class="line">    User git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试连接</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># 成功会显示：Hi username! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在可以正常克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:Git-xfy/remote-repo.git</span><br></pre></td></tr></table></figure><p><strong>这种方法有效的原因</strong>:</p><ol><li>许多公司和网络环境会阻止SSH的标准端口(22)，但允许HTTPS端口(443)</li><li>这种方法仍使用SSH协议及其安全特性和密钥认证</li><li>通信通过通常允许的HTTPS端口传输，从而绕过防火墙限制</li></ol><hr><h2 id="11-关联本地仓库和远程仓库"><a href="#11-关联本地仓库和远程仓库" class="headerlink" title="11. 关联本地仓库和远程仓库"></a>11. 关联本地仓库和远程仓库</h2><h3 id="git-remote-add"><a href="#git-remote-add" class="headerlink" title="git remote add &lt;shortname&gt; &lt;url&gt;"></a><code>git remote add &lt;shortname&gt; &lt;url&gt;</code></h3><ul><li>shortname - 起一个短名字，一般都是origin</li><li>url - 要关联的远程仓库地址</li></ul><h3 id="git-remote-v"><a href="#git-remote-v" class="headerlink" title="git remote -v"></a><code>git remote -v</code></h3><p>查看当前仓库所对应的远程仓库的别名和地址</p><h3 id="git-branch-M-main"><a href="#git-branch-M-main" class="headerlink" title="git branch -M main"></a><code>git branch -M main</code></h3><p>将本地仓库当前分支命名为main</p><ul><li>GitHub默认的主分支名称是main，而本地分支有时候默认是master</li><li>如果已经设置过默认分支为main，则不需要此操作</li></ul><h3 id="git-push-u-origin-main"><a href="#git-push-u-origin-main" class="headerlink" title="git push -u origin main"></a><code>git push -u origin main</code></h3><p>把本地分支和远程分支的main关联起来</p><ul><li>全称是<code>git push -u origin main:main</code></li><li>将本地的main分支（冒号前）与远程main分支（冒号后）关联起来</li><li>名称一样可以省略一个</li></ul><h3 id="简化命令"><a href="#简化命令" class="headerlink" title="简化命令"></a>简化命令</h3><ul><li>关联后可以直接使用 <code>git push</code></li><li>未关联则需使用 <code>git push &lt;remote_name&gt; &lt;local_branch_name&gt;:&lt;remote_branch_name&gt;</code></li></ul><h3 id="拉取命令"><a href="#拉取命令" class="headerlink" title="拉取命令"></a>拉取命令</h3><ul><li>关联后：<code>git pull</code></li><li>未关联：<code>git pull &lt;remote_name&gt; &lt;local_branch_name&gt;:&lt;remote_branch_name&gt;</code></li><li>省略时默认拉取origin的main分支</li><li><code>git pull</code> 会自动合并，如有冲突需解决</li><li><code>git fetch</code> 是获取后不自动合并</li></ul><p><img src="https://fyblog.oss-cn-shanghai.aliyuncs.com/blog/20250423170207574.png" alt="拉取示意图"></p><hr><h2 id="12-分支的基本操作"><a href="#12-分支的基本操作" class="headerlink" title="12. 分支的基本操作"></a>12. 分支的基本操作</h2><h3 id="查看分支列表"><a href="#查看分支列表" class="headerlink" title="查看分支列表"></a>查看分支列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统方式</span></span><br><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐方式（Git 2.23+）</span></span><br><span class="line">git switch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><ul><li><strong>已合并的分支</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>未合并的分支</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：分支操作前，建议先查看当前分支状态：<code>git status</code>。合并前确保工作区干净，删除前确认无误。</p></blockquote><hr><h2 id="13-解决合并冲突"><a href="#13-解决合并冲突" class="headerlink" title="13. 解决合并冲突"></a>13. 解决合并冲突</h2><h3 id="冲突说明"><a href="#冲突说明" class="headerlink" title="冲突说明"></a>冲突说明</h3><ul><li><strong>若两个分支修改了同一个文件的不同位置</strong> → Git会自动合并 ✓</li><li><strong>若两个分支修改了同一个文件的相同位置</strong> → 发生冲突 ✗</li></ul><h3 id="解决冲突步骤"><a href="#解决冲突步骤" class="headerlink" title="解决冲突步骤"></a>解决冲突步骤</h3><ol><li><strong>手动修改冲突文件</strong>，处理冲突内容</li><li><strong>添加到暂存区</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><strong>提交更改</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;解决合并冲突&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="中止合并操作"><a href="#中止合并操作" class="headerlink" title="中止合并操作"></a>中止合并操作</h3><p>如果不想继续合并，可使用以下命令中止合并过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：合并冲突发生时，Git会标记冲突区域（如 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>），你需要手动选择保留哪一部分内容。</p></blockquote><hr><h2 id="14-回退和Rebase"><a href="#14-回退和Rebase" class="headerlink" title="14. 回退和Rebase"></a>14. 回退和Rebase</h2><h3 id="Git-Rebase（变基）"><a href="#Git-Rebase（变基）" class="headerlink" title="Git Rebase（变基）"></a>Git Rebase（变基）</h3><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>将当前分支的提交”转移”到目标分支的最新提交之后，<strong>重写提交历史</strong>。</p><h3 id="Rebase-vs-Merge-区别"><a href="#Rebase-vs-Merge-区别" class="headerlink" title="Rebase vs Merge 区别"></a>Rebase vs Merge 区别</h3><table><thead><tr><th>比较项</th><th><code>git merge</code></th><th><code>git rebase</code></th></tr></thead><tbody><tr><td>历史记录</td><td>保留分支历史，产生合并提交</td><td>重写提交历史，线性、干净</td></tr><tr><td>可读性</td><td>可能出现分叉，历史分支交错</td><td>历史更线性，便于回顾</td></tr><tr><td>是否生成新提交</td><td>会生成一个合并提交</td><td>不会生成合并提交，重用原提交</td></tr><tr><td>冲突处理</td><td>只处理一次冲突</td><td>每次变基提交可能都需手动解决冲突</td></tr></tbody></table><h3 id="什么时候用什么？"><a href="#什么时候用什么？" class="headerlink" title="什么时候用什么？"></a>什么时候用什么？</h3><ul><li><p><strong>使用 <code>merge</code></strong>：</p><ul><li>团队协作中保留分支历史</li><li>避免修改提交历史</li><li>合并已推送的公共分支</li></ul></li><li><p><strong>使用 <code>rebase</code></strong>：</p><ul><li>自己在本地整理提交历史</li><li>保持提交历史简洁、线性</li><li>合并前清理开发分支历史，提升可读性</li></ul></li></ul><blockquote><p><strong>小提示</strong>：</p><ul><li><code>rebase</code> 更适合<strong>个人分支开发阶段</strong></li><li><code>merge</code> 更适合<strong>团队协作与主分支合并</strong></li><li>注意：不要对已经推送到远程的公共分支使用 <code>rebase</code>，可能导致历史冲突！</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
